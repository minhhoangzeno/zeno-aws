/**
 * api
 * plan-de-transport-api
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://localhost/api".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface Account {
    "name"?: string;
    "avatar"?: string;
    "phone"?: string;
    "typeRole"?: string;
    "realm"?: string;
    "username"?: string;
    "email": string;
    "emailVerified"?: boolean;
    "id"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
    "teamId"?: number;
}

export interface AccountToken {
    "id": string;
    /**
     * time to live in seconds (2 weeks by default)
     */
    "ttl"?: number;
    /**
     * Array of scopes granted to this access token.
     */
    "scopes"?: Array<string>;
    "created"?: Date;
    "userId"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface DurationTime {
    "title"?: string;
    "id"?: number;
    "leaderId"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface InlineResponse200 {
    "undefined"?: any;
}

export interface InlineResponse2001 {
    "result"?: any;
}

export interface InlineResponse2002 {
    "count"?: number;
}

export interface InlineResponse2003 {
    "exists"?: boolean;
}

/**
 * Information related to the outcome of the operation
 */
export interface InlineResponse2004 {
    /**
     * The number of instances updated
     */
    "count"?: number;
}

export interface Order {
    "numberOfCall"?: number;
    "numberOfAdvise"?: number;
    "numberOfOrder"?: number;
    "numberOfAccepted"?: number;
    "revenueOfOrder"?: number;
    "revenueOfAccepted"?: number;
    "id"?: number;
    "accountId"?: number;
    "durationTimeId"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
    "teamId"?: number;
}

export interface Role {
    "id"?: number;
    "name": string;
    "description"?: string;
    "created"?: Date;
    "modified"?: Date;
}

/**
 * Map principals to roles
 */
export interface RoleMapping {
    "id"?: number;
    /**
     * The principal type, such as USER, APPLICATION, ROLE, or user model name in case of multiple user models
     */
    "principalType"?: string;
    "principalId"?: string;
    "roleId"?: number;
}

export interface Target {
    "revenue"?: number;
    "worksday"?: number;
    "month"?: Date;
    "id"?: number;
    "accountId"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface Team {
    "name"?: string;
    "id"?: number;
    "leaderId"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}



/**
 * AccountApi - fetch parameter creator
 */
export const AccountApiFetchParamCreator = {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    accountChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any): FetchArgs {
        // verify required parameter "oldPassword" is set
        if (params["oldPassword"] == null) {
            throw new Error("Missing required parameter oldPassword when calling accountChangePassword");
        }
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountChangePassword");
        }
        const baseUrl = `/Accounts/change-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "oldPassword": params["oldPassword"],
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Change role of user
     * @param data context of request
     */
    accountChangeRole(params: {  "data": string; }, options?: any): FetchArgs {
        // verify required parameter "data" is set
        if (params["data"] == null) {
            throw new Error("Missing required parameter data when calling accountChangeRole");
        }
        const baseUrl = `/Accounts/change-role`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "data": params["data"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    accountConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any): FetchArgs {
        // verify required parameter "uid" is set
        if (params["uid"] == null) {
            throw new Error("Missing required parameter uid when calling accountConfirm");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            throw new Error("Missing required parameter token when calling accountConfirm");
        }
        const baseUrl = `/Accounts/confirm`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "uid": params["uid"],
            "token": params["token"],
            "redirect": params["redirect"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamGetAccountsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamPostAccountsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountDeleteById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsGetAccountsidExists");
        }
        const baseUrl = `/Accounts/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsHeadAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountFindById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get account by token
     */
    accountGetMe(options?: any): FetchArgs {
        const baseUrl = `/Accounts/get-me`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params: {  "credentials": any; "include"?: string; }, options?: any): FetchArgs {
        // verify required parameter "credentials" is set
        if (params["credentials"] == null) {
            throw new Error("Missing required parameter credentials when calling accountLogin");
        }
        const baseUrl = `/Accounts/login`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "include": params["include"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["credentials"]) {
            fetchOptions.body = JSON.stringify(params["credentials"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Logout a user with access token.
     */
    accountLogout(options?: any): FetchArgs {
        const baseUrl = `/Accounts/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccountToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateRoles(params: {  "id": string; "data"?: Role; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeExistsRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeExistsRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetRoles(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation team.
     * @param id Account id
     * @param refresh 
     */
    accountPrototypeGetTeam(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetTeam");
        }
        const baseUrl = `/Accounts/{id}/team`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeLinkRoles(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeLinkRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeLinkRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypePatchAttributes");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUnlinkRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUnlinkRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    accountPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccountToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeUpdateByIdRoles(params: {  "id": string; "fk": string; "data"?: Role; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeVerify");
        }
        const baseUrl = `/Accounts/{id}/verify`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPostAccountsidReplace");
        }
        const baseUrl = `/Accounts/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPutAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    accountResetPassword(params: {  "options": any; }, options?: any): FetchArgs {
        // verify required parameter "options" is set
        if (params["options"] == null) {
            throw new Error("Missing required parameter options when calling accountResetPassword");
        }
        const baseUrl = `/Accounts/reset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    accountSetPassword(params: {  "newPassword": string; }, options?: any): FetchArgs {
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountSetPassword");
        }
        const baseUrl = `/Accounts/reset-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params: {  "where"?: string; "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params: {  "where"?: string; "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AccountApi - functional programming interface
 */
export const AccountApiFp = {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    accountChangePassword(params: { "oldPassword": string; "newPassword": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountChangePassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Change role of user
     * @param data context of request
     */
    accountChangeRole(params: { "data": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountChangeRole(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    accountConfirm(params: { "uid": string; "token": string; "redirect"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountConfirm(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AccountApiFetchParamCreator.accountCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamGetAccountsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountCreateChangeStreamGetAccountsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamPostAccountsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountCreateChangeStreamPostAccountsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = AccountApiFetchParamCreator.accountExistsGetAccountsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = AccountApiFetchParamCreator.accountExistsHeadAccountsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
        const fetchArgs = AccountApiFetchParamCreator.accountFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get account by token
     */
    accountGetMe(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountGetMe(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params: { "credentials": any; "include"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountLogin(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Logout a user with access token.
     */
    accountLogout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountLogout(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateAccessTokens(params: { "id": string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateRoles(params: { "id": string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeExistsRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetAccessTokens(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccountToken>> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetRoles(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Role>> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation team.
     * @param id Account id
     * @param refresh 
     */
    accountPrototypeGetTeam(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetTeam(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeLinkRoles(params: { "id": string; "fk": string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeLinkRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUnlinkRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    accountPrototypeUpdateByIdAccessTokens(params: { "id": string; "fk": string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeUpdateByIdRoles(params: { "id": string; "fk": string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeVerify(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceByIdPostAccountsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceByIdPutAccountsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceOrCreatePutAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    accountResetPassword(params: { "options": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountResetPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    accountSetPassword(params: { "newPassword": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountSetPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params: { "where"?: string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = AccountApiFetchParamCreator.accountUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params: { "where"?: string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AccountApi - object-oriented interface
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    accountChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any) {
        return AccountApiFp.accountChangePassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Change role of user
     * @param data context of request
     */
    accountChangeRole(params: {  "data": string; }, options?: any) {
        return AccountApiFp.accountChangeRole(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    accountConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any) {
        return AccountApiFp.accountConfirm(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params: {  "where"?: string; }, options?: any) {
        return AccountApiFp.accountCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamGetAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamPostAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountExistsGetAccountsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountExistsHeadAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params: {  "filter"?: string; }, options?: any) {
        return AccountApiFp.accountFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params: {  "filter"?: string; }, options?: any) {
        return AccountApiFp.accountFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get account by token
     */
    accountGetMe(options?: any) {
        return AccountApiFp.accountGetMe(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params: {  "credentials": any; "include"?: string; }, options?: any) {
        return AccountApiFp.accountLogin(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Logout a user with access token.
     */
    accountLogout(options?: any) {
        return AccountApiFp.accountLogout(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeCountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params: {  "id": string; "where"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeCountRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
        return AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateRoles(params: {  "id": string; "data"?: Role; }, options?: any) {
        return AccountApiFp.accountPrototypeCreateRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDeleteRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeExistsRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeFindByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeGetAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetRoles(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeGetRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation team.
     * @param id Account id
     * @param refresh 
     */
    accountPrototypeGetTeam(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return AccountApiFp.accountPrototypeGetTeam(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeLinkRoles(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any) {
        return AccountApiFp.accountPrototypeLinkRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params: {  "id": string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeUnlinkRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    accountPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccountToken; }, options?: any) {
        return AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeUpdateByIdRoles(params: {  "id": string; "fk": string; "data"?: Role; }, options?: any) {
        return AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeVerify(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params: {  "id": string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params: {  "id": string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    accountResetPassword(params: {  "options": any; }, options?: any) {
        return AccountApiFp.accountResetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    accountSetPassword(params: {  "newPassword": string; }, options?: any) {
        return AccountApiFp.accountSetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params: {  "where"?: string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params: {  "where"?: string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AccountApi - factory interface
 */
export const AccountApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Change a user's password.
         * @param oldPassword 
         * @param newPassword 
         */
        accountChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any) {
            return AccountApiFp.accountChangePassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Change role of user
         * @param data context of request
         */
        accountChangeRole(params: {  "data": string; }, options?: any) {
            return AccountApiFp.accountChangeRole(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Confirm a user registration with identity verification token.
         * @param uid 
         * @param token 
         * @param redirect 
         */
        accountConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any) {
            return AccountApiFp.accountConfirm(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountCount(params: {  "where"?: string; }, options?: any) {
            return AccountApiFp.accountCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountCreate(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountCreateChangeStreamGetAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountCreateChangeStreamPostAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountDeleteById(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsGetAccountsidExists(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountExistsGetAccountsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsHeadAccountsid(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountExistsHeadAccountsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFind(params: {  "filter"?: string; }, options?: any) {
            return AccountApiFp.accountFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFindOne(params: {  "filter"?: string; }, options?: any) {
            return AccountApiFp.accountFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get account by token
         */
        accountGetMe(options?: any) {
            return AccountApiFp.accountGetMe(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Login a user with username/email and password.
         * @param credentials 
         * @param include Related objects to include in the response. See the description of return value for more details.
         */
        accountLogin(params: {  "credentials": any; "include"?: string; }, options?: any) {
            return AccountApiFp.accountLogin(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logout a user with access token.
         */
        accountLogout(options?: any) {
            return AccountApiFp.accountLogout(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountPatchOrCreate(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts accessTokens of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeCountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts roles of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountRoles(params: {  "id": string; "where"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeCountRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in accessTokens of this model.
         * @param id Account id
         * @param data 
         */
        accountPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
            return AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in roles of this model.
         * @param id Account id
         * @param data 
         */
        accountPrototypeCreateRoles(params: {  "id": string; "data"?: Role; }, options?: any) {
            return AccountApiFp.accountPrototypeCreateRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all accessTokens of this model.
         * @param id Account id
         */
        accountPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all roles of this model.
         * @param id Account id
         */
        accountPrototypeDeleteRoles(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDeleteRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeDestroyByIdRoles(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check the existence of roles relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeExistsRoles(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeExistsRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeFindByIdRoles(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeFindByIdRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries accessTokens of Account.
         * @param id Account id
         * @param filter 
         */
        accountPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeGetAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries roles of Account.
         * @param id Account id
         * @param filter 
         */
        accountPrototypeGetRoles(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeGetRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation team.
         * @param id Account id
         * @param refresh 
         */
        accountPrototypeGetTeam(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return AccountApiFp.accountPrototypeGetTeam(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         * @param data 
         */
        accountPrototypeLinkRoles(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any) {
            return AccountApiFp.accountPrototypeLinkRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Account id
         * @param data An object of model property name/value pairs
         */
        accountPrototypePatchAttributes(params: {  "id": string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the roles relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeUnlinkRoles(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeUnlinkRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         * @param data 
         */
        accountPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccountToken; }, options?: any) {
            return AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         * @param data 
         */
        accountPrototypeUpdateByIdRoles(params: {  "id": string; "fk": string; "data"?: Role; }, options?: any) {
            return AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Trigger user's identity verification with configured verifyOptions
         * @param id Account id
         */
        accountPrototypeVerify(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeVerify(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPostAccountsidReplace(params: {  "id": string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPutAccountsid(params: {  "id": string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePostAccountsReplaceOrCreate(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePutAccounts(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset password for a user with email.
         * @param options 
         */
        accountResetPassword(params: {  "options": any; }, options?: any) {
            return AccountApiFp.accountResetPassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset user's password via a password-reset token.
         * @param newPassword 
         */
        accountSetPassword(params: {  "newPassword": string; }, options?: any) {
            return AccountApiFp.accountSetPassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpdateAll(params: {  "where"?: string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpsertWithWhere(params: {  "where"?: string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * AccountTokenApi - fetch parameter creator
 */
export const AccountTokenApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params: {  "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenDeleteById");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenExistsGetAccountTokensidExists");
        }
        const baseUrl = `/AccountTokens/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenExistsHeadAccountTokensid");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenFindById");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params: {  "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh 
     */
    accountTokenPrototypeGetUser(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenPrototypeGetUser");
        }
        const baseUrl = `/AccountTokens/{id}/user`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params: {  "id": string; "data"?: AccountToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenPrototypePatchAttributes");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params: {  "id": string; "data"?: AccountToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenReplaceByIdPostAccountTokensidReplace");
        }
        const baseUrl = `/AccountTokens/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params: {  "id": string; "data"?: AccountToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenReplaceByIdPutAccountTokensid");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params: {  "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params: {  "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params: {  "where"?: string; "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params: {  "where"?: string; "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AccountTokenApi - functional programming interface
 */
export const AccountTokenApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params: { "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenExistsGetAccountTokensidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenExistsHeadAccountTokensid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccountToken>> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params: { "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh 
     */
    accountTokenPrototypeGetUser(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenPrototypeGetUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params: { "id": string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params: { "id": string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenReplaceByIdPostAccountTokensidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params: { "id": string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenReplaceByIdPutAccountTokensid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params: { "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params: { "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenReplaceOrCreatePutAccountTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params: { "where"?: string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params: { "where"?: string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AccountTokenApi - object-oriented interface
 */
export class AccountTokenApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params: {  "where"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params: {  "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params: {  "id": string; }, options?: any) {
        return AccountTokenApiFp.accountTokenDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params: {  "id": string; }, options?: any) {
        return AccountTokenApiFp.accountTokenExistsGetAccountTokensidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params: {  "id": string; }, options?: any) {
        return AccountTokenApiFp.accountTokenExistsHeadAccountTokensid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params: {  "filter"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params: {  "filter"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params: {  "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh 
     */
    accountTokenPrototypeGetUser(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return AccountTokenApiFp.accountTokenPrototypeGetUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenReplaceByIdPostAccountTokensidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenReplaceByIdPutAccountTokensid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params: {  "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params: {  "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenReplaceOrCreatePutAccountTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params: {  "where"?: string; "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params: {  "where"?: string; "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AccountTokenApi - factory interface
 */
export const AccountTokenApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountTokenCount(params: {  "where"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountTokenCreate(params: {  "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountTokenCreateChangeStreamGetAccountTokensChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountTokenCreateChangeStreamPostAccountTokensChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountTokenDeleteById(params: {  "id": string; }, options?: any) {
            return AccountTokenApiFp.accountTokenDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountTokenExistsGetAccountTokensidExists(params: {  "id": string; }, options?: any) {
            return AccountTokenApiFp.accountTokenExistsGetAccountTokensidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountTokenExistsHeadAccountTokensid(params: {  "id": string; }, options?: any) {
            return AccountTokenApiFp.accountTokenExistsHeadAccountTokensid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountTokenFind(params: {  "filter"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountTokenFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountTokenFindOne(params: {  "filter"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenPatchOrCreate(params: {  "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation user.
         * @param id AccountToken id
         * @param refresh 
         */
        accountTokenPrototypeGetUser(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return AccountTokenApiFp.accountTokenPrototypeGetUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id AccountToken id
         * @param data An object of model property name/value pairs
         */
        accountTokenPrototypePatchAttributes(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountTokenReplaceByIdPostAccountTokensidReplace(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenReplaceByIdPostAccountTokensidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountTokenReplaceByIdPutAccountTokensid(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenReplaceByIdPutAccountTokensid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params: {  "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenReplaceOrCreatePutAccountTokens(params: {  "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenReplaceOrCreatePutAccountTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountTokenUpdateAll(params: {  "where"?: string; "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountTokenUpsertWithWhere(params: {  "where"?: string; "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * ContainerApi - fetch parameter creator
 */
export const ContainerApiFetchParamCreator = {
    /**
     * 
     * @param options 
     */
    containerCreateContainer(params: {  "options"?: any; }, options?: any): FetchArgs {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerDestroyContainer(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerDestroyContainer");
        }
        const baseUrl = `/Containers/{container}`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerDownload(params: {  "container": string; "file": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerDownload");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerDownload");
        }
        const baseUrl = `/Containers/{container}/download/{file}`
            .replace(`{${"container"}}`, `${ params["container"] }`)
            .replace(`{${"file"}}`, `${ params["file"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetContainer(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetContainer");
        }
        const baseUrl = `/Containers/{container}`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    containerGetContainers(options?: any): FetchArgs {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerGetFile(params: {  "container": string; "file": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetFile");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerGetFile");
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${"container"}}`, `${ params["container"] }`)
            .replace(`{${"file"}}`, `${ params["file"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetFiles(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetFiles");
        }
        const baseUrl = `/Containers/{container}/files`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerRemoveFile(params: {  "container": string; "file": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerRemoveFile");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerRemoveFile");
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${"container"}}`, `${ params["container"] }`)
            .replace(`{${"file"}}`, `${ params["file"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerUpload(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerUpload");
        }
        const baseUrl = `/Containers/{container}/upload`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ContainerApi - functional programming interface
 */
export const ContainerApiFp = {
    /**
     * 
     * @param options 
     */
    containerCreateContainer(params: { "options"?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerCreateContainer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerDestroyContainer(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = ContainerApiFetchParamCreator.containerDestroyContainer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerDownload(params: { "container": string; "file": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerDownload(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetContainer(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetContainer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    containerGetContainers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetContainers(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerGetFile(params: { "container": string; "file": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetFile(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetFiles(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetFiles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerRemoveFile(params: { "container": string; "file": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = ContainerApiFetchParamCreator.containerRemoveFile(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerUpload(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = ContainerApiFetchParamCreator.containerUpload(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ContainerApi - object-oriented interface
 */
export class ContainerApi extends BaseAPI {
    /**
     * 
     * @param options 
     */
    containerCreateContainer(params: {  "options"?: any; }, options?: any) {
        return ContainerApiFp.containerCreateContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerDestroyContainer(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerDestroyContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     * @param file 
     */
    containerDownload(params: {  "container": string; "file": string; }, options?: any) {
        return ContainerApiFp.containerDownload(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerGetContainer(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerGetContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    containerGetContainers(options?: any) {
        return ContainerApiFp.containerGetContainers(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     * @param file 
     */
    containerGetFile(params: {  "container": string; "file": string; }, options?: any) {
        return ContainerApiFp.containerGetFile(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerGetFiles(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerGetFiles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     * @param file 
     */
    containerRemoveFile(params: {  "container": string; "file": string; }, options?: any) {
        return ContainerApiFp.containerRemoveFile(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerUpload(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerUpload(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ContainerApi - factory interface
 */
export const ContainerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param options 
         */
        containerCreateContainer(params: {  "options"?: any; }, options?: any) {
            return ContainerApiFp.containerCreateContainer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerDestroyContainer(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerDestroyContainer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         * @param file 
         */
        containerDownload(params: {  "container": string; "file": string; }, options?: any) {
            return ContainerApiFp.containerDownload(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerGetContainer(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerGetContainer(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        containerGetContainers(options?: any) {
            return ContainerApiFp.containerGetContainers(options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         * @param file 
         */
        containerGetFile(params: {  "container": string; "file": string; }, options?: any) {
            return ContainerApiFp.containerGetFile(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerGetFiles(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerGetFiles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         * @param file 
         */
        containerRemoveFile(params: {  "container": string; "file": string; }, options?: any) {
            return ContainerApiFp.containerRemoveFile(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerUpload(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerUpload(params, options)(fetch, basePath);
        },
    };
};


/**
 * DurationTimeApi - fetch parameter creator
 */
export const DurationTimeApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    durationTimeCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/DurationTimes/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    durationTimeCreate(params: {  "data"?: DurationTime; }, options?: any): FetchArgs {
        const baseUrl = `/DurationTimes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    durationTimeCreateChangeStreamGetDurationTimesChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/DurationTimes/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    durationTimeCreateChangeStreamPostDurationTimesChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/DurationTimes/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    durationTimeDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling durationTimeDeleteById");
        }
        const baseUrl = `/DurationTimes/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    durationTimeExistsGetDurationTimesidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling durationTimeExistsGetDurationTimesidExists");
        }
        const baseUrl = `/DurationTimes/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    durationTimeExistsHeadDurationTimesid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling durationTimeExistsHeadDurationTimesid");
        }
        const baseUrl = `/DurationTimes/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    durationTimeFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/DurationTimes`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    durationTimeFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling durationTimeFindById");
        }
        const baseUrl = `/DurationTimes/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    durationTimeFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/DurationTimes/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimePatchOrCreate(params: {  "data"?: DurationTime; }, options?: any): FetchArgs {
        const baseUrl = `/DurationTimes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation leader.
     * @param id DurationTime id
     * @param refresh 
     */
    durationTimePrototypeGetLeader(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling durationTimePrototypeGetLeader");
        }
        const baseUrl = `/DurationTimes/{id}/leader`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id DurationTime id
     * @param data An object of model property name/value pairs
     */
    durationTimePrototypePatchAttributes(params: {  "id": string; "data"?: DurationTime; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling durationTimePrototypePatchAttributes");
        }
        const baseUrl = `/DurationTimes/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    durationTimeReplaceByIdPostDurationTimesidReplace(params: {  "id": string; "data"?: DurationTime; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling durationTimeReplaceByIdPostDurationTimesidReplace");
        }
        const baseUrl = `/DurationTimes/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    durationTimeReplaceByIdPutDurationTimesid(params: {  "id": string; "data"?: DurationTime; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling durationTimeReplaceByIdPutDurationTimesid");
        }
        const baseUrl = `/DurationTimes/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimeReplaceOrCreatePostDurationTimesReplaceOrCreate(params: {  "data"?: DurationTime; }, options?: any): FetchArgs {
        const baseUrl = `/DurationTimes/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimeReplaceOrCreatePutDurationTimes(params: {  "data"?: DurationTime; }, options?: any): FetchArgs {
        const baseUrl = `/DurationTimes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    durationTimeUpdateAll(params: {  "where"?: string; "data"?: DurationTime; }, options?: any): FetchArgs {
        const baseUrl = `/DurationTimes/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    durationTimeUpsertWithWhere(params: {  "where"?: string; "data"?: DurationTime; }, options?: any): FetchArgs {
        const baseUrl = `/DurationTimes/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * DurationTimeApi - functional programming interface
 */
export const DurationTimeApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    durationTimeCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimeCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    durationTimeCreate(params: { "data"?: DurationTime;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DurationTime> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimeCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    durationTimeCreateChangeStreamGetDurationTimesChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimeCreateChangeStreamGetDurationTimesChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    durationTimeCreateChangeStreamPostDurationTimesChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimeCreateChangeStreamPostDurationTimesChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    durationTimeDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimeDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    durationTimeExistsGetDurationTimesidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimeExistsGetDurationTimesidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    durationTimeExistsHeadDurationTimesid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimeExistsHeadDurationTimesid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    durationTimeFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DurationTime>> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimeFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    durationTimeFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DurationTime> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimeFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    durationTimeFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DurationTime> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimeFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimePatchOrCreate(params: { "data"?: DurationTime;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DurationTime> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimePatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation leader.
     * @param id DurationTime id
     * @param refresh 
     */
    durationTimePrototypeGetLeader(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimePrototypeGetLeader(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id DurationTime id
     * @param data An object of model property name/value pairs
     */
    durationTimePrototypePatchAttributes(params: { "id": string; "data"?: DurationTime;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DurationTime> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimePrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    durationTimeReplaceByIdPostDurationTimesidReplace(params: { "id": string; "data"?: DurationTime;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DurationTime> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimeReplaceByIdPostDurationTimesidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    durationTimeReplaceByIdPutDurationTimesid(params: { "id": string; "data"?: DurationTime;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DurationTime> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimeReplaceByIdPutDurationTimesid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimeReplaceOrCreatePostDurationTimesReplaceOrCreate(params: { "data"?: DurationTime;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DurationTime> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimeReplaceOrCreatePostDurationTimesReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimeReplaceOrCreatePutDurationTimes(params: { "data"?: DurationTime;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DurationTime> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimeReplaceOrCreatePutDurationTimes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    durationTimeUpdateAll(params: { "where"?: string; "data"?: DurationTime;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimeUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    durationTimeUpsertWithWhere(params: { "where"?: string; "data"?: DurationTime;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DurationTime> {
        const fetchArgs = DurationTimeApiFetchParamCreator.durationTimeUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * DurationTimeApi - object-oriented interface
 */
export class DurationTimeApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    durationTimeCount(params: {  "where"?: string; }, options?: any) {
        return DurationTimeApiFp.durationTimeCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    durationTimeCreate(params: {  "data"?: DurationTime; }, options?: any) {
        return DurationTimeApiFp.durationTimeCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    durationTimeCreateChangeStreamGetDurationTimesChangeStream(params: {  "options"?: string; }, options?: any) {
        return DurationTimeApiFp.durationTimeCreateChangeStreamGetDurationTimesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    durationTimeCreateChangeStreamPostDurationTimesChangeStream(params: {  "options"?: string; }, options?: any) {
        return DurationTimeApiFp.durationTimeCreateChangeStreamPostDurationTimesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    durationTimeDeleteById(params: {  "id": string; }, options?: any) {
        return DurationTimeApiFp.durationTimeDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    durationTimeExistsGetDurationTimesidExists(params: {  "id": string; }, options?: any) {
        return DurationTimeApiFp.durationTimeExistsGetDurationTimesidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    durationTimeExistsHeadDurationTimesid(params: {  "id": string; }, options?: any) {
        return DurationTimeApiFp.durationTimeExistsHeadDurationTimesid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    durationTimeFind(params: {  "filter"?: string; }, options?: any) {
        return DurationTimeApiFp.durationTimeFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    durationTimeFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return DurationTimeApiFp.durationTimeFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    durationTimeFindOne(params: {  "filter"?: string; }, options?: any) {
        return DurationTimeApiFp.durationTimeFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimePatchOrCreate(params: {  "data"?: DurationTime; }, options?: any) {
        return DurationTimeApiFp.durationTimePatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation leader.
     * @param id DurationTime id
     * @param refresh 
     */
    durationTimePrototypeGetLeader(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return DurationTimeApiFp.durationTimePrototypeGetLeader(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id DurationTime id
     * @param data An object of model property name/value pairs
     */
    durationTimePrototypePatchAttributes(params: {  "id": string; "data"?: DurationTime; }, options?: any) {
        return DurationTimeApiFp.durationTimePrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    durationTimeReplaceByIdPostDurationTimesidReplace(params: {  "id": string; "data"?: DurationTime; }, options?: any) {
        return DurationTimeApiFp.durationTimeReplaceByIdPostDurationTimesidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    durationTimeReplaceByIdPutDurationTimesid(params: {  "id": string; "data"?: DurationTime; }, options?: any) {
        return DurationTimeApiFp.durationTimeReplaceByIdPutDurationTimesid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimeReplaceOrCreatePostDurationTimesReplaceOrCreate(params: {  "data"?: DurationTime; }, options?: any) {
        return DurationTimeApiFp.durationTimeReplaceOrCreatePostDurationTimesReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimeReplaceOrCreatePutDurationTimes(params: {  "data"?: DurationTime; }, options?: any) {
        return DurationTimeApiFp.durationTimeReplaceOrCreatePutDurationTimes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    durationTimeUpdateAll(params: {  "where"?: string; "data"?: DurationTime; }, options?: any) {
        return DurationTimeApiFp.durationTimeUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    durationTimeUpsertWithWhere(params: {  "where"?: string; "data"?: DurationTime; }, options?: any) {
        return DurationTimeApiFp.durationTimeUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * DurationTimeApi - factory interface
 */
export const DurationTimeApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        durationTimeCount(params: {  "where"?: string; }, options?: any) {
            return DurationTimeApiFp.durationTimeCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        durationTimeCreate(params: {  "data"?: DurationTime; }, options?: any) {
            return DurationTimeApiFp.durationTimeCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        durationTimeCreateChangeStreamGetDurationTimesChangeStream(params: {  "options"?: string; }, options?: any) {
            return DurationTimeApiFp.durationTimeCreateChangeStreamGetDurationTimesChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        durationTimeCreateChangeStreamPostDurationTimesChangeStream(params: {  "options"?: string; }, options?: any) {
            return DurationTimeApiFp.durationTimeCreateChangeStreamPostDurationTimesChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        durationTimeDeleteById(params: {  "id": string; }, options?: any) {
            return DurationTimeApiFp.durationTimeDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        durationTimeExistsGetDurationTimesidExists(params: {  "id": string; }, options?: any) {
            return DurationTimeApiFp.durationTimeExistsGetDurationTimesidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        durationTimeExistsHeadDurationTimesid(params: {  "id": string; }, options?: any) {
            return DurationTimeApiFp.durationTimeExistsHeadDurationTimesid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        durationTimeFind(params: {  "filter"?: string; }, options?: any) {
            return DurationTimeApiFp.durationTimeFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        durationTimeFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return DurationTimeApiFp.durationTimeFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        durationTimeFindOne(params: {  "filter"?: string; }, options?: any) {
            return DurationTimeApiFp.durationTimeFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        durationTimePatchOrCreate(params: {  "data"?: DurationTime; }, options?: any) {
            return DurationTimeApiFp.durationTimePatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation leader.
         * @param id DurationTime id
         * @param refresh 
         */
        durationTimePrototypeGetLeader(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return DurationTimeApiFp.durationTimePrototypeGetLeader(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id DurationTime id
         * @param data An object of model property name/value pairs
         */
        durationTimePrototypePatchAttributes(params: {  "id": string; "data"?: DurationTime; }, options?: any) {
            return DurationTimeApiFp.durationTimePrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        durationTimeReplaceByIdPostDurationTimesidReplace(params: {  "id": string; "data"?: DurationTime; }, options?: any) {
            return DurationTimeApiFp.durationTimeReplaceByIdPostDurationTimesidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        durationTimeReplaceByIdPutDurationTimesid(params: {  "id": string; "data"?: DurationTime; }, options?: any) {
            return DurationTimeApiFp.durationTimeReplaceByIdPutDurationTimesid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        durationTimeReplaceOrCreatePostDurationTimesReplaceOrCreate(params: {  "data"?: DurationTime; }, options?: any) {
            return DurationTimeApiFp.durationTimeReplaceOrCreatePostDurationTimesReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        durationTimeReplaceOrCreatePutDurationTimes(params: {  "data"?: DurationTime; }, options?: any) {
            return DurationTimeApiFp.durationTimeReplaceOrCreatePutDurationTimes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        durationTimeUpdateAll(params: {  "where"?: string; "data"?: DurationTime; }, options?: any) {
            return DurationTimeApiFp.durationTimeUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        durationTimeUpsertWithWhere(params: {  "where"?: string; "data"?: DurationTime; }, options?: any) {
            return DurationTimeApiFp.durationTimeUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * OrderApi - fetch parameter creator
 */
export const OrderApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Orders/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderCreate(params: {  "data"?: Order; }, options?: any): FetchArgs {
        const baseUrl = `/Orders`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderCreateChangeStreamGetOrdersChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Orders/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderCreateChangeStreamPostOrdersChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Orders/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderDeleteById");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsGetOrdersidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderExistsGetOrdersidExists");
        }
        const baseUrl = `/Orders/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsHeadOrdersid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderExistsHeadOrdersid");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Orders`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderFindById");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Orders/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderPatchOrCreate(params: {  "data"?: Order; }, options?: any): FetchArgs {
        const baseUrl = `/Orders`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Order id
     * @param refresh 
     */
    orderPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeGetAccount");
        }
        const baseUrl = `/Orders/{id}/account`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation durationTime.
     * @param id Order id
     * @param refresh 
     */
    orderPrototypeGetDurationTime(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeGetDurationTime");
        }
        const baseUrl = `/Orders/{id}/durationTime`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation team.
     * @param id Order id
     * @param refresh 
     */
    orderPrototypeGetTeam(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeGetTeam");
        }
        const baseUrl = `/Orders/{id}/team`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Order id
     * @param data An object of model property name/value pairs
     */
    orderPrototypePatchAttributes(params: {  "id": string; "data"?: Order; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypePatchAttributes");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPostOrdersidReplace(params: {  "id": string; "data"?: Order; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderReplaceByIdPostOrdersidReplace");
        }
        const baseUrl = `/Orders/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPutOrdersid(params: {  "id": string; "data"?: Order; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderReplaceByIdPutOrdersid");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePostOrdersReplaceOrCreate(params: {  "data"?: Order; }, options?: any): FetchArgs {
        const baseUrl = `/Orders/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePutOrders(params: {  "data"?: Order; }, options?: any): FetchArgs {
        const baseUrl = `/Orders`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpdateAll(params: {  "where"?: string; "data"?: Order; }, options?: any): FetchArgs {
        const baseUrl = `/Orders/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpsertWithWhere(params: {  "where"?: string; "data"?: Order; }, options?: any): FetchArgs {
        const baseUrl = `/Orders/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * OrderApi - functional programming interface
 */
export const OrderApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = OrderApiFetchParamCreator.orderCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderCreate(params: { "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderCreateChangeStreamGetOrdersChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreator.orderCreateChangeStreamGetOrdersChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderCreateChangeStreamPostOrdersChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreator.orderCreateChangeStreamPostOrdersChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreator.orderDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsGetOrdersidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = OrderApiFetchParamCreator.orderExistsGetOrdersidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsHeadOrdersid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = OrderApiFetchParamCreator.orderExistsHeadOrdersid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Order>> {
        const fetchArgs = OrderApiFetchParamCreator.orderFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderPatchOrCreate(params: { "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Order id
     * @param refresh 
     */
    orderPrototypeGetAccount(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = OrderApiFetchParamCreator.orderPrototypeGetAccount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation durationTime.
     * @param id Order id
     * @param refresh 
     */
    orderPrototypeGetDurationTime(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DurationTime> {
        const fetchArgs = OrderApiFetchParamCreator.orderPrototypeGetDurationTime(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation team.
     * @param id Order id
     * @param refresh 
     */
    orderPrototypeGetTeam(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
        const fetchArgs = OrderApiFetchParamCreator.orderPrototypeGetTeam(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Order id
     * @param data An object of model property name/value pairs
     */
    orderPrototypePatchAttributes(params: { "id": string; "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPostOrdersidReplace(params: { "id": string; "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderReplaceByIdPostOrdersidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPutOrdersid(params: { "id": string; "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderReplaceByIdPutOrdersid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePostOrdersReplaceOrCreate(params: { "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePutOrders(params: { "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderReplaceOrCreatePutOrders(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpdateAll(params: { "where"?: string; "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = OrderApiFetchParamCreator.orderUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpsertWithWhere(params: { "where"?: string; "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * OrderApi - object-oriented interface
 */
export class OrderApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderCount(params: {  "where"?: string; }, options?: any) {
        return OrderApiFp.orderCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderCreate(params: {  "data"?: Order; }, options?: any) {
        return OrderApiFp.orderCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderCreateChangeStreamGetOrdersChangeStream(params: {  "options"?: string; }, options?: any) {
        return OrderApiFp.orderCreateChangeStreamGetOrdersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderCreateChangeStreamPostOrdersChangeStream(params: {  "options"?: string; }, options?: any) {
        return OrderApiFp.orderCreateChangeStreamPostOrdersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderDeleteById(params: {  "id": string; }, options?: any) {
        return OrderApiFp.orderDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsGetOrdersidExists(params: {  "id": string; }, options?: any) {
        return OrderApiFp.orderExistsGetOrdersidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsHeadOrdersid(params: {  "id": string; }, options?: any) {
        return OrderApiFp.orderExistsHeadOrdersid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFind(params: {  "filter"?: string; }, options?: any) {
        return OrderApiFp.orderFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return OrderApiFp.orderFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFindOne(params: {  "filter"?: string; }, options?: any) {
        return OrderApiFp.orderFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderPatchOrCreate(params: {  "data"?: Order; }, options?: any) {
        return OrderApiFp.orderPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Order id
     * @param refresh 
     */
    orderPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return OrderApiFp.orderPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation durationTime.
     * @param id Order id
     * @param refresh 
     */
    orderPrototypeGetDurationTime(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return OrderApiFp.orderPrototypeGetDurationTime(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation team.
     * @param id Order id
     * @param refresh 
     */
    orderPrototypeGetTeam(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return OrderApiFp.orderPrototypeGetTeam(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Order id
     * @param data An object of model property name/value pairs
     */
    orderPrototypePatchAttributes(params: {  "id": string; "data"?: Order; }, options?: any) {
        return OrderApiFp.orderPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPostOrdersidReplace(params: {  "id": string; "data"?: Order; }, options?: any) {
        return OrderApiFp.orderReplaceByIdPostOrdersidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPutOrdersid(params: {  "id": string; "data"?: Order; }, options?: any) {
        return OrderApiFp.orderReplaceByIdPutOrdersid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePostOrdersReplaceOrCreate(params: {  "data"?: Order; }, options?: any) {
        return OrderApiFp.orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePutOrders(params: {  "data"?: Order; }, options?: any) {
        return OrderApiFp.orderReplaceOrCreatePutOrders(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpdateAll(params: {  "where"?: string; "data"?: Order; }, options?: any) {
        return OrderApiFp.orderUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpsertWithWhere(params: {  "where"?: string; "data"?: Order; }, options?: any) {
        return OrderApiFp.orderUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * OrderApi - factory interface
 */
export const OrderApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        orderCount(params: {  "where"?: string; }, options?: any) {
            return OrderApiFp.orderCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        orderCreate(params: {  "data"?: Order; }, options?: any) {
            return OrderApiFp.orderCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        orderCreateChangeStreamGetOrdersChangeStream(params: {  "options"?: string; }, options?: any) {
            return OrderApiFp.orderCreateChangeStreamGetOrdersChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        orderCreateChangeStreamPostOrdersChangeStream(params: {  "options"?: string; }, options?: any) {
            return OrderApiFp.orderCreateChangeStreamPostOrdersChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        orderDeleteById(params: {  "id": string; }, options?: any) {
            return OrderApiFp.orderDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        orderExistsGetOrdersidExists(params: {  "id": string; }, options?: any) {
            return OrderApiFp.orderExistsGetOrdersidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        orderExistsHeadOrdersid(params: {  "id": string; }, options?: any) {
            return OrderApiFp.orderExistsHeadOrdersid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        orderFind(params: {  "filter"?: string; }, options?: any) {
            return OrderApiFp.orderFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        orderFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return OrderApiFp.orderFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        orderFindOne(params: {  "filter"?: string; }, options?: any) {
            return OrderApiFp.orderFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderPatchOrCreate(params: {  "data"?: Order; }, options?: any) {
            return OrderApiFp.orderPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation account.
         * @param id Order id
         * @param refresh 
         */
        orderPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return OrderApiFp.orderPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation durationTime.
         * @param id Order id
         * @param refresh 
         */
        orderPrototypeGetDurationTime(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return OrderApiFp.orderPrototypeGetDurationTime(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation team.
         * @param id Order id
         * @param refresh 
         */
        orderPrototypeGetTeam(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return OrderApiFp.orderPrototypeGetTeam(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Order id
         * @param data An object of model property name/value pairs
         */
        orderPrototypePatchAttributes(params: {  "id": string; "data"?: Order; }, options?: any) {
            return OrderApiFp.orderPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        orderReplaceByIdPostOrdersidReplace(params: {  "id": string; "data"?: Order; }, options?: any) {
            return OrderApiFp.orderReplaceByIdPostOrdersidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        orderReplaceByIdPutOrdersid(params: {  "id": string; "data"?: Order; }, options?: any) {
            return OrderApiFp.orderReplaceByIdPutOrdersid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderReplaceOrCreatePostOrdersReplaceOrCreate(params: {  "data"?: Order; }, options?: any) {
            return OrderApiFp.orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderReplaceOrCreatePutOrders(params: {  "data"?: Order; }, options?: any) {
            return OrderApiFp.orderReplaceOrCreatePutOrders(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        orderUpdateAll(params: {  "where"?: string; "data"?: Order; }, options?: any) {
            return OrderApiFp.orderUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        orderUpsertWithWhere(params: {  "where"?: string; "data"?: Order; }, options?: any) {
            return OrderApiFp.orderUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * TargetApi - fetch parameter creator
 */
export const TargetApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    targetCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Targets/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    targetCreate(params: {  "data"?: Target; }, options?: any): FetchArgs {
        const baseUrl = `/Targets`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    targetCreateChangeStreamGetTargetsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Targets/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    targetCreateChangeStreamPostTargetsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Targets/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    targetDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling targetDeleteById");
        }
        const baseUrl = `/Targets/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    targetExistsGetTargetsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling targetExistsGetTargetsidExists");
        }
        const baseUrl = `/Targets/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    targetExistsHeadTargetsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling targetExistsHeadTargetsid");
        }
        const baseUrl = `/Targets/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    targetFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Targets`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    targetFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling targetFindById");
        }
        const baseUrl = `/Targets/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    targetFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Targets/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetPatchOrCreate(params: {  "data"?: Target; }, options?: any): FetchArgs {
        const baseUrl = `/Targets`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Target id
     * @param refresh 
     */
    targetPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling targetPrototypeGetAccount");
        }
        const baseUrl = `/Targets/{id}/account`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Target id
     * @param data An object of model property name/value pairs
     */
    targetPrototypePatchAttributes(params: {  "id": string; "data"?: Target; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling targetPrototypePatchAttributes");
        }
        const baseUrl = `/Targets/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    targetReplaceByIdPostTargetsidReplace(params: {  "id": string; "data"?: Target; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling targetReplaceByIdPostTargetsidReplace");
        }
        const baseUrl = `/Targets/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    targetReplaceByIdPutTargetsid(params: {  "id": string; "data"?: Target; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling targetReplaceByIdPutTargetsid");
        }
        const baseUrl = `/Targets/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetReplaceOrCreatePostTargetsReplaceOrCreate(params: {  "data"?: Target; }, options?: any): FetchArgs {
        const baseUrl = `/Targets/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetReplaceOrCreatePutTargets(params: {  "data"?: Target; }, options?: any): FetchArgs {
        const baseUrl = `/Targets`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    targetUpdateAll(params: {  "where"?: string; "data"?: Target; }, options?: any): FetchArgs {
        const baseUrl = `/Targets/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    targetUpsertWithWhere(params: {  "where"?: string; "data"?: Target; }, options?: any): FetchArgs {
        const baseUrl = `/Targets/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TargetApi - functional programming interface
 */
export const TargetApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    targetCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = TargetApiFetchParamCreator.targetCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    targetCreate(params: { "data"?: Target;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Target> {
        const fetchArgs = TargetApiFetchParamCreator.targetCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    targetCreateChangeStreamGetTargetsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TargetApiFetchParamCreator.targetCreateChangeStreamGetTargetsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    targetCreateChangeStreamPostTargetsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TargetApiFetchParamCreator.targetCreateChangeStreamPostTargetsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    targetDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TargetApiFetchParamCreator.targetDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    targetExistsGetTargetsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = TargetApiFetchParamCreator.targetExistsGetTargetsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    targetExistsHeadTargetsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = TargetApiFetchParamCreator.targetExistsHeadTargetsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    targetFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Target>> {
        const fetchArgs = TargetApiFetchParamCreator.targetFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    targetFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Target> {
        const fetchArgs = TargetApiFetchParamCreator.targetFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    targetFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Target> {
        const fetchArgs = TargetApiFetchParamCreator.targetFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetPatchOrCreate(params: { "data"?: Target;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Target> {
        const fetchArgs = TargetApiFetchParamCreator.targetPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Target id
     * @param refresh 
     */
    targetPrototypeGetAccount(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = TargetApiFetchParamCreator.targetPrototypeGetAccount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Target id
     * @param data An object of model property name/value pairs
     */
    targetPrototypePatchAttributes(params: { "id": string; "data"?: Target;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Target> {
        const fetchArgs = TargetApiFetchParamCreator.targetPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    targetReplaceByIdPostTargetsidReplace(params: { "id": string; "data"?: Target;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Target> {
        const fetchArgs = TargetApiFetchParamCreator.targetReplaceByIdPostTargetsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    targetReplaceByIdPutTargetsid(params: { "id": string; "data"?: Target;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Target> {
        const fetchArgs = TargetApiFetchParamCreator.targetReplaceByIdPutTargetsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetReplaceOrCreatePostTargetsReplaceOrCreate(params: { "data"?: Target;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Target> {
        const fetchArgs = TargetApiFetchParamCreator.targetReplaceOrCreatePostTargetsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetReplaceOrCreatePutTargets(params: { "data"?: Target;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Target> {
        const fetchArgs = TargetApiFetchParamCreator.targetReplaceOrCreatePutTargets(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    targetUpdateAll(params: { "where"?: string; "data"?: Target;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = TargetApiFetchParamCreator.targetUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    targetUpsertWithWhere(params: { "where"?: string; "data"?: Target;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Target> {
        const fetchArgs = TargetApiFetchParamCreator.targetUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TargetApi - object-oriented interface
 */
export class TargetApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    targetCount(params: {  "where"?: string; }, options?: any) {
        return TargetApiFp.targetCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    targetCreate(params: {  "data"?: Target; }, options?: any) {
        return TargetApiFp.targetCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    targetCreateChangeStreamGetTargetsChangeStream(params: {  "options"?: string; }, options?: any) {
        return TargetApiFp.targetCreateChangeStreamGetTargetsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    targetCreateChangeStreamPostTargetsChangeStream(params: {  "options"?: string; }, options?: any) {
        return TargetApiFp.targetCreateChangeStreamPostTargetsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    targetDeleteById(params: {  "id": string; }, options?: any) {
        return TargetApiFp.targetDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    targetExistsGetTargetsidExists(params: {  "id": string; }, options?: any) {
        return TargetApiFp.targetExistsGetTargetsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    targetExistsHeadTargetsid(params: {  "id": string; }, options?: any) {
        return TargetApiFp.targetExistsHeadTargetsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    targetFind(params: {  "filter"?: string; }, options?: any) {
        return TargetApiFp.targetFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    targetFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return TargetApiFp.targetFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    targetFindOne(params: {  "filter"?: string; }, options?: any) {
        return TargetApiFp.targetFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetPatchOrCreate(params: {  "data"?: Target; }, options?: any) {
        return TargetApiFp.targetPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Target id
     * @param refresh 
     */
    targetPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return TargetApiFp.targetPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Target id
     * @param data An object of model property name/value pairs
     */
    targetPrototypePatchAttributes(params: {  "id": string; "data"?: Target; }, options?: any) {
        return TargetApiFp.targetPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    targetReplaceByIdPostTargetsidReplace(params: {  "id": string; "data"?: Target; }, options?: any) {
        return TargetApiFp.targetReplaceByIdPostTargetsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    targetReplaceByIdPutTargetsid(params: {  "id": string; "data"?: Target; }, options?: any) {
        return TargetApiFp.targetReplaceByIdPutTargetsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetReplaceOrCreatePostTargetsReplaceOrCreate(params: {  "data"?: Target; }, options?: any) {
        return TargetApiFp.targetReplaceOrCreatePostTargetsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetReplaceOrCreatePutTargets(params: {  "data"?: Target; }, options?: any) {
        return TargetApiFp.targetReplaceOrCreatePutTargets(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    targetUpdateAll(params: {  "where"?: string; "data"?: Target; }, options?: any) {
        return TargetApiFp.targetUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    targetUpsertWithWhere(params: {  "where"?: string; "data"?: Target; }, options?: any) {
        return TargetApiFp.targetUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TargetApi - factory interface
 */
export const TargetApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        targetCount(params: {  "where"?: string; }, options?: any) {
            return TargetApiFp.targetCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        targetCreate(params: {  "data"?: Target; }, options?: any) {
            return TargetApiFp.targetCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        targetCreateChangeStreamGetTargetsChangeStream(params: {  "options"?: string; }, options?: any) {
            return TargetApiFp.targetCreateChangeStreamGetTargetsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        targetCreateChangeStreamPostTargetsChangeStream(params: {  "options"?: string; }, options?: any) {
            return TargetApiFp.targetCreateChangeStreamPostTargetsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        targetDeleteById(params: {  "id": string; }, options?: any) {
            return TargetApiFp.targetDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        targetExistsGetTargetsidExists(params: {  "id": string; }, options?: any) {
            return TargetApiFp.targetExistsGetTargetsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        targetExistsHeadTargetsid(params: {  "id": string; }, options?: any) {
            return TargetApiFp.targetExistsHeadTargetsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        targetFind(params: {  "filter"?: string; }, options?: any) {
            return TargetApiFp.targetFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        targetFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return TargetApiFp.targetFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        targetFindOne(params: {  "filter"?: string; }, options?: any) {
            return TargetApiFp.targetFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        targetPatchOrCreate(params: {  "data"?: Target; }, options?: any) {
            return TargetApiFp.targetPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation account.
         * @param id Target id
         * @param refresh 
         */
        targetPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return TargetApiFp.targetPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Target id
         * @param data An object of model property name/value pairs
         */
        targetPrototypePatchAttributes(params: {  "id": string; "data"?: Target; }, options?: any) {
            return TargetApiFp.targetPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        targetReplaceByIdPostTargetsidReplace(params: {  "id": string; "data"?: Target; }, options?: any) {
            return TargetApiFp.targetReplaceByIdPostTargetsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        targetReplaceByIdPutTargetsid(params: {  "id": string; "data"?: Target; }, options?: any) {
            return TargetApiFp.targetReplaceByIdPutTargetsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        targetReplaceOrCreatePostTargetsReplaceOrCreate(params: {  "data"?: Target; }, options?: any) {
            return TargetApiFp.targetReplaceOrCreatePostTargetsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        targetReplaceOrCreatePutTargets(params: {  "data"?: Target; }, options?: any) {
            return TargetApiFp.targetReplaceOrCreatePutTargets(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        targetUpdateAll(params: {  "where"?: string; "data"?: Target; }, options?: any) {
            return TargetApiFp.targetUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        targetUpsertWithWhere(params: {  "where"?: string; "data"?: Target; }, options?: any) {
            return TargetApiFp.targetUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * TeamApi - fetch parameter creator
 */
export const TeamApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    teamCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Teams/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    teamCreate(params: {  "data"?: Team; }, options?: any): FetchArgs {
        const baseUrl = `/Teams`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    teamCreateChangeStreamGetTeamsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Teams/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    teamCreateChangeStreamPostTeamsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Teams/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    teamDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamDeleteById");
        }
        const baseUrl = `/Teams/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    teamExistsGetTeamsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamExistsGetTeamsidExists");
        }
        const baseUrl = `/Teams/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    teamExistsHeadTeamsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamExistsHeadTeamsid");
        }
        const baseUrl = `/Teams/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    teamFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Teams`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    teamFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamFindById");
        }
        const baseUrl = `/Teams/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    teamFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Teams/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamPatchOrCreate(params: {  "data"?: Team; }, options?: any): FetchArgs {
        const baseUrl = `/Teams`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts members of Team.
     * @param id Team id
     * @param where Criteria to match model instances
     */
    teamPrototypeCountMembers(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypeCountMembers");
        }
        const baseUrl = `/Teams/{id}/members/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in members of this model.
     * @param id Team id
     * @param data 
     */
    teamPrototypeCreateMembers(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypeCreateMembers");
        }
        const baseUrl = `/Teams/{id}/members`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all members of this model.
     * @param id Team id
     */
    teamPrototypeDeleteMembers(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypeDeleteMembers");
        }
        const baseUrl = `/Teams/{id}/members`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     */
    teamPrototypeDestroyByIdMembers(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypeDestroyByIdMembers");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling teamPrototypeDestroyByIdMembers");
        }
        const baseUrl = `/Teams/{id}/members/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     */
    teamPrototypeFindByIdMembers(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypeFindByIdMembers");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling teamPrototypeFindByIdMembers");
        }
        const baseUrl = `/Teams/{id}/members/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation leader.
     * @param id Team id
     * @param refresh 
     */
    teamPrototypeGetLeader(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypeGetLeader");
        }
        const baseUrl = `/Teams/{id}/leader`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries members of Team.
     * @param id Team id
     * @param filter 
     */
    teamPrototypeGetMembers(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypeGetMembers");
        }
        const baseUrl = `/Teams/{id}/members`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Team id
     * @param data An object of model property name/value pairs
     */
    teamPrototypePatchAttributes(params: {  "id": string; "data"?: Team; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypePatchAttributes");
        }
        const baseUrl = `/Teams/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     * @param data 
     */
    teamPrototypeUpdateByIdMembers(params: {  "id": string; "fk": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypeUpdateByIdMembers");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling teamPrototypeUpdateByIdMembers");
        }
        const baseUrl = `/Teams/{id}/members/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    teamReplaceByIdPostTeamsidReplace(params: {  "id": string; "data"?: Team; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamReplaceByIdPostTeamsidReplace");
        }
        const baseUrl = `/Teams/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    teamReplaceByIdPutTeamsid(params: {  "id": string; "data"?: Team; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamReplaceByIdPutTeamsid");
        }
        const baseUrl = `/Teams/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamReplaceOrCreatePostTeamsReplaceOrCreate(params: {  "data"?: Team; }, options?: any): FetchArgs {
        const baseUrl = `/Teams/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamReplaceOrCreatePutTeams(params: {  "data"?: Team; }, options?: any): FetchArgs {
        const baseUrl = `/Teams`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    teamUpdateAll(params: {  "where"?: string; "data"?: Team; }, options?: any): FetchArgs {
        const baseUrl = `/Teams/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    teamUpsertWithWhere(params: {  "where"?: string; "data"?: Team; }, options?: any): FetchArgs {
        const baseUrl = `/Teams/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TeamApi - functional programming interface
 */
export const TeamApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    teamCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = TeamApiFetchParamCreator.teamCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    teamCreate(params: { "data"?: Team;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
        const fetchArgs = TeamApiFetchParamCreator.teamCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    teamCreateChangeStreamGetTeamsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TeamApiFetchParamCreator.teamCreateChangeStreamGetTeamsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    teamCreateChangeStreamPostTeamsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TeamApiFetchParamCreator.teamCreateChangeStreamPostTeamsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    teamDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TeamApiFetchParamCreator.teamDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    teamExistsGetTeamsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = TeamApiFetchParamCreator.teamExistsGetTeamsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    teamExistsHeadTeamsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = TeamApiFetchParamCreator.teamExistsHeadTeamsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    teamFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Team>> {
        const fetchArgs = TeamApiFetchParamCreator.teamFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    teamFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
        const fetchArgs = TeamApiFetchParamCreator.teamFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    teamFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
        const fetchArgs = TeamApiFetchParamCreator.teamFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamPatchOrCreate(params: { "data"?: Team;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
        const fetchArgs = TeamApiFetchParamCreator.teamPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts members of Team.
     * @param id Team id
     * @param where Criteria to match model instances
     */
    teamPrototypeCountMembers(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = TeamApiFetchParamCreator.teamPrototypeCountMembers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in members of this model.
     * @param id Team id
     * @param data 
     */
    teamPrototypeCreateMembers(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = TeamApiFetchParamCreator.teamPrototypeCreateMembers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all members of this model.
     * @param id Team id
     */
    teamPrototypeDeleteMembers(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TeamApiFetchParamCreator.teamPrototypeDeleteMembers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     */
    teamPrototypeDestroyByIdMembers(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TeamApiFetchParamCreator.teamPrototypeDestroyByIdMembers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     */
    teamPrototypeFindByIdMembers(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = TeamApiFetchParamCreator.teamPrototypeFindByIdMembers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation leader.
     * @param id Team id
     * @param refresh 
     */
    teamPrototypeGetLeader(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = TeamApiFetchParamCreator.teamPrototypeGetLeader(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries members of Team.
     * @param id Team id
     * @param filter 
     */
    teamPrototypeGetMembers(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
        const fetchArgs = TeamApiFetchParamCreator.teamPrototypeGetMembers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Team id
     * @param data An object of model property name/value pairs
     */
    teamPrototypePatchAttributes(params: { "id": string; "data"?: Team;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
        const fetchArgs = TeamApiFetchParamCreator.teamPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     * @param data 
     */
    teamPrototypeUpdateByIdMembers(params: { "id": string; "fk": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = TeamApiFetchParamCreator.teamPrototypeUpdateByIdMembers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    teamReplaceByIdPostTeamsidReplace(params: { "id": string; "data"?: Team;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
        const fetchArgs = TeamApiFetchParamCreator.teamReplaceByIdPostTeamsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    teamReplaceByIdPutTeamsid(params: { "id": string; "data"?: Team;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
        const fetchArgs = TeamApiFetchParamCreator.teamReplaceByIdPutTeamsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamReplaceOrCreatePostTeamsReplaceOrCreate(params: { "data"?: Team;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
        const fetchArgs = TeamApiFetchParamCreator.teamReplaceOrCreatePostTeamsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamReplaceOrCreatePutTeams(params: { "data"?: Team;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
        const fetchArgs = TeamApiFetchParamCreator.teamReplaceOrCreatePutTeams(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    teamUpdateAll(params: { "where"?: string; "data"?: Team;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = TeamApiFetchParamCreator.teamUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    teamUpsertWithWhere(params: { "where"?: string; "data"?: Team;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Team> {
        const fetchArgs = TeamApiFetchParamCreator.teamUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TeamApi - object-oriented interface
 */
export class TeamApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    teamCount(params: {  "where"?: string; }, options?: any) {
        return TeamApiFp.teamCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    teamCreate(params: {  "data"?: Team; }, options?: any) {
        return TeamApiFp.teamCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    teamCreateChangeStreamGetTeamsChangeStream(params: {  "options"?: string; }, options?: any) {
        return TeamApiFp.teamCreateChangeStreamGetTeamsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    teamCreateChangeStreamPostTeamsChangeStream(params: {  "options"?: string; }, options?: any) {
        return TeamApiFp.teamCreateChangeStreamPostTeamsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    teamDeleteById(params: {  "id": string; }, options?: any) {
        return TeamApiFp.teamDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    teamExistsGetTeamsidExists(params: {  "id": string; }, options?: any) {
        return TeamApiFp.teamExistsGetTeamsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    teamExistsHeadTeamsid(params: {  "id": string; }, options?: any) {
        return TeamApiFp.teamExistsHeadTeamsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    teamFind(params: {  "filter"?: string; }, options?: any) {
        return TeamApiFp.teamFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    teamFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return TeamApiFp.teamFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    teamFindOne(params: {  "filter"?: string; }, options?: any) {
        return TeamApiFp.teamFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamPatchOrCreate(params: {  "data"?: Team; }, options?: any) {
        return TeamApiFp.teamPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts members of Team.
     * @param id Team id
     * @param where Criteria to match model instances
     */
    teamPrototypeCountMembers(params: {  "id": string; "where"?: string; }, options?: any) {
        return TeamApiFp.teamPrototypeCountMembers(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in members of this model.
     * @param id Team id
     * @param data 
     */
    teamPrototypeCreateMembers(params: {  "id": string; "data"?: Account; }, options?: any) {
        return TeamApiFp.teamPrototypeCreateMembers(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all members of this model.
     * @param id Team id
     */
    teamPrototypeDeleteMembers(params: {  "id": string; }, options?: any) {
        return TeamApiFp.teamPrototypeDeleteMembers(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     */
    teamPrototypeDestroyByIdMembers(params: {  "id": string; "fk": string; }, options?: any) {
        return TeamApiFp.teamPrototypeDestroyByIdMembers(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     */
    teamPrototypeFindByIdMembers(params: {  "id": string; "fk": string; }, options?: any) {
        return TeamApiFp.teamPrototypeFindByIdMembers(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation leader.
     * @param id Team id
     * @param refresh 
     */
    teamPrototypeGetLeader(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return TeamApiFp.teamPrototypeGetLeader(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries members of Team.
     * @param id Team id
     * @param filter 
     */
    teamPrototypeGetMembers(params: {  "id": string; "filter"?: string; }, options?: any) {
        return TeamApiFp.teamPrototypeGetMembers(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Team id
     * @param data An object of model property name/value pairs
     */
    teamPrototypePatchAttributes(params: {  "id": string; "data"?: Team; }, options?: any) {
        return TeamApiFp.teamPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     * @param data 
     */
    teamPrototypeUpdateByIdMembers(params: {  "id": string; "fk": string; "data"?: Account; }, options?: any) {
        return TeamApiFp.teamPrototypeUpdateByIdMembers(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    teamReplaceByIdPostTeamsidReplace(params: {  "id": string; "data"?: Team; }, options?: any) {
        return TeamApiFp.teamReplaceByIdPostTeamsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    teamReplaceByIdPutTeamsid(params: {  "id": string; "data"?: Team; }, options?: any) {
        return TeamApiFp.teamReplaceByIdPutTeamsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamReplaceOrCreatePostTeamsReplaceOrCreate(params: {  "data"?: Team; }, options?: any) {
        return TeamApiFp.teamReplaceOrCreatePostTeamsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamReplaceOrCreatePutTeams(params: {  "data"?: Team; }, options?: any) {
        return TeamApiFp.teamReplaceOrCreatePutTeams(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    teamUpdateAll(params: {  "where"?: string; "data"?: Team; }, options?: any) {
        return TeamApiFp.teamUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    teamUpsertWithWhere(params: {  "where"?: string; "data"?: Team; }, options?: any) {
        return TeamApiFp.teamUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TeamApi - factory interface
 */
export const TeamApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        teamCount(params: {  "where"?: string; }, options?: any) {
            return TeamApiFp.teamCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        teamCreate(params: {  "data"?: Team; }, options?: any) {
            return TeamApiFp.teamCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        teamCreateChangeStreamGetTeamsChangeStream(params: {  "options"?: string; }, options?: any) {
            return TeamApiFp.teamCreateChangeStreamGetTeamsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        teamCreateChangeStreamPostTeamsChangeStream(params: {  "options"?: string; }, options?: any) {
            return TeamApiFp.teamCreateChangeStreamPostTeamsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        teamDeleteById(params: {  "id": string; }, options?: any) {
            return TeamApiFp.teamDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        teamExistsGetTeamsidExists(params: {  "id": string; }, options?: any) {
            return TeamApiFp.teamExistsGetTeamsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        teamExistsHeadTeamsid(params: {  "id": string; }, options?: any) {
            return TeamApiFp.teamExistsHeadTeamsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        teamFind(params: {  "filter"?: string; }, options?: any) {
            return TeamApiFp.teamFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        teamFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return TeamApiFp.teamFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        teamFindOne(params: {  "filter"?: string; }, options?: any) {
            return TeamApiFp.teamFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        teamPatchOrCreate(params: {  "data"?: Team; }, options?: any) {
            return TeamApiFp.teamPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts members of Team.
         * @param id Team id
         * @param where Criteria to match model instances
         */
        teamPrototypeCountMembers(params: {  "id": string; "where"?: string; }, options?: any) {
            return TeamApiFp.teamPrototypeCountMembers(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in members of this model.
         * @param id Team id
         * @param data 
         */
        teamPrototypeCreateMembers(params: {  "id": string; "data"?: Account; }, options?: any) {
            return TeamApiFp.teamPrototypeCreateMembers(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all members of this model.
         * @param id Team id
         */
        teamPrototypeDeleteMembers(params: {  "id": string; }, options?: any) {
            return TeamApiFp.teamPrototypeDeleteMembers(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for members.
         * @param id Team id
         * @param fk Foreign key for members
         */
        teamPrototypeDestroyByIdMembers(params: {  "id": string; "fk": string; }, options?: any) {
            return TeamApiFp.teamPrototypeDestroyByIdMembers(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for members.
         * @param id Team id
         * @param fk Foreign key for members
         */
        teamPrototypeFindByIdMembers(params: {  "id": string; "fk": string; }, options?: any) {
            return TeamApiFp.teamPrototypeFindByIdMembers(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation leader.
         * @param id Team id
         * @param refresh 
         */
        teamPrototypeGetLeader(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return TeamApiFp.teamPrototypeGetLeader(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries members of Team.
         * @param id Team id
         * @param filter 
         */
        teamPrototypeGetMembers(params: {  "id": string; "filter"?: string; }, options?: any) {
            return TeamApiFp.teamPrototypeGetMembers(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Team id
         * @param data An object of model property name/value pairs
         */
        teamPrototypePatchAttributes(params: {  "id": string; "data"?: Team; }, options?: any) {
            return TeamApiFp.teamPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for members.
         * @param id Team id
         * @param fk Foreign key for members
         * @param data 
         */
        teamPrototypeUpdateByIdMembers(params: {  "id": string; "fk": string; "data"?: Account; }, options?: any) {
            return TeamApiFp.teamPrototypeUpdateByIdMembers(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        teamReplaceByIdPostTeamsidReplace(params: {  "id": string; "data"?: Team; }, options?: any) {
            return TeamApiFp.teamReplaceByIdPostTeamsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        teamReplaceByIdPutTeamsid(params: {  "id": string; "data"?: Team; }, options?: any) {
            return TeamApiFp.teamReplaceByIdPutTeamsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        teamReplaceOrCreatePostTeamsReplaceOrCreate(params: {  "data"?: Team; }, options?: any) {
            return TeamApiFp.teamReplaceOrCreatePostTeamsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        teamReplaceOrCreatePutTeams(params: {  "data"?: Team; }, options?: any) {
            return TeamApiFp.teamReplaceOrCreatePutTeams(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        teamUpdateAll(params: {  "where"?: string; "data"?: Team; }, options?: any) {
            return TeamApiFp.teamUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        teamUpsertWithWhere(params: {  "where"?: string; "data"?: Team; }, options?: any) {
            return TeamApiFp.teamUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};

