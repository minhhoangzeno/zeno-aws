/**
 * plan-de-transport-api
 * plan-de-transport-api
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://localhost/api".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface Account {
    "firstName"?: string;
    "lastName"?: string;
    "avatar"?: string;
    "city"?: number;
    "district"?: number;
    "phoneNumber"?: number;
    "realm"?: string;
    "username"?: string;
    "email": string;
    "emailVerified"?: boolean;
    "id"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface AccountToken {
    "id": string;
    /**
     * time to live in seconds (2 weeks by default)
     */
    "ttl"?: number;
    /**
     * Array of scopes granted to this access token.
     */
    "scopes"?: Array<string>;
    "created"?: Date;
    "userId"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface Banner {
    "photoURL"?: string;
    "id"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface Blog {
    "title"?: string;
    "metaDescription"?: string;
    "content"?: string;
    "photoURL"?: string;
    "id"?: number;
    "accountId"?: number;
    "tagId"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface CategoryProduct {
    "title"?: string;
    "photoURL"?: string;
    "id"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface Contact {
    "name"?: string;
    "email"?: string;
    "subject"?: string;
    "message"?: string;
    "id"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface Feedback {
    "content"?: string;
    "id"?: number;
    "accountId"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface InlineResponse200 {
    "undefined"?: any;
}

export interface InlineResponse2001 {
    "result"?: any;
}

export interface InlineResponse2002 {
    "count"?: number;
}

export interface InlineResponse2003 {
    "exists"?: boolean;
}

/**
 * Information related to the outcome of the operation
 */
export interface InlineResponse2004 {
    /**
     * The number of instances updated
     */
    "count"?: number;
}

export interface Order {
    "code"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "phoneNumber"?: number;
    "email"?: string;
    "address"?: string;
    "city"?: number;
    "district"?: number;
    "note"?: string;
    "status"?: string;
    "price"?: number;
    "id"?: number;
    "accountId"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface OrderProduct {
    "amount"?: number;
    "price"?: number;
    "id"?: number;
    "productId"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
    "orderId"?: number;
}

export interface Product {
    "title"?: string;
    "price"?: number;
    "color"?: string;
    "origin"?: string;
    "photoURL"?: string;
    "content"?: string;
    "metaDescription"?: string;
    "record"?: number;
    "id"?: number;
    "categoryProductId"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}

export interface Role {
    "id"?: number;
    "name": string;
    "description"?: string;
    "created"?: Date;
    "modified"?: Date;
}

/**
 * Map principals to roles
 */
export interface RoleMapping {
    "id"?: number;
    /**
     * The principal type, such as USER, APPLICATION, ROLE, or user model name in case of multiple user models
     */
    "principalType"?: string;
    "principalId"?: string;
    "roleId"?: number;
}

export interface Tag {
    "title"?: string;
    "id"?: number;
    "createdAt"?: Date;
    "updatedAt"?: Date;
}



/**
 * AccountApi - fetch parameter creator
 */
export const AccountApiFetchParamCreator = {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    accountChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any): FetchArgs {
        // verify required parameter "oldPassword" is set
        if (params["oldPassword"] == null) {
            throw new Error("Missing required parameter oldPassword when calling accountChangePassword");
        }
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountChangePassword");
        }
        const baseUrl = `/Accounts/change-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "oldPassword": params["oldPassword"],
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Change role of user
     * @param data context of request
     */
    accountChangeRole(params: {  "data": string; }, options?: any): FetchArgs {
        // verify required parameter "data" is set
        if (params["data"] == null) {
            throw new Error("Missing required parameter data when calling accountChangeRole");
        }
        const baseUrl = `/Accounts/change-role`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "data": params["data"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    accountConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any): FetchArgs {
        // verify required parameter "uid" is set
        if (params["uid"] == null) {
            throw new Error("Missing required parameter uid when calling accountConfirm");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            throw new Error("Missing required parameter token when calling accountConfirm");
        }
        const baseUrl = `/Accounts/confirm`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "uid": params["uid"],
            "token": params["token"],
            "redirect": params["redirect"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamGetAccountsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamPostAccountsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountDeleteById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsGetAccountsidExists");
        }
        const baseUrl = `/Accounts/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsHeadAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountFindById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get account by token
     */
    accountGetMe(options?: any): FetchArgs {
        const baseUrl = `/Accounts/get-me`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params: {  "credentials": any; "include"?: string; }, options?: any): FetchArgs {
        // verify required parameter "credentials" is set
        if (params["credentials"] == null) {
            throw new Error("Missing required parameter credentials when calling accountLogin");
        }
        const baseUrl = `/Accounts/login`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "include": params["include"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["credentials"]) {
            fetchOptions.body = JSON.stringify(params["credentials"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Logout a user with access token.
     */
    accountLogout(options?: any): FetchArgs {
        const baseUrl = `/Accounts/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccountToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateRoles(params: {  "id": string; "data"?: Role; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeExistsRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeExistsRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetRoles(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeLinkRoles(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeLinkRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeLinkRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypePatchAttributes");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUnlinkRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUnlinkRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    accountPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccountToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeUpdateByIdRoles(params: {  "id": string; "fk": string; "data"?: Role; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeVerify");
        }
        const baseUrl = `/Accounts/{id}/verify`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPostAccountsidReplace");
        }
        const baseUrl = `/Accounts/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params: {  "id": string; "data"?: Account; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPutAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params: {  "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    accountResetPassword(params: {  "options": any; }, options?: any): FetchArgs {
        // verify required parameter "options" is set
        if (params["options"] == null) {
            throw new Error("Missing required parameter options when calling accountResetPassword");
        }
        const baseUrl = `/Accounts/reset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    accountSetPassword(params: {  "newPassword": string; }, options?: any): FetchArgs {
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountSetPassword");
        }
        const baseUrl = `/Accounts/reset-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params: {  "where"?: string; "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params: {  "where"?: string; "data"?: Account; }, options?: any): FetchArgs {
        const baseUrl = `/Accounts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AccountApi - functional programming interface
 */
export const AccountApiFp = {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    accountChangePassword(params: { "oldPassword": string; "newPassword": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountChangePassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Change role of user
     * @param data context of request
     */
    accountChangeRole(params: { "data": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountChangeRole(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    accountConfirm(params: { "uid": string; "token": string; "redirect"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountConfirm(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AccountApiFetchParamCreator.accountCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamGetAccountsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountCreateChangeStreamGetAccountsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamPostAccountsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountCreateChangeStreamPostAccountsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = AccountApiFetchParamCreator.accountExistsGetAccountsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = AccountApiFetchParamCreator.accountExistsHeadAccountsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Account>> {
        const fetchArgs = AccountApiFetchParamCreator.accountFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get account by token
     */
    accountGetMe(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountGetMe(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params: { "credentials": any; "include"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountLogin(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Logout a user with access token.
     */
    accountLogout(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountLogout(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCountRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateAccessTokens(params: { "id": string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateRoles(params: { "id": string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeCreateRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDeleteRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeDestroyByIdRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeExistsRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeFindByIdRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetAccessTokens(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccountToken>> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetRoles(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Role>> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeGetRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeLinkRoles(params: { "id": string; "fk": string; "data"?: RoleMapping;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RoleMapping> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeLinkRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUnlinkRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    accountPrototypeUpdateByIdAccessTokens(params: { "id": string; "fk": string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdAccessTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeUpdateByIdRoles(params: { "id": string; "fk": string; "data"?: Role;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Role> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeUpdateByIdRoles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountPrototypeVerify(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceByIdPostAccountsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params: { "id": string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceByIdPutAccountsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params: { "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountReplaceOrCreatePutAccounts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    accountResetPassword(params: { "options": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountResetPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    accountSetPassword(params: { "newPassword": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountApiFetchParamCreator.accountSetPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params: { "where"?: string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = AccountApiFetchParamCreator.accountUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params: { "where"?: string; "data"?: Account;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountApiFetchParamCreator.accountUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AccountApi - object-oriented interface
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Change a user's password.
     * @param oldPassword 
     * @param newPassword 
     */
    accountChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any) {
        return AccountApiFp.accountChangePassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Change role of user
     * @param data context of request
     */
    accountChangeRole(params: {  "data": string; }, options?: any) {
        return AccountApiFp.accountChangeRole(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Confirm a user registration with identity verification token.
     * @param uid 
     * @param token 
     * @param redirect 
     */
    accountConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any) {
        return AccountApiFp.accountConfirm(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params: {  "where"?: string; }, options?: any) {
        return AccountApiFp.accountCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamGetAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountCreateChangeStreamPostAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountExistsGetAccountsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountExistsHeadAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params: {  "filter"?: string; }, options?: any) {
        return AccountApiFp.accountFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params: {  "filter"?: string; }, options?: any) {
        return AccountApiFp.accountFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get account by token
     */
    accountGetMe(options?: any) {
        return AccountApiFp.accountGetMe(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Login a user with username/email and password.
     * @param credentials 
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params: {  "credentials": any; "include"?: string; }, options?: any) {
        return AccountApiFp.accountLogin(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Logout a user with access token.
     */
    accountLogout(options?: any) {
        return AccountApiFp.accountLogout(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeCountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params: {  "id": string; "where"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeCountRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
        return AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data 
     */
    accountPrototypeCreateRoles(params: {  "id": string; "data"?: Role; }, options?: any) {
        return AccountApiFp.accountPrototypeCreateRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDeleteRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeExistsRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeFindByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeGetAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter 
     */
    accountPrototypeGetRoles(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountApiFp.accountPrototypeGetRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeLinkRoles(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any) {
        return AccountApiFp.accountPrototypeLinkRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params: {  "id": string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params: {  "id": string; "fk": string; }, options?: any) {
        return AccountApiFp.accountPrototypeUnlinkRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data 
     */
    accountPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccountToken; }, options?: any) {
        return AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data 
     */
    accountPrototypeUpdateByIdRoles(params: {  "id": string; "fk": string; "data"?: Role; }, options?: any) {
        return AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params: {  "id": string; }, options?: any) {
        return AccountApiFp.accountPrototypeVerify(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params: {  "id": string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params: {  "id": string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params: {  "data"?: Account; }, options?: any) {
        return AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Reset password for a user with email.
     * @param options 
     */
    accountResetPassword(params: {  "options": any; }, options?: any) {
        return AccountApiFp.accountResetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Reset user's password via a password-reset token.
     * @param newPassword 
     */
    accountSetPassword(params: {  "newPassword": string; }, options?: any) {
        return AccountApiFp.accountSetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params: {  "where"?: string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params: {  "where"?: string; "data"?: Account; }, options?: any) {
        return AccountApiFp.accountUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AccountApi - factory interface
 */
export const AccountApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Change a user's password.
         * @param oldPassword 
         * @param newPassword 
         */
        accountChangePassword(params: {  "oldPassword": string; "newPassword": string; }, options?: any) {
            return AccountApiFp.accountChangePassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Change role of user
         * @param data context of request
         */
        accountChangeRole(params: {  "data": string; }, options?: any) {
            return AccountApiFp.accountChangeRole(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Confirm a user registration with identity verification token.
         * @param uid 
         * @param token 
         * @param redirect 
         */
        accountConfirm(params: {  "uid": string; "token": string; "redirect"?: string; }, options?: any) {
            return AccountApiFp.accountConfirm(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountCount(params: {  "where"?: string; }, options?: any) {
            return AccountApiFp.accountCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountCreate(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountCreateChangeStreamGetAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountCreateChangeStreamPostAccountsChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountDeleteById(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsGetAccountsidExists(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountExistsGetAccountsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsHeadAccountsid(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountExistsHeadAccountsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFind(params: {  "filter"?: string; }, options?: any) {
            return AccountApiFp.accountFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFindOne(params: {  "filter"?: string; }, options?: any) {
            return AccountApiFp.accountFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get account by token
         */
        accountGetMe(options?: any) {
            return AccountApiFp.accountGetMe(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Login a user with username/email and password.
         * @param credentials 
         * @param include Related objects to include in the response. See the description of return value for more details.
         */
        accountLogin(params: {  "credentials": any; "include"?: string; }, options?: any) {
            return AccountApiFp.accountLogin(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logout a user with access token.
         */
        accountLogout(options?: any) {
            return AccountApiFp.accountLogout(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountPatchOrCreate(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts accessTokens of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountAccessTokens(params: {  "id": string; "where"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeCountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts roles of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountRoles(params: {  "id": string; "where"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeCountRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in accessTokens of this model.
         * @param id Account id
         * @param data 
         */
        accountPrototypeCreateAccessTokens(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
            return AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in roles of this model.
         * @param id Account id
         * @param data 
         */
        accountPrototypeCreateRoles(params: {  "id": string; "data"?: Role; }, options?: any) {
            return AccountApiFp.accountPrototypeCreateRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all accessTokens of this model.
         * @param id Account id
         */
        accountPrototypeDeleteAccessTokens(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all roles of this model.
         * @param id Account id
         */
        accountPrototypeDeleteRoles(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDeleteRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeDestroyByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeDestroyByIdRoles(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check the existence of roles relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeExistsRoles(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeExistsRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeFindByIdAccessTokens(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeFindByIdRoles(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeFindByIdRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries accessTokens of Account.
         * @param id Account id
         * @param filter 
         */
        accountPrototypeGetAccessTokens(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeGetAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries roles of Account.
         * @param id Account id
         * @param filter 
         */
        accountPrototypeGetRoles(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountApiFp.accountPrototypeGetRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         * @param data 
         */
        accountPrototypeLinkRoles(params: {  "id": string; "fk": string; "data"?: RoleMapping; }, options?: any) {
            return AccountApiFp.accountPrototypeLinkRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Account id
         * @param data An object of model property name/value pairs
         */
        accountPrototypePatchAttributes(params: {  "id": string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the roles relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeUnlinkRoles(params: {  "id": string; "fk": string; }, options?: any) {
            return AccountApiFp.accountPrototypeUnlinkRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         * @param data 
         */
        accountPrototypeUpdateByIdAccessTokens(params: {  "id": string; "fk": string; "data"?: AccountToken; }, options?: any) {
            return AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         * @param data 
         */
        accountPrototypeUpdateByIdRoles(params: {  "id": string; "fk": string; "data"?: Role; }, options?: any) {
            return AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Trigger user's identity verification with configured verifyOptions
         * @param id Account id
         */
        accountPrototypeVerify(params: {  "id": string; }, options?: any) {
            return AccountApiFp.accountPrototypeVerify(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPostAccountsidReplace(params: {  "id": string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPutAccountsid(params: {  "id": string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePostAccountsReplaceOrCreate(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePutAccounts(params: {  "data"?: Account; }, options?: any) {
            return AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset password for a user with email.
         * @param options 
         */
        accountResetPassword(params: {  "options": any; }, options?: any) {
            return AccountApiFp.accountResetPassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Reset user's password via a password-reset token.
         * @param newPassword 
         */
        accountSetPassword(params: {  "newPassword": string; }, options?: any) {
            return AccountApiFp.accountSetPassword(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpdateAll(params: {  "where"?: string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpsertWithWhere(params: {  "where"?: string; "data"?: Account; }, options?: any) {
            return AccountApiFp.accountUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * AccountTokenApi - fetch parameter creator
 */
export const AccountTokenApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params: {  "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenDeleteById");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenExistsGetAccountTokensidExists");
        }
        const baseUrl = `/AccountTokens/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenExistsHeadAccountTokensid");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenFindById");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params: {  "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh 
     */
    accountTokenPrototypeGetUser(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenPrototypeGetUser");
        }
        const baseUrl = `/AccountTokens/{id}/user`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params: {  "id": string; "data"?: AccountToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenPrototypePatchAttributes");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params: {  "id": string; "data"?: AccountToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenReplaceByIdPostAccountTokensidReplace");
        }
        const baseUrl = `/AccountTokens/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params: {  "id": string; "data"?: AccountToken; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenReplaceByIdPutAccountTokensid");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params: {  "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params: {  "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params: {  "where"?: string; "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params: {  "where"?: string; "data"?: AccountToken; }, options?: any): FetchArgs {
        const baseUrl = `/AccountTokens/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AccountTokenApi - functional programming interface
 */
export const AccountTokenApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params: { "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenExistsGetAccountTokensidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenExistsHeadAccountTokensid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AccountToken>> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params: { "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh 
     */
    accountTokenPrototypeGetUser(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenPrototypeGetUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params: { "id": string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params: { "id": string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenReplaceByIdPostAccountTokensidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params: { "id": string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenReplaceByIdPutAccountTokensid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params: { "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params: { "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenReplaceOrCreatePutAccountTokens(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params: { "where"?: string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params: { "where"?: string; "data"?: AccountToken;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AccountToken> {
        const fetchArgs = AccountTokenApiFetchParamCreator.accountTokenUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AccountTokenApi - object-oriented interface
 */
export class AccountTokenApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params: {  "where"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params: {  "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params: {  "options"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params: {  "id": string; }, options?: any) {
        return AccountTokenApiFp.accountTokenDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params: {  "id": string; }, options?: any) {
        return AccountTokenApiFp.accountTokenExistsGetAccountTokensidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params: {  "id": string; }, options?: any) {
        return AccountTokenApiFp.accountTokenExistsHeadAccountTokensid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params: {  "filter"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params: {  "filter"?: string; }, options?: any) {
        return AccountTokenApiFp.accountTokenFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params: {  "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh 
     */
    accountTokenPrototypeGetUser(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return AccountTokenApiFp.accountTokenPrototypeGetUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenReplaceByIdPostAccountTokensidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenReplaceByIdPutAccountTokensid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params: {  "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params: {  "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenReplaceOrCreatePutAccountTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params: {  "where"?: string; "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params: {  "where"?: string; "data"?: AccountToken; }, options?: any) {
        return AccountTokenApiFp.accountTokenUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AccountTokenApi - factory interface
 */
export const AccountTokenApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountTokenCount(params: {  "where"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountTokenCreate(params: {  "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountTokenCreateChangeStreamGetAccountTokensChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        accountTokenCreateChangeStreamPostAccountTokensChangeStream(params: {  "options"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountTokenDeleteById(params: {  "id": string; }, options?: any) {
            return AccountTokenApiFp.accountTokenDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountTokenExistsGetAccountTokensidExists(params: {  "id": string; }, options?: any) {
            return AccountTokenApiFp.accountTokenExistsGetAccountTokensidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountTokenExistsHeadAccountTokensid(params: {  "id": string; }, options?: any) {
            return AccountTokenApiFp.accountTokenExistsHeadAccountTokensid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountTokenFind(params: {  "filter"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountTokenFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountTokenFindOne(params: {  "filter"?: string; }, options?: any) {
            return AccountTokenApiFp.accountTokenFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenPatchOrCreate(params: {  "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation user.
         * @param id AccountToken id
         * @param refresh 
         */
        accountTokenPrototypeGetUser(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return AccountTokenApiFp.accountTokenPrototypeGetUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id AccountToken id
         * @param data An object of model property name/value pairs
         */
        accountTokenPrototypePatchAttributes(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountTokenReplaceByIdPostAccountTokensidReplace(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenReplaceByIdPostAccountTokensidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountTokenReplaceByIdPutAccountTokensid(params: {  "id": string; "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenReplaceByIdPutAccountTokensid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params: {  "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenReplaceOrCreatePutAccountTokens(params: {  "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenReplaceOrCreatePutAccountTokens(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountTokenUpdateAll(params: {  "where"?: string; "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountTokenUpsertWithWhere(params: {  "where"?: string; "data"?: AccountToken; }, options?: any) {
            return AccountTokenApiFp.accountTokenUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * BannerApi - fetch parameter creator
 */
export const BannerApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    bannerCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Banners/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    bannerCreate(params: {  "data"?: Banner; }, options?: any): FetchArgs {
        const baseUrl = `/Banners`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    bannerCreateChangeStreamGetBannersChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Banners/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    bannerCreateChangeStreamPostBannersChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Banners/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    bannerDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling bannerDeleteById");
        }
        const baseUrl = `/Banners/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    bannerExistsGetBannersidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling bannerExistsGetBannersidExists");
        }
        const baseUrl = `/Banners/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    bannerExistsHeadBannersid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling bannerExistsHeadBannersid");
        }
        const baseUrl = `/Banners/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    bannerFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Banners`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    bannerFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling bannerFindById");
        }
        const baseUrl = `/Banners/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    bannerFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Banners/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerPatchOrCreate(params: {  "data"?: Banner; }, options?: any): FetchArgs {
        const baseUrl = `/Banners`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Banner id
     * @param data An object of model property name/value pairs
     */
    bannerPrototypePatchAttributes(params: {  "id": string; "data"?: Banner; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling bannerPrototypePatchAttributes");
        }
        const baseUrl = `/Banners/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    bannerReplaceByIdPostBannersidReplace(params: {  "id": string; "data"?: Banner; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling bannerReplaceByIdPostBannersidReplace");
        }
        const baseUrl = `/Banners/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    bannerReplaceByIdPutBannersid(params: {  "id": string; "data"?: Banner; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling bannerReplaceByIdPutBannersid");
        }
        const baseUrl = `/Banners/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerReplaceOrCreatePostBannersReplaceOrCreate(params: {  "data"?: Banner; }, options?: any): FetchArgs {
        const baseUrl = `/Banners/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerReplaceOrCreatePutBanners(params: {  "data"?: Banner; }, options?: any): FetchArgs {
        const baseUrl = `/Banners`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    bannerUpdateAll(params: {  "where"?: string; "data"?: Banner; }, options?: any): FetchArgs {
        const baseUrl = `/Banners/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    bannerUpsertWithWhere(params: {  "where"?: string; "data"?: Banner; }, options?: any): FetchArgs {
        const baseUrl = `/Banners/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BannerApi - functional programming interface
 */
export const BannerApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    bannerCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = BannerApiFetchParamCreator.bannerCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    bannerCreate(params: { "data"?: Banner;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Banner> {
        const fetchArgs = BannerApiFetchParamCreator.bannerCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    bannerCreateChangeStreamGetBannersChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BannerApiFetchParamCreator.bannerCreateChangeStreamGetBannersChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    bannerCreateChangeStreamPostBannersChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BannerApiFetchParamCreator.bannerCreateChangeStreamPostBannersChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    bannerDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BannerApiFetchParamCreator.bannerDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    bannerExistsGetBannersidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = BannerApiFetchParamCreator.bannerExistsGetBannersidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    bannerExistsHeadBannersid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = BannerApiFetchParamCreator.bannerExistsHeadBannersid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    bannerFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Banner>> {
        const fetchArgs = BannerApiFetchParamCreator.bannerFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    bannerFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Banner> {
        const fetchArgs = BannerApiFetchParamCreator.bannerFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    bannerFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Banner> {
        const fetchArgs = BannerApiFetchParamCreator.bannerFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerPatchOrCreate(params: { "data"?: Banner;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Banner> {
        const fetchArgs = BannerApiFetchParamCreator.bannerPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Banner id
     * @param data An object of model property name/value pairs
     */
    bannerPrototypePatchAttributes(params: { "id": string; "data"?: Banner;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Banner> {
        const fetchArgs = BannerApiFetchParamCreator.bannerPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    bannerReplaceByIdPostBannersidReplace(params: { "id": string; "data"?: Banner;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Banner> {
        const fetchArgs = BannerApiFetchParamCreator.bannerReplaceByIdPostBannersidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    bannerReplaceByIdPutBannersid(params: { "id": string; "data"?: Banner;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Banner> {
        const fetchArgs = BannerApiFetchParamCreator.bannerReplaceByIdPutBannersid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerReplaceOrCreatePostBannersReplaceOrCreate(params: { "data"?: Banner;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Banner> {
        const fetchArgs = BannerApiFetchParamCreator.bannerReplaceOrCreatePostBannersReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerReplaceOrCreatePutBanners(params: { "data"?: Banner;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Banner> {
        const fetchArgs = BannerApiFetchParamCreator.bannerReplaceOrCreatePutBanners(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    bannerUpdateAll(params: { "where"?: string; "data"?: Banner;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = BannerApiFetchParamCreator.bannerUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    bannerUpsertWithWhere(params: { "where"?: string; "data"?: Banner;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Banner> {
        const fetchArgs = BannerApiFetchParamCreator.bannerUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BannerApi - object-oriented interface
 */
export class BannerApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    bannerCount(params: {  "where"?: string; }, options?: any) {
        return BannerApiFp.bannerCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    bannerCreate(params: {  "data"?: Banner; }, options?: any) {
        return BannerApiFp.bannerCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    bannerCreateChangeStreamGetBannersChangeStream(params: {  "options"?: string; }, options?: any) {
        return BannerApiFp.bannerCreateChangeStreamGetBannersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    bannerCreateChangeStreamPostBannersChangeStream(params: {  "options"?: string; }, options?: any) {
        return BannerApiFp.bannerCreateChangeStreamPostBannersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    bannerDeleteById(params: {  "id": string; }, options?: any) {
        return BannerApiFp.bannerDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    bannerExistsGetBannersidExists(params: {  "id": string; }, options?: any) {
        return BannerApiFp.bannerExistsGetBannersidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    bannerExistsHeadBannersid(params: {  "id": string; }, options?: any) {
        return BannerApiFp.bannerExistsHeadBannersid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    bannerFind(params: {  "filter"?: string; }, options?: any) {
        return BannerApiFp.bannerFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    bannerFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return BannerApiFp.bannerFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    bannerFindOne(params: {  "filter"?: string; }, options?: any) {
        return BannerApiFp.bannerFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerPatchOrCreate(params: {  "data"?: Banner; }, options?: any) {
        return BannerApiFp.bannerPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Banner id
     * @param data An object of model property name/value pairs
     */
    bannerPrototypePatchAttributes(params: {  "id": string; "data"?: Banner; }, options?: any) {
        return BannerApiFp.bannerPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    bannerReplaceByIdPostBannersidReplace(params: {  "id": string; "data"?: Banner; }, options?: any) {
        return BannerApiFp.bannerReplaceByIdPostBannersidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    bannerReplaceByIdPutBannersid(params: {  "id": string; "data"?: Banner; }, options?: any) {
        return BannerApiFp.bannerReplaceByIdPutBannersid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerReplaceOrCreatePostBannersReplaceOrCreate(params: {  "data"?: Banner; }, options?: any) {
        return BannerApiFp.bannerReplaceOrCreatePostBannersReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerReplaceOrCreatePutBanners(params: {  "data"?: Banner; }, options?: any) {
        return BannerApiFp.bannerReplaceOrCreatePutBanners(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    bannerUpdateAll(params: {  "where"?: string; "data"?: Banner; }, options?: any) {
        return BannerApiFp.bannerUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    bannerUpsertWithWhere(params: {  "where"?: string; "data"?: Banner; }, options?: any) {
        return BannerApiFp.bannerUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * BannerApi - factory interface
 */
export const BannerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        bannerCount(params: {  "where"?: string; }, options?: any) {
            return BannerApiFp.bannerCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        bannerCreate(params: {  "data"?: Banner; }, options?: any) {
            return BannerApiFp.bannerCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        bannerCreateChangeStreamGetBannersChangeStream(params: {  "options"?: string; }, options?: any) {
            return BannerApiFp.bannerCreateChangeStreamGetBannersChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        bannerCreateChangeStreamPostBannersChangeStream(params: {  "options"?: string; }, options?: any) {
            return BannerApiFp.bannerCreateChangeStreamPostBannersChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        bannerDeleteById(params: {  "id": string; }, options?: any) {
            return BannerApiFp.bannerDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        bannerExistsGetBannersidExists(params: {  "id": string; }, options?: any) {
            return BannerApiFp.bannerExistsGetBannersidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        bannerExistsHeadBannersid(params: {  "id": string; }, options?: any) {
            return BannerApiFp.bannerExistsHeadBannersid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        bannerFind(params: {  "filter"?: string; }, options?: any) {
            return BannerApiFp.bannerFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        bannerFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return BannerApiFp.bannerFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        bannerFindOne(params: {  "filter"?: string; }, options?: any) {
            return BannerApiFp.bannerFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        bannerPatchOrCreate(params: {  "data"?: Banner; }, options?: any) {
            return BannerApiFp.bannerPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Banner id
         * @param data An object of model property name/value pairs
         */
        bannerPrototypePatchAttributes(params: {  "id": string; "data"?: Banner; }, options?: any) {
            return BannerApiFp.bannerPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        bannerReplaceByIdPostBannersidReplace(params: {  "id": string; "data"?: Banner; }, options?: any) {
            return BannerApiFp.bannerReplaceByIdPostBannersidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        bannerReplaceByIdPutBannersid(params: {  "id": string; "data"?: Banner; }, options?: any) {
            return BannerApiFp.bannerReplaceByIdPutBannersid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        bannerReplaceOrCreatePostBannersReplaceOrCreate(params: {  "data"?: Banner; }, options?: any) {
            return BannerApiFp.bannerReplaceOrCreatePostBannersReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        bannerReplaceOrCreatePutBanners(params: {  "data"?: Banner; }, options?: any) {
            return BannerApiFp.bannerReplaceOrCreatePutBanners(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        bannerUpdateAll(params: {  "where"?: string; "data"?: Banner; }, options?: any) {
            return BannerApiFp.bannerUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        bannerUpsertWithWhere(params: {  "where"?: string; "data"?: Banner; }, options?: any) {
            return BannerApiFp.bannerUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * BlogApi - fetch parameter creator
 */
export const BlogApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    blogCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Blogs/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    blogCreate(params: {  "data"?: Blog; }, options?: any): FetchArgs {
        const baseUrl = `/Blogs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    blogCreateChangeStreamGetBlogsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Blogs/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    blogCreateChangeStreamPostBlogsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Blogs/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    blogDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogDeleteById");
        }
        const baseUrl = `/Blogs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsGetBlogsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogExistsGetBlogsidExists");
        }
        const baseUrl = `/Blogs/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsHeadBlogsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogExistsHeadBlogsid");
        }
        const baseUrl = `/Blogs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Blogs`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    blogFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogFindById");
        }
        const baseUrl = `/Blogs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Blogs/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogPatchOrCreate(params: {  "data"?: Blog; }, options?: any): FetchArgs {
        const baseUrl = `/Blogs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Blog id
     * @param refresh 
     */
    blogPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogPrototypeGetAccount");
        }
        const baseUrl = `/Blogs/{id}/account`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation tag.
     * @param id Blog id
     * @param refresh 
     */
    blogPrototypeGetTag(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogPrototypeGetTag");
        }
        const baseUrl = `/Blogs/{id}/tag`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Blog id
     * @param data An object of model property name/value pairs
     */
    blogPrototypePatchAttributes(params: {  "id": string; "data"?: Blog; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogPrototypePatchAttributes");
        }
        const baseUrl = `/Blogs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPostBlogsidReplace(params: {  "id": string; "data"?: Blog; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogReplaceByIdPostBlogsidReplace");
        }
        const baseUrl = `/Blogs/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPutBlogsid(params: {  "id": string; "data"?: Blog; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogReplaceByIdPutBlogsid");
        }
        const baseUrl = `/Blogs/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePostBlogsReplaceOrCreate(params: {  "data"?: Blog; }, options?: any): FetchArgs {
        const baseUrl = `/Blogs/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePutBlogs(params: {  "data"?: Blog; }, options?: any): FetchArgs {
        const baseUrl = `/Blogs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpdateAll(params: {  "where"?: string; "data"?: Blog; }, options?: any): FetchArgs {
        const baseUrl = `/Blogs/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpsertWithWhere(params: {  "where"?: string; "data"?: Blog; }, options?: any): FetchArgs {
        const baseUrl = `/Blogs/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * BlogApi - functional programming interface
 */
export const BlogApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    blogCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = BlogApiFetchParamCreator.blogCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    blogCreate(params: { "data"?: Blog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blog> {
        const fetchArgs = BlogApiFetchParamCreator.blogCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    blogCreateChangeStreamGetBlogsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BlogApiFetchParamCreator.blogCreateChangeStreamGetBlogsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    blogCreateChangeStreamPostBlogsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BlogApiFetchParamCreator.blogCreateChangeStreamPostBlogsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    blogDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = BlogApiFetchParamCreator.blogDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsGetBlogsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = BlogApiFetchParamCreator.blogExistsGetBlogsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsHeadBlogsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = BlogApiFetchParamCreator.blogExistsHeadBlogsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Blog>> {
        const fetchArgs = BlogApiFetchParamCreator.blogFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    blogFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blog> {
        const fetchArgs = BlogApiFetchParamCreator.blogFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blog> {
        const fetchArgs = BlogApiFetchParamCreator.blogFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogPatchOrCreate(params: { "data"?: Blog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blog> {
        const fetchArgs = BlogApiFetchParamCreator.blogPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Blog id
     * @param refresh 
     */
    blogPrototypeGetAccount(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = BlogApiFetchParamCreator.blogPrototypeGetAccount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation tag.
     * @param id Blog id
     * @param refresh 
     */
    blogPrototypeGetTag(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
        const fetchArgs = BlogApiFetchParamCreator.blogPrototypeGetTag(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Blog id
     * @param data An object of model property name/value pairs
     */
    blogPrototypePatchAttributes(params: { "id": string; "data"?: Blog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blog> {
        const fetchArgs = BlogApiFetchParamCreator.blogPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPostBlogsidReplace(params: { "id": string; "data"?: Blog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blog> {
        const fetchArgs = BlogApiFetchParamCreator.blogReplaceByIdPostBlogsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPutBlogsid(params: { "id": string; "data"?: Blog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blog> {
        const fetchArgs = BlogApiFetchParamCreator.blogReplaceByIdPutBlogsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePostBlogsReplaceOrCreate(params: { "data"?: Blog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blog> {
        const fetchArgs = BlogApiFetchParamCreator.blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePutBlogs(params: { "data"?: Blog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blog> {
        const fetchArgs = BlogApiFetchParamCreator.blogReplaceOrCreatePutBlogs(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpdateAll(params: { "where"?: string; "data"?: Blog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = BlogApiFetchParamCreator.blogUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpsertWithWhere(params: { "where"?: string; "data"?: Blog;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blog> {
        const fetchArgs = BlogApiFetchParamCreator.blogUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * BlogApi - object-oriented interface
 */
export class BlogApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    blogCount(params: {  "where"?: string; }, options?: any) {
        return BlogApiFp.blogCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    blogCreate(params: {  "data"?: Blog; }, options?: any) {
        return BlogApiFp.blogCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    blogCreateChangeStreamGetBlogsChangeStream(params: {  "options"?: string; }, options?: any) {
        return BlogApiFp.blogCreateChangeStreamGetBlogsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    blogCreateChangeStreamPostBlogsChangeStream(params: {  "options"?: string; }, options?: any) {
        return BlogApiFp.blogCreateChangeStreamPostBlogsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    blogDeleteById(params: {  "id": string; }, options?: any) {
        return BlogApiFp.blogDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsGetBlogsidExists(params: {  "id": string; }, options?: any) {
        return BlogApiFp.blogExistsGetBlogsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsHeadBlogsid(params: {  "id": string; }, options?: any) {
        return BlogApiFp.blogExistsHeadBlogsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFind(params: {  "filter"?: string; }, options?: any) {
        return BlogApiFp.blogFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    blogFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return BlogApiFp.blogFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFindOne(params: {  "filter"?: string; }, options?: any) {
        return BlogApiFp.blogFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogPatchOrCreate(params: {  "data"?: Blog; }, options?: any) {
        return BlogApiFp.blogPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Blog id
     * @param refresh 
     */
    blogPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return BlogApiFp.blogPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation tag.
     * @param id Blog id
     * @param refresh 
     */
    blogPrototypeGetTag(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return BlogApiFp.blogPrototypeGetTag(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Blog id
     * @param data An object of model property name/value pairs
     */
    blogPrototypePatchAttributes(params: {  "id": string; "data"?: Blog; }, options?: any) {
        return BlogApiFp.blogPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPostBlogsidReplace(params: {  "id": string; "data"?: Blog; }, options?: any) {
        return BlogApiFp.blogReplaceByIdPostBlogsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPutBlogsid(params: {  "id": string; "data"?: Blog; }, options?: any) {
        return BlogApiFp.blogReplaceByIdPutBlogsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePostBlogsReplaceOrCreate(params: {  "data"?: Blog; }, options?: any) {
        return BlogApiFp.blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePutBlogs(params: {  "data"?: Blog; }, options?: any) {
        return BlogApiFp.blogReplaceOrCreatePutBlogs(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpdateAll(params: {  "where"?: string; "data"?: Blog; }, options?: any) {
        return BlogApiFp.blogUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpsertWithWhere(params: {  "where"?: string; "data"?: Blog; }, options?: any) {
        return BlogApiFp.blogUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * BlogApi - factory interface
 */
export const BlogApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        blogCount(params: {  "where"?: string; }, options?: any) {
            return BlogApiFp.blogCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        blogCreate(params: {  "data"?: Blog; }, options?: any) {
            return BlogApiFp.blogCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        blogCreateChangeStreamGetBlogsChangeStream(params: {  "options"?: string; }, options?: any) {
            return BlogApiFp.blogCreateChangeStreamGetBlogsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        blogCreateChangeStreamPostBlogsChangeStream(params: {  "options"?: string; }, options?: any) {
            return BlogApiFp.blogCreateChangeStreamPostBlogsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        blogDeleteById(params: {  "id": string; }, options?: any) {
            return BlogApiFp.blogDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        blogExistsGetBlogsidExists(params: {  "id": string; }, options?: any) {
            return BlogApiFp.blogExistsGetBlogsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        blogExistsHeadBlogsid(params: {  "id": string; }, options?: any) {
            return BlogApiFp.blogExistsHeadBlogsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        blogFind(params: {  "filter"?: string; }, options?: any) {
            return BlogApiFp.blogFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        blogFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return BlogApiFp.blogFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        blogFindOne(params: {  "filter"?: string; }, options?: any) {
            return BlogApiFp.blogFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        blogPatchOrCreate(params: {  "data"?: Blog; }, options?: any) {
            return BlogApiFp.blogPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation account.
         * @param id Blog id
         * @param refresh 
         */
        blogPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return BlogApiFp.blogPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation tag.
         * @param id Blog id
         * @param refresh 
         */
        blogPrototypeGetTag(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return BlogApiFp.blogPrototypeGetTag(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Blog id
         * @param data An object of model property name/value pairs
         */
        blogPrototypePatchAttributes(params: {  "id": string; "data"?: Blog; }, options?: any) {
            return BlogApiFp.blogPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        blogReplaceByIdPostBlogsidReplace(params: {  "id": string; "data"?: Blog; }, options?: any) {
            return BlogApiFp.blogReplaceByIdPostBlogsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        blogReplaceByIdPutBlogsid(params: {  "id": string; "data"?: Blog; }, options?: any) {
            return BlogApiFp.blogReplaceByIdPutBlogsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        blogReplaceOrCreatePostBlogsReplaceOrCreate(params: {  "data"?: Blog; }, options?: any) {
            return BlogApiFp.blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        blogReplaceOrCreatePutBlogs(params: {  "data"?: Blog; }, options?: any) {
            return BlogApiFp.blogReplaceOrCreatePutBlogs(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        blogUpdateAll(params: {  "where"?: string; "data"?: Blog; }, options?: any) {
            return BlogApiFp.blogUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        blogUpsertWithWhere(params: {  "where"?: string; "data"?: Blog; }, options?: any) {
            return BlogApiFp.blogUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * CategoryProductApi - fetch parameter creator
 */
export const CategoryProductApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    categoryProductCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/CategoryProducts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    categoryProductCreate(params: {  "data"?: CategoryProduct; }, options?: any): FetchArgs {
        const baseUrl = `/CategoryProducts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/CategoryProducts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/CategoryProducts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    categoryProductDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductDeleteById");
        }
        const baseUrl = `/CategoryProducts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsGetCategoryProductsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductExistsGetCategoryProductsidExists");
        }
        const baseUrl = `/CategoryProducts/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsHeadCategoryProductsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductExistsHeadCategoryProductsid");
        }
        const baseUrl = `/CategoryProducts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/CategoryProducts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    categoryProductFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductFindById");
        }
        const baseUrl = `/CategoryProducts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/CategoryProducts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductPatchOrCreate(params: {  "data"?: CategoryProduct; }, options?: any): FetchArgs {
        const baseUrl = `/CategoryProducts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id CategoryProduct id
     * @param data An object of model property name/value pairs
     */
    categoryProductPrototypePatchAttributes(params: {  "id": string; "data"?: CategoryProduct; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductPrototypePatchAttributes");
        }
        const baseUrl = `/CategoryProducts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPostCategoryProductsidReplace(params: {  "id": string; "data"?: CategoryProduct; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductReplaceByIdPostCategoryProductsidReplace");
        }
        const baseUrl = `/CategoryProducts/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPutCategoryProductsid(params: {  "id": string; "data"?: CategoryProduct; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductReplaceByIdPutCategoryProductsid");
        }
        const baseUrl = `/CategoryProducts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params: {  "data"?: CategoryProduct; }, options?: any): FetchArgs {
        const baseUrl = `/CategoryProducts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePutCategoryProducts(params: {  "data"?: CategoryProduct; }, options?: any): FetchArgs {
        const baseUrl = `/CategoryProducts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpdateAll(params: {  "where"?: string; "data"?: CategoryProduct; }, options?: any): FetchArgs {
        const baseUrl = `/CategoryProducts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpsertWithWhere(params: {  "where"?: string; "data"?: CategoryProduct; }, options?: any): FetchArgs {
        const baseUrl = `/CategoryProducts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CategoryProductApi - functional programming interface
 */
export const CategoryProductApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    categoryProductCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    categoryProductCreate(params: { "data"?: CategoryProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryProduct> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    categoryProductDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsGetCategoryProductsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductExistsGetCategoryProductsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsHeadCategoryProductsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductExistsHeadCategoryProductsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CategoryProduct>> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    categoryProductFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryProduct> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryProduct> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductPatchOrCreate(params: { "data"?: CategoryProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryProduct> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id CategoryProduct id
     * @param data An object of model property name/value pairs
     */
    categoryProductPrototypePatchAttributes(params: { "id": string; "data"?: CategoryProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryProduct> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPostCategoryProductsidReplace(params: { "id": string; "data"?: CategoryProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryProduct> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductReplaceByIdPostCategoryProductsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPutCategoryProductsid(params: { "id": string; "data"?: CategoryProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryProduct> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductReplaceByIdPutCategoryProductsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params: { "data"?: CategoryProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryProduct> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePutCategoryProducts(params: { "data"?: CategoryProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryProduct> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductReplaceOrCreatePutCategoryProducts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpdateAll(params: { "where"?: string; "data"?: CategoryProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpsertWithWhere(params: { "where"?: string; "data"?: CategoryProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryProduct> {
        const fetchArgs = CategoryProductApiFetchParamCreator.categoryProductUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CategoryProductApi - object-oriented interface
 */
export class CategoryProductApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    categoryProductCount(params: {  "where"?: string; }, options?: any) {
        return CategoryProductApiFp.categoryProductCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    categoryProductCreate(params: {  "data"?: CategoryProduct; }, options?: any) {
        return CategoryProductApiFp.categoryProductCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params: {  "options"?: string; }, options?: any) {
        return CategoryProductApiFp.categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params: {  "options"?: string; }, options?: any) {
        return CategoryProductApiFp.categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    categoryProductDeleteById(params: {  "id": string; }, options?: any) {
        return CategoryProductApiFp.categoryProductDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsGetCategoryProductsidExists(params: {  "id": string; }, options?: any) {
        return CategoryProductApiFp.categoryProductExistsGetCategoryProductsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsHeadCategoryProductsid(params: {  "id": string; }, options?: any) {
        return CategoryProductApiFp.categoryProductExistsHeadCategoryProductsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFind(params: {  "filter"?: string; }, options?: any) {
        return CategoryProductApiFp.categoryProductFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    categoryProductFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return CategoryProductApiFp.categoryProductFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFindOne(params: {  "filter"?: string; }, options?: any) {
        return CategoryProductApiFp.categoryProductFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductPatchOrCreate(params: {  "data"?: CategoryProduct; }, options?: any) {
        return CategoryProductApiFp.categoryProductPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id CategoryProduct id
     * @param data An object of model property name/value pairs
     */
    categoryProductPrototypePatchAttributes(params: {  "id": string; "data"?: CategoryProduct; }, options?: any) {
        return CategoryProductApiFp.categoryProductPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPostCategoryProductsidReplace(params: {  "id": string; "data"?: CategoryProduct; }, options?: any) {
        return CategoryProductApiFp.categoryProductReplaceByIdPostCategoryProductsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPutCategoryProductsid(params: {  "id": string; "data"?: CategoryProduct; }, options?: any) {
        return CategoryProductApiFp.categoryProductReplaceByIdPutCategoryProductsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params: {  "data"?: CategoryProduct; }, options?: any) {
        return CategoryProductApiFp.categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePutCategoryProducts(params: {  "data"?: CategoryProduct; }, options?: any) {
        return CategoryProductApiFp.categoryProductReplaceOrCreatePutCategoryProducts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpdateAll(params: {  "where"?: string; "data"?: CategoryProduct; }, options?: any) {
        return CategoryProductApiFp.categoryProductUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpsertWithWhere(params: {  "where"?: string; "data"?: CategoryProduct; }, options?: any) {
        return CategoryProductApiFp.categoryProductUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CategoryProductApi - factory interface
 */
export const CategoryProductApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        categoryProductCount(params: {  "where"?: string; }, options?: any) {
            return CategoryProductApiFp.categoryProductCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        categoryProductCreate(params: {  "data"?: CategoryProduct; }, options?: any) {
            return CategoryProductApiFp.categoryProductCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params: {  "options"?: string; }, options?: any) {
            return CategoryProductApiFp.categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params: {  "options"?: string; }, options?: any) {
            return CategoryProductApiFp.categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        categoryProductDeleteById(params: {  "id": string; }, options?: any) {
            return CategoryProductApiFp.categoryProductDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        categoryProductExistsGetCategoryProductsidExists(params: {  "id": string; }, options?: any) {
            return CategoryProductApiFp.categoryProductExistsGetCategoryProductsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        categoryProductExistsHeadCategoryProductsid(params: {  "id": string; }, options?: any) {
            return CategoryProductApiFp.categoryProductExistsHeadCategoryProductsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        categoryProductFind(params: {  "filter"?: string; }, options?: any) {
            return CategoryProductApiFp.categoryProductFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        categoryProductFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return CategoryProductApiFp.categoryProductFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        categoryProductFindOne(params: {  "filter"?: string; }, options?: any) {
            return CategoryProductApiFp.categoryProductFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        categoryProductPatchOrCreate(params: {  "data"?: CategoryProduct; }, options?: any) {
            return CategoryProductApiFp.categoryProductPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id CategoryProduct id
         * @param data An object of model property name/value pairs
         */
        categoryProductPrototypePatchAttributes(params: {  "id": string; "data"?: CategoryProduct; }, options?: any) {
            return CategoryProductApiFp.categoryProductPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        categoryProductReplaceByIdPostCategoryProductsidReplace(params: {  "id": string; "data"?: CategoryProduct; }, options?: any) {
            return CategoryProductApiFp.categoryProductReplaceByIdPostCategoryProductsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        categoryProductReplaceByIdPutCategoryProductsid(params: {  "id": string; "data"?: CategoryProduct; }, options?: any) {
            return CategoryProductApiFp.categoryProductReplaceByIdPutCategoryProductsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params: {  "data"?: CategoryProduct; }, options?: any) {
            return CategoryProductApiFp.categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        categoryProductReplaceOrCreatePutCategoryProducts(params: {  "data"?: CategoryProduct; }, options?: any) {
            return CategoryProductApiFp.categoryProductReplaceOrCreatePutCategoryProducts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        categoryProductUpdateAll(params: {  "where"?: string; "data"?: CategoryProduct; }, options?: any) {
            return CategoryProductApiFp.categoryProductUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        categoryProductUpsertWithWhere(params: {  "where"?: string; "data"?: CategoryProduct; }, options?: any) {
            return CategoryProductApiFp.categoryProductUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * ContactApi - fetch parameter creator
 */
export const ContactApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    contactCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Contacts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    contactCreate(params: {  "data"?: Contact; }, options?: any): FetchArgs {
        const baseUrl = `/Contacts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    contactCreateChangeStreamGetContactsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Contacts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    contactCreateChangeStreamPostContactsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Contacts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    contactDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactDeleteById");
        }
        const baseUrl = `/Contacts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsGetContactsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactExistsGetContactsidExists");
        }
        const baseUrl = `/Contacts/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsHeadContactsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactExistsHeadContactsid");
        }
        const baseUrl = `/Contacts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Contacts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    contactFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactFindById");
        }
        const baseUrl = `/Contacts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Contacts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactPatchOrCreate(params: {  "data"?: Contact; }, options?: any): FetchArgs {
        const baseUrl = `/Contacts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Contact id
     * @param data An object of model property name/value pairs
     */
    contactPrototypePatchAttributes(params: {  "id": string; "data"?: Contact; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactPrototypePatchAttributes");
        }
        const baseUrl = `/Contacts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPostContactsidReplace(params: {  "id": string; "data"?: Contact; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactReplaceByIdPostContactsidReplace");
        }
        const baseUrl = `/Contacts/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPutContactsid(params: {  "id": string; "data"?: Contact; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactReplaceByIdPutContactsid");
        }
        const baseUrl = `/Contacts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePostContactsReplaceOrCreate(params: {  "data"?: Contact; }, options?: any): FetchArgs {
        const baseUrl = `/Contacts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePutContacts(params: {  "data"?: Contact; }, options?: any): FetchArgs {
        const baseUrl = `/Contacts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpdateAll(params: {  "where"?: string; "data"?: Contact; }, options?: any): FetchArgs {
        const baseUrl = `/Contacts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpsertWithWhere(params: {  "where"?: string; "data"?: Contact; }, options?: any): FetchArgs {
        const baseUrl = `/Contacts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ContactApi - functional programming interface
 */
export const ContactApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    contactCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = ContactApiFetchParamCreator.contactCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    contactCreate(params: { "data"?: Contact;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Contact> {
        const fetchArgs = ContactApiFetchParamCreator.contactCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    contactCreateChangeStreamGetContactsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContactApiFetchParamCreator.contactCreateChangeStreamGetContactsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    contactCreateChangeStreamPostContactsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContactApiFetchParamCreator.contactCreateChangeStreamPostContactsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    contactDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContactApiFetchParamCreator.contactDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsGetContactsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = ContactApiFetchParamCreator.contactExistsGetContactsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsHeadContactsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = ContactApiFetchParamCreator.contactExistsHeadContactsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Contact>> {
        const fetchArgs = ContactApiFetchParamCreator.contactFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    contactFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Contact> {
        const fetchArgs = ContactApiFetchParamCreator.contactFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Contact> {
        const fetchArgs = ContactApiFetchParamCreator.contactFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactPatchOrCreate(params: { "data"?: Contact;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Contact> {
        const fetchArgs = ContactApiFetchParamCreator.contactPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Contact id
     * @param data An object of model property name/value pairs
     */
    contactPrototypePatchAttributes(params: { "id": string; "data"?: Contact;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Contact> {
        const fetchArgs = ContactApiFetchParamCreator.contactPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPostContactsidReplace(params: { "id": string; "data"?: Contact;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Contact> {
        const fetchArgs = ContactApiFetchParamCreator.contactReplaceByIdPostContactsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPutContactsid(params: { "id": string; "data"?: Contact;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Contact> {
        const fetchArgs = ContactApiFetchParamCreator.contactReplaceByIdPutContactsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePostContactsReplaceOrCreate(params: { "data"?: Contact;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Contact> {
        const fetchArgs = ContactApiFetchParamCreator.contactReplaceOrCreatePostContactsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePutContacts(params: { "data"?: Contact;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Contact> {
        const fetchArgs = ContactApiFetchParamCreator.contactReplaceOrCreatePutContacts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpdateAll(params: { "where"?: string; "data"?: Contact;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = ContactApiFetchParamCreator.contactUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpsertWithWhere(params: { "where"?: string; "data"?: Contact;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Contact> {
        const fetchArgs = ContactApiFetchParamCreator.contactUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ContactApi - object-oriented interface
 */
export class ContactApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    contactCount(params: {  "where"?: string; }, options?: any) {
        return ContactApiFp.contactCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    contactCreate(params: {  "data"?: Contact; }, options?: any) {
        return ContactApiFp.contactCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    contactCreateChangeStreamGetContactsChangeStream(params: {  "options"?: string; }, options?: any) {
        return ContactApiFp.contactCreateChangeStreamGetContactsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    contactCreateChangeStreamPostContactsChangeStream(params: {  "options"?: string; }, options?: any) {
        return ContactApiFp.contactCreateChangeStreamPostContactsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    contactDeleteById(params: {  "id": string; }, options?: any) {
        return ContactApiFp.contactDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsGetContactsidExists(params: {  "id": string; }, options?: any) {
        return ContactApiFp.contactExistsGetContactsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsHeadContactsid(params: {  "id": string; }, options?: any) {
        return ContactApiFp.contactExistsHeadContactsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFind(params: {  "filter"?: string; }, options?: any) {
        return ContactApiFp.contactFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    contactFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return ContactApiFp.contactFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFindOne(params: {  "filter"?: string; }, options?: any) {
        return ContactApiFp.contactFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactPatchOrCreate(params: {  "data"?: Contact; }, options?: any) {
        return ContactApiFp.contactPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Contact id
     * @param data An object of model property name/value pairs
     */
    contactPrototypePatchAttributes(params: {  "id": string; "data"?: Contact; }, options?: any) {
        return ContactApiFp.contactPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPostContactsidReplace(params: {  "id": string; "data"?: Contact; }, options?: any) {
        return ContactApiFp.contactReplaceByIdPostContactsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPutContactsid(params: {  "id": string; "data"?: Contact; }, options?: any) {
        return ContactApiFp.contactReplaceByIdPutContactsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePostContactsReplaceOrCreate(params: {  "data"?: Contact; }, options?: any) {
        return ContactApiFp.contactReplaceOrCreatePostContactsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePutContacts(params: {  "data"?: Contact; }, options?: any) {
        return ContactApiFp.contactReplaceOrCreatePutContacts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpdateAll(params: {  "where"?: string; "data"?: Contact; }, options?: any) {
        return ContactApiFp.contactUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpsertWithWhere(params: {  "where"?: string; "data"?: Contact; }, options?: any) {
        return ContactApiFp.contactUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ContactApi - factory interface
 */
export const ContactApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        contactCount(params: {  "where"?: string; }, options?: any) {
            return ContactApiFp.contactCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        contactCreate(params: {  "data"?: Contact; }, options?: any) {
            return ContactApiFp.contactCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        contactCreateChangeStreamGetContactsChangeStream(params: {  "options"?: string; }, options?: any) {
            return ContactApiFp.contactCreateChangeStreamGetContactsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        contactCreateChangeStreamPostContactsChangeStream(params: {  "options"?: string; }, options?: any) {
            return ContactApiFp.contactCreateChangeStreamPostContactsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        contactDeleteById(params: {  "id": string; }, options?: any) {
            return ContactApiFp.contactDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        contactExistsGetContactsidExists(params: {  "id": string; }, options?: any) {
            return ContactApiFp.contactExistsGetContactsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        contactExistsHeadContactsid(params: {  "id": string; }, options?: any) {
            return ContactApiFp.contactExistsHeadContactsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        contactFind(params: {  "filter"?: string; }, options?: any) {
            return ContactApiFp.contactFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        contactFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return ContactApiFp.contactFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        contactFindOne(params: {  "filter"?: string; }, options?: any) {
            return ContactApiFp.contactFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        contactPatchOrCreate(params: {  "data"?: Contact; }, options?: any) {
            return ContactApiFp.contactPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Contact id
         * @param data An object of model property name/value pairs
         */
        contactPrototypePatchAttributes(params: {  "id": string; "data"?: Contact; }, options?: any) {
            return ContactApiFp.contactPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        contactReplaceByIdPostContactsidReplace(params: {  "id": string; "data"?: Contact; }, options?: any) {
            return ContactApiFp.contactReplaceByIdPostContactsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        contactReplaceByIdPutContactsid(params: {  "id": string; "data"?: Contact; }, options?: any) {
            return ContactApiFp.contactReplaceByIdPutContactsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        contactReplaceOrCreatePostContactsReplaceOrCreate(params: {  "data"?: Contact; }, options?: any) {
            return ContactApiFp.contactReplaceOrCreatePostContactsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        contactReplaceOrCreatePutContacts(params: {  "data"?: Contact; }, options?: any) {
            return ContactApiFp.contactReplaceOrCreatePutContacts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        contactUpdateAll(params: {  "where"?: string; "data"?: Contact; }, options?: any) {
            return ContactApiFp.contactUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        contactUpsertWithWhere(params: {  "where"?: string; "data"?: Contact; }, options?: any) {
            return ContactApiFp.contactUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * ContainerApi - fetch parameter creator
 */
export const ContainerApiFetchParamCreator = {
    /**
     * 
     * @param options 
     */
    containerCreateContainer(params: {  "options"?: any; }, options?: any): FetchArgs {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerDestroyContainer(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerDestroyContainer");
        }
        const baseUrl = `/Containers/{container}`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerDownload(params: {  "container": string; "file": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerDownload");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerDownload");
        }
        const baseUrl = `/Containers/{container}/download/{file}`
            .replace(`{${"container"}}`, `${ params["container"] }`)
            .replace(`{${"file"}}`, `${ params["file"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetContainer(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetContainer");
        }
        const baseUrl = `/Containers/{container}`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     */
    containerGetContainers(options?: any): FetchArgs {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerGetFile(params: {  "container": string; "file": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetFile");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerGetFile");
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${"container"}}`, `${ params["container"] }`)
            .replace(`{${"file"}}`, `${ params["file"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetFiles(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetFiles");
        }
        const baseUrl = `/Containers/{container}/files`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerRemoveFile(params: {  "container": string; "file": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerRemoveFile");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerRemoveFile");
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${"container"}}`, `${ params["container"] }`)
            .replace(`{${"file"}}`, `${ params["file"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @param container 
     */
    containerUpload(params: {  "container": string; }, options?: any): FetchArgs {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerUpload");
        }
        const baseUrl = `/Containers/{container}/upload`
            .replace(`{${"container"}}`, `${ params["container"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ContainerApi - functional programming interface
 */
export const ContainerApiFp = {
    /**
     * 
     * @param options 
     */
    containerCreateContainer(params: { "options"?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerCreateContainer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerDestroyContainer(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = ContainerApiFetchParamCreator.containerDestroyContainer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerDownload(params: { "container": string; "file": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerDownload(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetContainer(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetContainer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     */
    containerGetContainers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetContainers(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerGetFile(params: { "container": string; "file": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetFile(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerGetFiles(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<any>> {
        const fetchArgs = ContainerApiFetchParamCreator.containerGetFiles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     * @param file 
     */
    containerRemoveFile(params: { "container": string; "file": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = ContainerApiFetchParamCreator.containerRemoveFile(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @param container 
     */
    containerUpload(params: { "container": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
        const fetchArgs = ContainerApiFetchParamCreator.containerUpload(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ContainerApi - object-oriented interface
 */
export class ContainerApi extends BaseAPI {
    /**
     * 
     * @param options 
     */
    containerCreateContainer(params: {  "options"?: any; }, options?: any) {
        return ContainerApiFp.containerCreateContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerDestroyContainer(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerDestroyContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     * @param file 
     */
    containerDownload(params: {  "container": string; "file": string; }, options?: any) {
        return ContainerApiFp.containerDownload(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerGetContainer(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerGetContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     */
    containerGetContainers(options?: any) {
        return ContainerApiFp.containerGetContainers(options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     * @param file 
     */
    containerGetFile(params: {  "container": string; "file": string; }, options?: any) {
        return ContainerApiFp.containerGetFile(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerGetFiles(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerGetFiles(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     * @param file 
     */
    containerRemoveFile(params: {  "container": string; "file": string; }, options?: any) {
        return ContainerApiFp.containerRemoveFile(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @param container 
     */
    containerUpload(params: {  "container": string; }, options?: any) {
        return ContainerApiFp.containerUpload(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ContainerApi - factory interface
 */
export const ContainerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param options 
         */
        containerCreateContainer(params: {  "options"?: any; }, options?: any) {
            return ContainerApiFp.containerCreateContainer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerDestroyContainer(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerDestroyContainer(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         * @param file 
         */
        containerDownload(params: {  "container": string; "file": string; }, options?: any) {
            return ContainerApiFp.containerDownload(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerGetContainer(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerGetContainer(params, options)(fetch, basePath);
        },
        /**
         * 
         */
        containerGetContainers(options?: any) {
            return ContainerApiFp.containerGetContainers(options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         * @param file 
         */
        containerGetFile(params: {  "container": string; "file": string; }, options?: any) {
            return ContainerApiFp.containerGetFile(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerGetFiles(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerGetFiles(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         * @param file 
         */
        containerRemoveFile(params: {  "container": string; "file": string; }, options?: any) {
            return ContainerApiFp.containerRemoveFile(params, options)(fetch, basePath);
        },
        /**
         * 
         * @param container 
         */
        containerUpload(params: {  "container": string; }, options?: any) {
            return ContainerApiFp.containerUpload(params, options)(fetch, basePath);
        },
    };
};


/**
 * FeedbackApi - fetch parameter creator
 */
export const FeedbackApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    feedbackCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Feedbacks/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    feedbackCreate(params: {  "data"?: Feedback; }, options?: any): FetchArgs {
        const baseUrl = `/Feedbacks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    feedbackCreateChangeStreamGetFeedbacksChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Feedbacks/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    feedbackCreateChangeStreamPostFeedbacksChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Feedbacks/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    feedbackDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackDeleteById");
        }
        const baseUrl = `/Feedbacks/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsGetFeedbacksidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackExistsGetFeedbacksidExists");
        }
        const baseUrl = `/Feedbacks/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsHeadFeedbacksid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackExistsHeadFeedbacksid");
        }
        const baseUrl = `/Feedbacks/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Feedbacks`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    feedbackFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackFindById");
        }
        const baseUrl = `/Feedbacks/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Feedbacks/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackPatchOrCreate(params: {  "data"?: Feedback; }, options?: any): FetchArgs {
        const baseUrl = `/Feedbacks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Feedback id
     * @param refresh 
     */
    feedbackPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackPrototypeGetAccount");
        }
        const baseUrl = `/Feedbacks/{id}/account`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Feedback id
     * @param data An object of model property name/value pairs
     */
    feedbackPrototypePatchAttributes(params: {  "id": string; "data"?: Feedback; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackPrototypePatchAttributes");
        }
        const baseUrl = `/Feedbacks/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPostFeedbacksidReplace(params: {  "id": string; "data"?: Feedback; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackReplaceByIdPostFeedbacksidReplace");
        }
        const baseUrl = `/Feedbacks/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPutFeedbacksid(params: {  "id": string; "data"?: Feedback; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackReplaceByIdPutFeedbacksid");
        }
        const baseUrl = `/Feedbacks/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params: {  "data"?: Feedback; }, options?: any): FetchArgs {
        const baseUrl = `/Feedbacks/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePutFeedbacks(params: {  "data"?: Feedback; }, options?: any): FetchArgs {
        const baseUrl = `/Feedbacks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpdateAll(params: {  "where"?: string; "data"?: Feedback; }, options?: any): FetchArgs {
        const baseUrl = `/Feedbacks/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpsertWithWhere(params: {  "where"?: string; "data"?: Feedback; }, options?: any): FetchArgs {
        const baseUrl = `/Feedbacks/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * FeedbackApi - functional programming interface
 */
export const FeedbackApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    feedbackCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    feedbackCreate(params: { "data"?: Feedback;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Feedback> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    feedbackCreateChangeStreamGetFeedbacksChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    feedbackCreateChangeStreamPostFeedbacksChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    feedbackDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsGetFeedbacksidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackExistsGetFeedbacksidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsHeadFeedbacksid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackExistsHeadFeedbacksid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Feedback>> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    feedbackFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Feedback> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Feedback> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackPatchOrCreate(params: { "data"?: Feedback;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Feedback> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Feedback id
     * @param refresh 
     */
    feedbackPrototypeGetAccount(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackPrototypeGetAccount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Feedback id
     * @param data An object of model property name/value pairs
     */
    feedbackPrototypePatchAttributes(params: { "id": string; "data"?: Feedback;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Feedback> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPostFeedbacksidReplace(params: { "id": string; "data"?: Feedback;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Feedback> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackReplaceByIdPostFeedbacksidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPutFeedbacksid(params: { "id": string; "data"?: Feedback;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Feedback> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackReplaceByIdPutFeedbacksid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params: { "data"?: Feedback;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Feedback> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePutFeedbacks(params: { "data"?: Feedback;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Feedback> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackReplaceOrCreatePutFeedbacks(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpdateAll(params: { "where"?: string; "data"?: Feedback;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpsertWithWhere(params: { "where"?: string; "data"?: Feedback;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Feedback> {
        const fetchArgs = FeedbackApiFetchParamCreator.feedbackUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * FeedbackApi - object-oriented interface
 */
export class FeedbackApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    feedbackCount(params: {  "where"?: string; }, options?: any) {
        return FeedbackApiFp.feedbackCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    feedbackCreate(params: {  "data"?: Feedback; }, options?: any) {
        return FeedbackApiFp.feedbackCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    feedbackCreateChangeStreamGetFeedbacksChangeStream(params: {  "options"?: string; }, options?: any) {
        return FeedbackApiFp.feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    feedbackCreateChangeStreamPostFeedbacksChangeStream(params: {  "options"?: string; }, options?: any) {
        return FeedbackApiFp.feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    feedbackDeleteById(params: {  "id": string; }, options?: any) {
        return FeedbackApiFp.feedbackDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsGetFeedbacksidExists(params: {  "id": string; }, options?: any) {
        return FeedbackApiFp.feedbackExistsGetFeedbacksidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsHeadFeedbacksid(params: {  "id": string; }, options?: any) {
        return FeedbackApiFp.feedbackExistsHeadFeedbacksid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFind(params: {  "filter"?: string; }, options?: any) {
        return FeedbackApiFp.feedbackFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    feedbackFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return FeedbackApiFp.feedbackFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFindOne(params: {  "filter"?: string; }, options?: any) {
        return FeedbackApiFp.feedbackFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackPatchOrCreate(params: {  "data"?: Feedback; }, options?: any) {
        return FeedbackApiFp.feedbackPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Feedback id
     * @param refresh 
     */
    feedbackPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return FeedbackApiFp.feedbackPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Feedback id
     * @param data An object of model property name/value pairs
     */
    feedbackPrototypePatchAttributes(params: {  "id": string; "data"?: Feedback; }, options?: any) {
        return FeedbackApiFp.feedbackPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPostFeedbacksidReplace(params: {  "id": string; "data"?: Feedback; }, options?: any) {
        return FeedbackApiFp.feedbackReplaceByIdPostFeedbacksidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPutFeedbacksid(params: {  "id": string; "data"?: Feedback; }, options?: any) {
        return FeedbackApiFp.feedbackReplaceByIdPutFeedbacksid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params: {  "data"?: Feedback; }, options?: any) {
        return FeedbackApiFp.feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePutFeedbacks(params: {  "data"?: Feedback; }, options?: any) {
        return FeedbackApiFp.feedbackReplaceOrCreatePutFeedbacks(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpdateAll(params: {  "where"?: string; "data"?: Feedback; }, options?: any) {
        return FeedbackApiFp.feedbackUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpsertWithWhere(params: {  "where"?: string; "data"?: Feedback; }, options?: any) {
        return FeedbackApiFp.feedbackUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * FeedbackApi - factory interface
 */
export const FeedbackApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        feedbackCount(params: {  "where"?: string; }, options?: any) {
            return FeedbackApiFp.feedbackCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        feedbackCreate(params: {  "data"?: Feedback; }, options?: any) {
            return FeedbackApiFp.feedbackCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        feedbackCreateChangeStreamGetFeedbacksChangeStream(params: {  "options"?: string; }, options?: any) {
            return FeedbackApiFp.feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        feedbackCreateChangeStreamPostFeedbacksChangeStream(params: {  "options"?: string; }, options?: any) {
            return FeedbackApiFp.feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        feedbackDeleteById(params: {  "id": string; }, options?: any) {
            return FeedbackApiFp.feedbackDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        feedbackExistsGetFeedbacksidExists(params: {  "id": string; }, options?: any) {
            return FeedbackApiFp.feedbackExistsGetFeedbacksidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        feedbackExistsHeadFeedbacksid(params: {  "id": string; }, options?: any) {
            return FeedbackApiFp.feedbackExistsHeadFeedbacksid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        feedbackFind(params: {  "filter"?: string; }, options?: any) {
            return FeedbackApiFp.feedbackFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        feedbackFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return FeedbackApiFp.feedbackFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        feedbackFindOne(params: {  "filter"?: string; }, options?: any) {
            return FeedbackApiFp.feedbackFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        feedbackPatchOrCreate(params: {  "data"?: Feedback; }, options?: any) {
            return FeedbackApiFp.feedbackPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation account.
         * @param id Feedback id
         * @param refresh 
         */
        feedbackPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return FeedbackApiFp.feedbackPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Feedback id
         * @param data An object of model property name/value pairs
         */
        feedbackPrototypePatchAttributes(params: {  "id": string; "data"?: Feedback; }, options?: any) {
            return FeedbackApiFp.feedbackPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        feedbackReplaceByIdPostFeedbacksidReplace(params: {  "id": string; "data"?: Feedback; }, options?: any) {
            return FeedbackApiFp.feedbackReplaceByIdPostFeedbacksidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        feedbackReplaceByIdPutFeedbacksid(params: {  "id": string; "data"?: Feedback; }, options?: any) {
            return FeedbackApiFp.feedbackReplaceByIdPutFeedbacksid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params: {  "data"?: Feedback; }, options?: any) {
            return FeedbackApiFp.feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        feedbackReplaceOrCreatePutFeedbacks(params: {  "data"?: Feedback; }, options?: any) {
            return FeedbackApiFp.feedbackReplaceOrCreatePutFeedbacks(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        feedbackUpdateAll(params: {  "where"?: string; "data"?: Feedback; }, options?: any) {
            return FeedbackApiFp.feedbackUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        feedbackUpsertWithWhere(params: {  "where"?: string; "data"?: Feedback; }, options?: any) {
            return FeedbackApiFp.feedbackUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * OrderApi - fetch parameter creator
 */
export const OrderApiFetchParamCreator = {
    /**
     * 
     * @summary check order by account token and product
     * @param product product
     */
    orderAddToCart(params: {  "product": string; }, options?: any): FetchArgs {
        // verify required parameter "product" is set
        if (params["product"] == null) {
            throw new Error("Missing required parameter product when calling orderAddToCart");
        }
        const baseUrl = `/Orders/add-to-cart`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "product": params["product"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Orders/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderCreate(params: {  "data"?: Order; }, options?: any): FetchArgs {
        const baseUrl = `/Orders`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderCreateChangeStreamGetOrdersChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Orders/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderCreateChangeStreamPostOrdersChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Orders/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderDeleteById");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsGetOrdersidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderExistsGetOrdersidExists");
        }
        const baseUrl = `/Orders/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsHeadOrdersid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderExistsHeadOrdersid");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Orders`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderFindById");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Orders/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderPatchOrCreate(params: {  "data"?: Order; }, options?: any): FetchArgs {
        const baseUrl = `/Orders`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary payment online
     * @param data information payment
     */
    orderPaymentOrder(params: {  "data": any; }, options?: any): FetchArgs {
        // verify required parameter "data" is set
        if (params["data"] == null) {
            throw new Error("Missing required parameter data when calling orderPaymentOrder");
        }
        const baseUrl = `/Orders/payment-order`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts product of Order.
     * @param id Order id
     * @param where Criteria to match model instances
     */
    orderPrototypeCountProduct(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeCountProduct");
        }
        const baseUrl = `/Orders/{id}/product/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in product of this model.
     * @param id Order id
     * @param data 
     */
    orderPrototypeCreateProduct(params: {  "id": string; "data"?: Product; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeCreateProduct");
        }
        const baseUrl = `/Orders/{id}/product`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all product of this model.
     * @param id Order id
     */
    orderPrototypeDeleteProduct(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeDeleteProduct");
        }
        const baseUrl = `/Orders/{id}/product`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeDestroyByIdProduct(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeDestroyByIdProduct");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling orderPrototypeDestroyByIdProduct");
        }
        const baseUrl = `/Orders/{id}/product/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check the existence of product relation to an item by id.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeExistsProduct(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeExistsProduct");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling orderPrototypeExistsProduct");
        }
        const baseUrl = `/Orders/{id}/product/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeFindByIdProduct(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeFindByIdProduct");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling orderPrototypeFindByIdProduct");
        }
        const baseUrl = `/Orders/{id}/product/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Order id
     * @param refresh 
     */
    orderPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeGetAccount");
        }
        const baseUrl = `/Orders/{id}/account`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries product of Order.
     * @param id Order id
     * @param filter 
     */
    orderPrototypeGetProduct(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeGetProduct");
        }
        const baseUrl = `/Orders/{id}/product`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Add a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     * @param data 
     */
    orderPrototypeLinkProduct(params: {  "id": string; "fk": string; "data"?: OrderProduct; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeLinkProduct");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling orderPrototypeLinkProduct");
        }
        const baseUrl = `/Orders/{id}/product/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Order id
     * @param data An object of model property name/value pairs
     */
    orderPrototypePatchAttributes(params: {  "id": string; "data"?: Order; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypePatchAttributes");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove the product relation to an item by id.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeUnlinkProduct(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeUnlinkProduct");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling orderPrototypeUnlinkProduct");
        }
        const baseUrl = `/Orders/{id}/product/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     * @param data 
     */
    orderPrototypeUpdateByIdProduct(params: {  "id": string; "fk": string; "data"?: Product; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeUpdateByIdProduct");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling orderPrototypeUpdateByIdProduct");
        }
        const baseUrl = `/Orders/{id}/product/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPostOrdersidReplace(params: {  "id": string; "data"?: Order; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderReplaceByIdPostOrdersidReplace");
        }
        const baseUrl = `/Orders/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPutOrdersid(params: {  "id": string; "data"?: Order; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderReplaceByIdPutOrdersid");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePostOrdersReplaceOrCreate(params: {  "data"?: Order; }, options?: any): FetchArgs {
        const baseUrl = `/Orders/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePutOrders(params: {  "data"?: Order; }, options?: any): FetchArgs {
        const baseUrl = `/Orders`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary statistic order by year
     * @param year year
     */
    orderStatisticByAmount(params: {  "year": number; }, options?: any): FetchArgs {
        // verify required parameter "year" is set
        if (params["year"] == null) {
            throw new Error("Missing required parameter year when calling orderStatisticByAmount");
        }
        const baseUrl = `/Orders/statistic-amount`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "year": params["year"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary statistic order by year
     * @param year year
     */
    orderStatisticByRevenue(params: {  "year": number; }, options?: any): FetchArgs {
        // verify required parameter "year" is set
        if (params["year"] == null) {
            throw new Error("Missing required parameter year when calling orderStatisticByRevenue");
        }
        const baseUrl = `/Orders/statistic-revenue`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "year": params["year"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpdateAll(params: {  "where"?: string; "data"?: Order; }, options?: any): FetchArgs {
        const baseUrl = `/Orders/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpsertWithWhere(params: {  "where"?: string; "data"?: Order; }, options?: any): FetchArgs {
        const baseUrl = `/Orders/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * OrderApi - functional programming interface
 */
export const OrderApiFp = {
    /**
     * 
     * @summary check order by account token and product
     * @param product product
     */
    orderAddToCart(params: { "product": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = OrderApiFetchParamCreator.orderAddToCart(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = OrderApiFetchParamCreator.orderCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderCreate(params: { "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderCreateChangeStreamGetOrdersChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreator.orderCreateChangeStreamGetOrdersChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderCreateChangeStreamPostOrdersChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreator.orderCreateChangeStreamPostOrdersChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreator.orderDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsGetOrdersidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = OrderApiFetchParamCreator.orderExistsGetOrdersidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsHeadOrdersid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = OrderApiFetchParamCreator.orderExistsHeadOrdersid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Order>> {
        const fetchArgs = OrderApiFetchParamCreator.orderFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderPatchOrCreate(params: { "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary payment online
     * @param data information payment
     */
    orderPaymentOrder(params: { "data": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = OrderApiFetchParamCreator.orderPaymentOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts product of Order.
     * @param id Order id
     * @param where Criteria to match model instances
     */
    orderPrototypeCountProduct(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = OrderApiFetchParamCreator.orderPrototypeCountProduct(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in product of this model.
     * @param id Order id
     * @param data 
     */
    orderPrototypeCreateProduct(params: { "id": string; "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = OrderApiFetchParamCreator.orderPrototypeCreateProduct(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all product of this model.
     * @param id Order id
     */
    orderPrototypeDeleteProduct(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreator.orderPrototypeDeleteProduct(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeDestroyByIdProduct(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreator.orderPrototypeDestroyByIdProduct(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check the existence of product relation to an item by id.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeExistsProduct(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
        const fetchArgs = OrderApiFetchParamCreator.orderPrototypeExistsProduct(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeFindByIdProduct(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = OrderApiFetchParamCreator.orderPrototypeFindByIdProduct(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Order id
     * @param refresh 
     */
    orderPrototypeGetAccount(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Account> {
        const fetchArgs = OrderApiFetchParamCreator.orderPrototypeGetAccount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries product of Order.
     * @param id Order id
     * @param filter 
     */
    orderPrototypeGetProduct(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Product>> {
        const fetchArgs = OrderApiFetchParamCreator.orderPrototypeGetProduct(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Add a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     * @param data 
     */
    orderPrototypeLinkProduct(params: { "id": string; "fk": string; "data"?: OrderProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderProduct> {
        const fetchArgs = OrderApiFetchParamCreator.orderPrototypeLinkProduct(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Order id
     * @param data An object of model property name/value pairs
     */
    orderPrototypePatchAttributes(params: { "id": string; "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove the product relation to an item by id.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeUnlinkProduct(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreator.orderPrototypeUnlinkProduct(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     * @param data 
     */
    orderPrototypeUpdateByIdProduct(params: { "id": string; "fk": string; "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = OrderApiFetchParamCreator.orderPrototypeUpdateByIdProduct(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPostOrdersidReplace(params: { "id": string; "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderReplaceByIdPostOrdersidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPutOrdersid(params: { "id": string; "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderReplaceByIdPutOrdersid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePostOrdersReplaceOrCreate(params: { "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePutOrders(params: { "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderReplaceOrCreatePutOrders(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary statistic order by year
     * @param year year
     */
    orderStatisticByAmount(params: { "year": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreator.orderStatisticByAmount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary statistic order by year
     * @param year year
     */
    orderStatisticByRevenue(params: { "year": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderApiFetchParamCreator.orderStatisticByRevenue(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpdateAll(params: { "where"?: string; "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = OrderApiFetchParamCreator.orderUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpsertWithWhere(params: { "where"?: string; "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderApiFetchParamCreator.orderUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * OrderApi - object-oriented interface
 */
export class OrderApi extends BaseAPI {
    /**
     * 
     * @summary check order by account token and product
     * @param product product
     */
    orderAddToCart(params: {  "product": string; }, options?: any) {
        return OrderApiFp.orderAddToCart(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderCount(params: {  "where"?: string; }, options?: any) {
        return OrderApiFp.orderCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderCreate(params: {  "data"?: Order; }, options?: any) {
        return OrderApiFp.orderCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderCreateChangeStreamGetOrdersChangeStream(params: {  "options"?: string; }, options?: any) {
        return OrderApiFp.orderCreateChangeStreamGetOrdersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderCreateChangeStreamPostOrdersChangeStream(params: {  "options"?: string; }, options?: any) {
        return OrderApiFp.orderCreateChangeStreamPostOrdersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderDeleteById(params: {  "id": string; }, options?: any) {
        return OrderApiFp.orderDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsGetOrdersidExists(params: {  "id": string; }, options?: any) {
        return OrderApiFp.orderExistsGetOrdersidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsHeadOrdersid(params: {  "id": string; }, options?: any) {
        return OrderApiFp.orderExistsHeadOrdersid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFind(params: {  "filter"?: string; }, options?: any) {
        return OrderApiFp.orderFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return OrderApiFp.orderFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFindOne(params: {  "filter"?: string; }, options?: any) {
        return OrderApiFp.orderFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderPatchOrCreate(params: {  "data"?: Order; }, options?: any) {
        return OrderApiFp.orderPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary payment online
     * @param data information payment
     */
    orderPaymentOrder(params: {  "data": any; }, options?: any) {
        return OrderApiFp.orderPaymentOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts product of Order.
     * @param id Order id
     * @param where Criteria to match model instances
     */
    orderPrototypeCountProduct(params: {  "id": string; "where"?: string; }, options?: any) {
        return OrderApiFp.orderPrototypeCountProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in product of this model.
     * @param id Order id
     * @param data 
     */
    orderPrototypeCreateProduct(params: {  "id": string; "data"?: Product; }, options?: any) {
        return OrderApiFp.orderPrototypeCreateProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all product of this model.
     * @param id Order id
     */
    orderPrototypeDeleteProduct(params: {  "id": string; }, options?: any) {
        return OrderApiFp.orderPrototypeDeleteProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeDestroyByIdProduct(params: {  "id": string; "fk": string; }, options?: any) {
        return OrderApiFp.orderPrototypeDestroyByIdProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check the existence of product relation to an item by id.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeExistsProduct(params: {  "id": string; "fk": string; }, options?: any) {
        return OrderApiFp.orderPrototypeExistsProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeFindByIdProduct(params: {  "id": string; "fk": string; }, options?: any) {
        return OrderApiFp.orderPrototypeFindByIdProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation account.
     * @param id Order id
     * @param refresh 
     */
    orderPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return OrderApiFp.orderPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries product of Order.
     * @param id Order id
     * @param filter 
     */
    orderPrototypeGetProduct(params: {  "id": string; "filter"?: string; }, options?: any) {
        return OrderApiFp.orderPrototypeGetProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Add a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     * @param data 
     */
    orderPrototypeLinkProduct(params: {  "id": string; "fk": string; "data"?: OrderProduct; }, options?: any) {
        return OrderApiFp.orderPrototypeLinkProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Order id
     * @param data An object of model property name/value pairs
     */
    orderPrototypePatchAttributes(params: {  "id": string; "data"?: Order; }, options?: any) {
        return OrderApiFp.orderPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove the product relation to an item by id.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeUnlinkProduct(params: {  "id": string; "fk": string; }, options?: any) {
        return OrderApiFp.orderPrototypeUnlinkProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     * @param data 
     */
    orderPrototypeUpdateByIdProduct(params: {  "id": string; "fk": string; "data"?: Product; }, options?: any) {
        return OrderApiFp.orderPrototypeUpdateByIdProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPostOrdersidReplace(params: {  "id": string; "data"?: Order; }, options?: any) {
        return OrderApiFp.orderReplaceByIdPostOrdersidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPutOrdersid(params: {  "id": string; "data"?: Order; }, options?: any) {
        return OrderApiFp.orderReplaceByIdPutOrdersid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePostOrdersReplaceOrCreate(params: {  "data"?: Order; }, options?: any) {
        return OrderApiFp.orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePutOrders(params: {  "data"?: Order; }, options?: any) {
        return OrderApiFp.orderReplaceOrCreatePutOrders(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary statistic order by year
     * @param year year
     */
    orderStatisticByAmount(params: {  "year": number; }, options?: any) {
        return OrderApiFp.orderStatisticByAmount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary statistic order by year
     * @param year year
     */
    orderStatisticByRevenue(params: {  "year": number; }, options?: any) {
        return OrderApiFp.orderStatisticByRevenue(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpdateAll(params: {  "where"?: string; "data"?: Order; }, options?: any) {
        return OrderApiFp.orderUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpsertWithWhere(params: {  "where"?: string; "data"?: Order; }, options?: any) {
        return OrderApiFp.orderUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * OrderApi - factory interface
 */
export const OrderApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary check order by account token and product
         * @param product product
         */
        orderAddToCart(params: {  "product": string; }, options?: any) {
            return OrderApiFp.orderAddToCart(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        orderCount(params: {  "where"?: string; }, options?: any) {
            return OrderApiFp.orderCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        orderCreate(params: {  "data"?: Order; }, options?: any) {
            return OrderApiFp.orderCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        orderCreateChangeStreamGetOrdersChangeStream(params: {  "options"?: string; }, options?: any) {
            return OrderApiFp.orderCreateChangeStreamGetOrdersChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        orderCreateChangeStreamPostOrdersChangeStream(params: {  "options"?: string; }, options?: any) {
            return OrderApiFp.orderCreateChangeStreamPostOrdersChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        orderDeleteById(params: {  "id": string; }, options?: any) {
            return OrderApiFp.orderDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        orderExistsGetOrdersidExists(params: {  "id": string; }, options?: any) {
            return OrderApiFp.orderExistsGetOrdersidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        orderExistsHeadOrdersid(params: {  "id": string; }, options?: any) {
            return OrderApiFp.orderExistsHeadOrdersid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        orderFind(params: {  "filter"?: string; }, options?: any) {
            return OrderApiFp.orderFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        orderFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return OrderApiFp.orderFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        orderFindOne(params: {  "filter"?: string; }, options?: any) {
            return OrderApiFp.orderFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderPatchOrCreate(params: {  "data"?: Order; }, options?: any) {
            return OrderApiFp.orderPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary payment online
         * @param data information payment
         */
        orderPaymentOrder(params: {  "data": any; }, options?: any) {
            return OrderApiFp.orderPaymentOrder(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts product of Order.
         * @param id Order id
         * @param where Criteria to match model instances
         */
        orderPrototypeCountProduct(params: {  "id": string; "where"?: string; }, options?: any) {
            return OrderApiFp.orderPrototypeCountProduct(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in product of this model.
         * @param id Order id
         * @param data 
         */
        orderPrototypeCreateProduct(params: {  "id": string; "data"?: Product; }, options?: any) {
            return OrderApiFp.orderPrototypeCreateProduct(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all product of this model.
         * @param id Order id
         */
        orderPrototypeDeleteProduct(params: {  "id": string; }, options?: any) {
            return OrderApiFp.orderPrototypeDeleteProduct(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for product.
         * @param id Order id
         * @param fk Foreign key for product
         */
        orderPrototypeDestroyByIdProduct(params: {  "id": string; "fk": string; }, options?: any) {
            return OrderApiFp.orderPrototypeDestroyByIdProduct(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check the existence of product relation to an item by id.
         * @param id Order id
         * @param fk Foreign key for product
         */
        orderPrototypeExistsProduct(params: {  "id": string; "fk": string; }, options?: any) {
            return OrderApiFp.orderPrototypeExistsProduct(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for product.
         * @param id Order id
         * @param fk Foreign key for product
         */
        orderPrototypeFindByIdProduct(params: {  "id": string; "fk": string; }, options?: any) {
            return OrderApiFp.orderPrototypeFindByIdProduct(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation account.
         * @param id Order id
         * @param refresh 
         */
        orderPrototypeGetAccount(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return OrderApiFp.orderPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries product of Order.
         * @param id Order id
         * @param filter 
         */
        orderPrototypeGetProduct(params: {  "id": string; "filter"?: string; }, options?: any) {
            return OrderApiFp.orderPrototypeGetProduct(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add a related item by id for product.
         * @param id Order id
         * @param fk Foreign key for product
         * @param data 
         */
        orderPrototypeLinkProduct(params: {  "id": string; "fk": string; "data"?: OrderProduct; }, options?: any) {
            return OrderApiFp.orderPrototypeLinkProduct(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Order id
         * @param data An object of model property name/value pairs
         */
        orderPrototypePatchAttributes(params: {  "id": string; "data"?: Order; }, options?: any) {
            return OrderApiFp.orderPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the product relation to an item by id.
         * @param id Order id
         * @param fk Foreign key for product
         */
        orderPrototypeUnlinkProduct(params: {  "id": string; "fk": string; }, options?: any) {
            return OrderApiFp.orderPrototypeUnlinkProduct(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for product.
         * @param id Order id
         * @param fk Foreign key for product
         * @param data 
         */
        orderPrototypeUpdateByIdProduct(params: {  "id": string; "fk": string; "data"?: Product; }, options?: any) {
            return OrderApiFp.orderPrototypeUpdateByIdProduct(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        orderReplaceByIdPostOrdersidReplace(params: {  "id": string; "data"?: Order; }, options?: any) {
            return OrderApiFp.orderReplaceByIdPostOrdersidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        orderReplaceByIdPutOrdersid(params: {  "id": string; "data"?: Order; }, options?: any) {
            return OrderApiFp.orderReplaceByIdPutOrdersid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderReplaceOrCreatePostOrdersReplaceOrCreate(params: {  "data"?: Order; }, options?: any) {
            return OrderApiFp.orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderReplaceOrCreatePutOrders(params: {  "data"?: Order; }, options?: any) {
            return OrderApiFp.orderReplaceOrCreatePutOrders(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary statistic order by year
         * @param year year
         */
        orderStatisticByAmount(params: {  "year": number; }, options?: any) {
            return OrderApiFp.orderStatisticByAmount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary statistic order by year
         * @param year year
         */
        orderStatisticByRevenue(params: {  "year": number; }, options?: any) {
            return OrderApiFp.orderStatisticByRevenue(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        orderUpdateAll(params: {  "where"?: string; "data"?: Order; }, options?: any) {
            return OrderApiFp.orderUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        orderUpsertWithWhere(params: {  "where"?: string; "data"?: Order; }, options?: any) {
            return OrderApiFp.orderUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * OrderProductApi - fetch parameter creator
 */
export const OrderProductApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderProductCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/OrderProducts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderProductCreate(params: {  "data"?: OrderProduct; }, options?: any): FetchArgs {
        const baseUrl = `/OrderProducts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderProductCreateChangeStreamGetOrderProductsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/OrderProducts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderProductCreateChangeStreamPostOrderProductsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/OrderProducts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderProductDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductDeleteById");
        }
        const baseUrl = `/OrderProducts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderProductExistsGetOrderProductsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductExistsGetOrderProductsidExists");
        }
        const baseUrl = `/OrderProducts/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderProductExistsHeadOrderProductsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductExistsHeadOrderProductsid");
        }
        const baseUrl = `/OrderProducts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderProductFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/OrderProducts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderProductFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductFindById");
        }
        const baseUrl = `/OrderProducts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderProductFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/OrderProducts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get order product in cart by token
     * @param user userId
     */
    orderProductGetOrder(params: {  "user": string; }, options?: any): FetchArgs {
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling orderProductGetOrder");
        }
        const baseUrl = `/OrderProducts/get-order-cart`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "user": params["user"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductPatchOrCreate(params: {  "data"?: OrderProduct; }, options?: any): FetchArgs {
        const baseUrl = `/OrderProducts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation order.
     * @param id OrderProduct id
     * @param refresh 
     */
    orderProductPrototypeGetOrder(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductPrototypeGetOrder");
        }
        const baseUrl = `/OrderProducts/{id}/order`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation product.
     * @param id OrderProduct id
     * @param refresh 
     */
    orderProductPrototypeGetProduct(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductPrototypeGetProduct");
        }
        const baseUrl = `/OrderProducts/{id}/product`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id OrderProduct id
     * @param data An object of model property name/value pairs
     */
    orderProductPrototypePatchAttributes(params: {  "id": string; "data"?: OrderProduct; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductPrototypePatchAttributes");
        }
        const baseUrl = `/OrderProducts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderProductReplaceByIdPostOrderProductsidReplace(params: {  "id": string; "data"?: OrderProduct; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductReplaceByIdPostOrderProductsidReplace");
        }
        const baseUrl = `/OrderProducts/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderProductReplaceByIdPutOrderProductsid(params: {  "id": string; "data"?: OrderProduct; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductReplaceByIdPutOrderProductsid");
        }
        const baseUrl = `/OrderProducts/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductReplaceOrCreatePostOrderProductsReplaceOrCreate(params: {  "data"?: OrderProduct; }, options?: any): FetchArgs {
        const baseUrl = `/OrderProducts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductReplaceOrCreatePutOrderProducts(params: {  "data"?: OrderProduct; }, options?: any): FetchArgs {
        const baseUrl = `/OrderProducts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderProductUpdateAll(params: {  "where"?: string; "data"?: OrderProduct; }, options?: any): FetchArgs {
        const baseUrl = `/OrderProducts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderProductUpsertWithWhere(params: {  "where"?: string; "data"?: OrderProduct; }, options?: any): FetchArgs {
        const baseUrl = `/OrderProducts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * OrderProductApi - functional programming interface
 */
export const OrderProductApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderProductCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderProductCreate(params: { "data"?: OrderProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderProduct> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderProductCreateChangeStreamGetOrderProductsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductCreateChangeStreamGetOrderProductsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderProductCreateChangeStreamPostOrderProductsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductCreateChangeStreamPostOrderProductsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderProductDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderProductExistsGetOrderProductsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductExistsGetOrderProductsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderProductExistsHeadOrderProductsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductExistsHeadOrderProductsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderProductFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OrderProduct>> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderProductFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderProduct> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderProductFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderProduct> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get order product in cart by token
     * @param user userId
     */
    orderProductGetOrder(params: { "user": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductGetOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductPatchOrCreate(params: { "data"?: OrderProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderProduct> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation order.
     * @param id OrderProduct id
     * @param refresh 
     */
    orderProductPrototypeGetOrder(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductPrototypeGetOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation product.
     * @param id OrderProduct id
     * @param refresh 
     */
    orderProductPrototypeGetProduct(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductPrototypeGetProduct(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id OrderProduct id
     * @param data An object of model property name/value pairs
     */
    orderProductPrototypePatchAttributes(params: { "id": string; "data"?: OrderProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderProduct> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderProductReplaceByIdPostOrderProductsidReplace(params: { "id": string; "data"?: OrderProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderProduct> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductReplaceByIdPostOrderProductsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderProductReplaceByIdPutOrderProductsid(params: { "id": string; "data"?: OrderProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderProduct> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductReplaceByIdPutOrderProductsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductReplaceOrCreatePostOrderProductsReplaceOrCreate(params: { "data"?: OrderProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderProduct> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductReplaceOrCreatePostOrderProductsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductReplaceOrCreatePutOrderProducts(params: { "data"?: OrderProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderProduct> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductReplaceOrCreatePutOrderProducts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderProductUpdateAll(params: { "where"?: string; "data"?: OrderProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderProductUpsertWithWhere(params: { "where"?: string; "data"?: OrderProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderProduct> {
        const fetchArgs = OrderProductApiFetchParamCreator.orderProductUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * OrderProductApi - object-oriented interface
 */
export class OrderProductApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderProductCount(params: {  "where"?: string; }, options?: any) {
        return OrderProductApiFp.orderProductCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderProductCreate(params: {  "data"?: OrderProduct; }, options?: any) {
        return OrderProductApiFp.orderProductCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderProductCreateChangeStreamGetOrderProductsChangeStream(params: {  "options"?: string; }, options?: any) {
        return OrderProductApiFp.orderProductCreateChangeStreamGetOrderProductsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    orderProductCreateChangeStreamPostOrderProductsChangeStream(params: {  "options"?: string; }, options?: any) {
        return OrderProductApiFp.orderProductCreateChangeStreamPostOrderProductsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderProductDeleteById(params: {  "id": string; }, options?: any) {
        return OrderProductApiFp.orderProductDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderProductExistsGetOrderProductsidExists(params: {  "id": string; }, options?: any) {
        return OrderProductApiFp.orderProductExistsGetOrderProductsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderProductExistsHeadOrderProductsid(params: {  "id": string; }, options?: any) {
        return OrderProductApiFp.orderProductExistsHeadOrderProductsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderProductFind(params: {  "filter"?: string; }, options?: any) {
        return OrderProductApiFp.orderProductFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderProductFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return OrderProductApiFp.orderProductFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderProductFindOne(params: {  "filter"?: string; }, options?: any) {
        return OrderProductApiFp.orderProductFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get order product in cart by token
     * @param user userId
     */
    orderProductGetOrder(params: {  "user": string; }, options?: any) {
        return OrderProductApiFp.orderProductGetOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductPatchOrCreate(params: {  "data"?: OrderProduct; }, options?: any) {
        return OrderProductApiFp.orderProductPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation order.
     * @param id OrderProduct id
     * @param refresh 
     */
    orderProductPrototypeGetOrder(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return OrderProductApiFp.orderProductPrototypeGetOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation product.
     * @param id OrderProduct id
     * @param refresh 
     */
    orderProductPrototypeGetProduct(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return OrderProductApiFp.orderProductPrototypeGetProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id OrderProduct id
     * @param data An object of model property name/value pairs
     */
    orderProductPrototypePatchAttributes(params: {  "id": string; "data"?: OrderProduct; }, options?: any) {
        return OrderProductApiFp.orderProductPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderProductReplaceByIdPostOrderProductsidReplace(params: {  "id": string; "data"?: OrderProduct; }, options?: any) {
        return OrderProductApiFp.orderProductReplaceByIdPostOrderProductsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderProductReplaceByIdPutOrderProductsid(params: {  "id": string; "data"?: OrderProduct; }, options?: any) {
        return OrderProductApiFp.orderProductReplaceByIdPutOrderProductsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductReplaceOrCreatePostOrderProductsReplaceOrCreate(params: {  "data"?: OrderProduct; }, options?: any) {
        return OrderProductApiFp.orderProductReplaceOrCreatePostOrderProductsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductReplaceOrCreatePutOrderProducts(params: {  "data"?: OrderProduct; }, options?: any) {
        return OrderProductApiFp.orderProductReplaceOrCreatePutOrderProducts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderProductUpdateAll(params: {  "where"?: string; "data"?: OrderProduct; }, options?: any) {
        return OrderProductApiFp.orderProductUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderProductUpsertWithWhere(params: {  "where"?: string; "data"?: OrderProduct; }, options?: any) {
        return OrderProductApiFp.orderProductUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * OrderProductApi - factory interface
 */
export const OrderProductApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        orderProductCount(params: {  "where"?: string; }, options?: any) {
            return OrderProductApiFp.orderProductCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        orderProductCreate(params: {  "data"?: OrderProduct; }, options?: any) {
            return OrderProductApiFp.orderProductCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        orderProductCreateChangeStreamGetOrderProductsChangeStream(params: {  "options"?: string; }, options?: any) {
            return OrderProductApiFp.orderProductCreateChangeStreamGetOrderProductsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        orderProductCreateChangeStreamPostOrderProductsChangeStream(params: {  "options"?: string; }, options?: any) {
            return OrderProductApiFp.orderProductCreateChangeStreamPostOrderProductsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        orderProductDeleteById(params: {  "id": string; }, options?: any) {
            return OrderProductApiFp.orderProductDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        orderProductExistsGetOrderProductsidExists(params: {  "id": string; }, options?: any) {
            return OrderProductApiFp.orderProductExistsGetOrderProductsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        orderProductExistsHeadOrderProductsid(params: {  "id": string; }, options?: any) {
            return OrderProductApiFp.orderProductExistsHeadOrderProductsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        orderProductFind(params: {  "filter"?: string; }, options?: any) {
            return OrderProductApiFp.orderProductFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        orderProductFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return OrderProductApiFp.orderProductFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        orderProductFindOne(params: {  "filter"?: string; }, options?: any) {
            return OrderProductApiFp.orderProductFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get order product in cart by token
         * @param user userId
         */
        orderProductGetOrder(params: {  "user": string; }, options?: any) {
            return OrderProductApiFp.orderProductGetOrder(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderProductPatchOrCreate(params: {  "data"?: OrderProduct; }, options?: any) {
            return OrderProductApiFp.orderProductPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation order.
         * @param id OrderProduct id
         * @param refresh 
         */
        orderProductPrototypeGetOrder(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return OrderProductApiFp.orderProductPrototypeGetOrder(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation product.
         * @param id OrderProduct id
         * @param refresh 
         */
        orderProductPrototypeGetProduct(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return OrderProductApiFp.orderProductPrototypeGetProduct(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id OrderProduct id
         * @param data An object of model property name/value pairs
         */
        orderProductPrototypePatchAttributes(params: {  "id": string; "data"?: OrderProduct; }, options?: any) {
            return OrderProductApiFp.orderProductPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        orderProductReplaceByIdPostOrderProductsidReplace(params: {  "id": string; "data"?: OrderProduct; }, options?: any) {
            return OrderProductApiFp.orderProductReplaceByIdPostOrderProductsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        orderProductReplaceByIdPutOrderProductsid(params: {  "id": string; "data"?: OrderProduct; }, options?: any) {
            return OrderProductApiFp.orderProductReplaceByIdPutOrderProductsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderProductReplaceOrCreatePostOrderProductsReplaceOrCreate(params: {  "data"?: OrderProduct; }, options?: any) {
            return OrderProductApiFp.orderProductReplaceOrCreatePostOrderProductsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderProductReplaceOrCreatePutOrderProducts(params: {  "data"?: OrderProduct; }, options?: any) {
            return OrderProductApiFp.orderProductReplaceOrCreatePutOrderProducts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        orderProductUpdateAll(params: {  "where"?: string; "data"?: OrderProduct; }, options?: any) {
            return OrderProductApiFp.orderProductUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        orderProductUpsertWithWhere(params: {  "where"?: string; "data"?: OrderProduct; }, options?: any) {
            return OrderProductApiFp.orderProductUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * ProductApi - fetch parameter creator
 */
export const ProductApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    productCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Products/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    productCreate(params: {  "data"?: Product; }, options?: any): FetchArgs {
        const baseUrl = `/Products`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    productCreateChangeStreamGetProductsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Products/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    productCreateChangeStreamPostProductsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Products/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    productDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productDeleteById");
        }
        const baseUrl = `/Products/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsGetProductsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productExistsGetProductsidExists");
        }
        const baseUrl = `/Products/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsHeadProductsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productExistsHeadProductsid");
        }
        const baseUrl = `/Products/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    productFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Products`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    productFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productFindById");
        }
        const baseUrl = `/Products/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    productFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Products/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productPatchOrCreate(params: {  "data"?: Product; }, options?: any): FetchArgs {
        const baseUrl = `/Products`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Counts order of Product.
     * @param id Product id
     * @param where Criteria to match model instances
     */
    productPrototypeCountOrder(params: {  "id": string; "where"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeCountOrder");
        }
        const baseUrl = `/Products/{id}/order/count`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates a new instance in order of this model.
     * @param id Product id
     * @param data 
     */
    productPrototypeCreateOrder(params: {  "id": string; "data"?: Order; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeCreateOrder");
        }
        const baseUrl = `/Products/{id}/order`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes all order of this model.
     * @param id Product id
     */
    productPrototypeDeleteOrder(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeDeleteOrder");
        }
        const baseUrl = `/Products/{id}/order`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeDestroyByIdOrder(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeDestroyByIdOrder");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling productPrototypeDestroyByIdOrder");
        }
        const baseUrl = `/Products/{id}/order/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check the existence of order relation to an item by id.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeExistsOrder(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeExistsOrder");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling productPrototypeExistsOrder");
        }
        const baseUrl = `/Products/{id}/order/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeFindByIdOrder(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeFindByIdOrder");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling productPrototypeFindByIdOrder");
        }
        const baseUrl = `/Products/{id}/order/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation categoryProduct.
     * @param id Product id
     * @param refresh 
     */
    productPrototypeGetCategoryProduct(params: {  "id": string; "refresh"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeGetCategoryProduct");
        }
        const baseUrl = `/Products/{id}/categoryProduct`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Queries order of Product.
     * @param id Product id
     * @param filter 
     */
    productPrototypeGetOrder(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeGetOrder");
        }
        const baseUrl = `/Products/{id}/order`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Add a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     * @param data 
     */
    productPrototypeLinkOrder(params: {  "id": string; "fk": string; "data"?: OrderProduct; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeLinkOrder");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling productPrototypeLinkOrder");
        }
        const baseUrl = `/Products/{id}/order/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Product id
     * @param data An object of model property name/value pairs
     */
    productPrototypePatchAttributes(params: {  "id": string; "data"?: Product; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypePatchAttributes");
        }
        const baseUrl = `/Products/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Remove the order relation to an item by id.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeUnlinkOrder(params: {  "id": string; "fk": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeUnlinkOrder");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling productPrototypeUnlinkOrder");
        }
        const baseUrl = `/Products/{id}/order/rel/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     * @param data 
     */
    productPrototypeUpdateByIdOrder(params: {  "id": string; "fk": string; "data"?: Order; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeUpdateByIdOrder");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling productPrototypeUpdateByIdOrder");
        }
        const baseUrl = `/Products/{id}/order/{fk}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"fk"}}`, `${ params["fk"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPostProductsidReplace(params: {  "id": string; "data"?: Product; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productReplaceByIdPostProductsidReplace");
        }
        const baseUrl = `/Products/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPutProductsid(params: {  "id": string; "data"?: Product; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productReplaceByIdPutProductsid");
        }
        const baseUrl = `/Products/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePostProductsReplaceOrCreate(params: {  "data"?: Product; }, options?: any): FetchArgs {
        const baseUrl = `/Products/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePutProducts(params: {  "data"?: Product; }, options?: any): FetchArgs {
        const baseUrl = `/Products`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpdateAll(params: {  "where"?: string; "data"?: Product; }, options?: any): FetchArgs {
        const baseUrl = `/Products/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpsertWithWhere(params: {  "where"?: string; "data"?: Product; }, options?: any): FetchArgs {
        const baseUrl = `/Products/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ProductApi - functional programming interface
 */
export const ProductApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    productCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = ProductApiFetchParamCreator.productCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    productCreate(params: { "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    productCreateChangeStreamGetProductsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreator.productCreateChangeStreamGetProductsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    productCreateChangeStreamPostProductsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreator.productCreateChangeStreamPostProductsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    productDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreator.productDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsGetProductsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = ProductApiFetchParamCreator.productExistsGetProductsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsHeadProductsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = ProductApiFetchParamCreator.productExistsHeadProductsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    productFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Product>> {
        const fetchArgs = ProductApiFetchParamCreator.productFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    productFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    productFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productPatchOrCreate(params: { "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Counts order of Product.
     * @param id Product id
     * @param where Criteria to match model instances
     */
    productPrototypeCountOrder(params: { "id": string; "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = ProductApiFetchParamCreator.productPrototypeCountOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates a new instance in order of this model.
     * @param id Product id
     * @param data 
     */
    productPrototypeCreateOrder(params: { "id": string; "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = ProductApiFetchParamCreator.productPrototypeCreateOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes all order of this model.
     * @param id Product id
     */
    productPrototypeDeleteOrder(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreator.productPrototypeDeleteOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeDestroyByIdOrder(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreator.productPrototypeDestroyByIdOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check the existence of order relation to an item by id.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeExistsOrder(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
        const fetchArgs = ProductApiFetchParamCreator.productPrototypeExistsOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeFindByIdOrder(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = ProductApiFetchParamCreator.productPrototypeFindByIdOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Fetches belongsTo relation categoryProduct.
     * @param id Product id
     * @param refresh 
     */
    productPrototypeGetCategoryProduct(params: { "id": string; "refresh"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CategoryProduct> {
        const fetchArgs = ProductApiFetchParamCreator.productPrototypeGetCategoryProduct(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Queries order of Product.
     * @param id Product id
     * @param filter 
     */
    productPrototypeGetOrder(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Order>> {
        const fetchArgs = ProductApiFetchParamCreator.productPrototypeGetOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Add a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     * @param data 
     */
    productPrototypeLinkOrder(params: { "id": string; "fk": string; "data"?: OrderProduct;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderProduct> {
        const fetchArgs = ProductApiFetchParamCreator.productPrototypeLinkOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Product id
     * @param data An object of model property name/value pairs
     */
    productPrototypePatchAttributes(params: { "id": string; "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Remove the order relation to an item by id.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeUnlinkOrder(params: { "id": string; "fk": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ProductApiFetchParamCreator.productPrototypeUnlinkOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     * @param data 
     */
    productPrototypeUpdateByIdOrder(params: { "id": string; "fk": string; "data"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = ProductApiFetchParamCreator.productPrototypeUpdateByIdOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPostProductsidReplace(params: { "id": string; "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productReplaceByIdPostProductsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPutProductsid(params: { "id": string; "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productReplaceByIdPutProductsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePostProductsReplaceOrCreate(params: { "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productReplaceOrCreatePostProductsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePutProducts(params: { "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productReplaceOrCreatePutProducts(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpdateAll(params: { "where"?: string; "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = ProductApiFetchParamCreator.productUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpsertWithWhere(params: { "where"?: string; "data"?: Product;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
        const fetchArgs = ProductApiFetchParamCreator.productUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ProductApi - object-oriented interface
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    productCount(params: {  "where"?: string; }, options?: any) {
        return ProductApiFp.productCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    productCreate(params: {  "data"?: Product; }, options?: any) {
        return ProductApiFp.productCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    productCreateChangeStreamGetProductsChangeStream(params: {  "options"?: string; }, options?: any) {
        return ProductApiFp.productCreateChangeStreamGetProductsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    productCreateChangeStreamPostProductsChangeStream(params: {  "options"?: string; }, options?: any) {
        return ProductApiFp.productCreateChangeStreamPostProductsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    productDeleteById(params: {  "id": string; }, options?: any) {
        return ProductApiFp.productDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsGetProductsidExists(params: {  "id": string; }, options?: any) {
        return ProductApiFp.productExistsGetProductsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsHeadProductsid(params: {  "id": string; }, options?: any) {
        return ProductApiFp.productExistsHeadProductsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    productFind(params: {  "filter"?: string; }, options?: any) {
        return ProductApiFp.productFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    productFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return ProductApiFp.productFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    productFindOne(params: {  "filter"?: string; }, options?: any) {
        return ProductApiFp.productFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productPatchOrCreate(params: {  "data"?: Product; }, options?: any) {
        return ProductApiFp.productPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Counts order of Product.
     * @param id Product id
     * @param where Criteria to match model instances
     */
    productPrototypeCountOrder(params: {  "id": string; "where"?: string; }, options?: any) {
        return ProductApiFp.productPrototypeCountOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates a new instance in order of this model.
     * @param id Product id
     * @param data 
     */
    productPrototypeCreateOrder(params: {  "id": string; "data"?: Order; }, options?: any) {
        return ProductApiFp.productPrototypeCreateOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes all order of this model.
     * @param id Product id
     */
    productPrototypeDeleteOrder(params: {  "id": string; }, options?: any) {
        return ProductApiFp.productPrototypeDeleteOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeDestroyByIdOrder(params: {  "id": string; "fk": string; }, options?: any) {
        return ProductApiFp.productPrototypeDestroyByIdOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check the existence of order relation to an item by id.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeExistsOrder(params: {  "id": string; "fk": string; }, options?: any) {
        return ProductApiFp.productPrototypeExistsOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeFindByIdOrder(params: {  "id": string; "fk": string; }, options?: any) {
        return ProductApiFp.productPrototypeFindByIdOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Fetches belongsTo relation categoryProduct.
     * @param id Product id
     * @param refresh 
     */
    productPrototypeGetCategoryProduct(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
        return ProductApiFp.productPrototypeGetCategoryProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Queries order of Product.
     * @param id Product id
     * @param filter 
     */
    productPrototypeGetOrder(params: {  "id": string; "filter"?: string; }, options?: any) {
        return ProductApiFp.productPrototypeGetOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Add a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     * @param data 
     */
    productPrototypeLinkOrder(params: {  "id": string; "fk": string; "data"?: OrderProduct; }, options?: any) {
        return ProductApiFp.productPrototypeLinkOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Product id
     * @param data An object of model property name/value pairs
     */
    productPrototypePatchAttributes(params: {  "id": string; "data"?: Product; }, options?: any) {
        return ProductApiFp.productPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Remove the order relation to an item by id.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeUnlinkOrder(params: {  "id": string; "fk": string; }, options?: any) {
        return ProductApiFp.productPrototypeUnlinkOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     * @param data 
     */
    productPrototypeUpdateByIdOrder(params: {  "id": string; "fk": string; "data"?: Order; }, options?: any) {
        return ProductApiFp.productPrototypeUpdateByIdOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPostProductsidReplace(params: {  "id": string; "data"?: Product; }, options?: any) {
        return ProductApiFp.productReplaceByIdPostProductsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPutProductsid(params: {  "id": string; "data"?: Product; }, options?: any) {
        return ProductApiFp.productReplaceByIdPutProductsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePostProductsReplaceOrCreate(params: {  "data"?: Product; }, options?: any) {
        return ProductApiFp.productReplaceOrCreatePostProductsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePutProducts(params: {  "data"?: Product; }, options?: any) {
        return ProductApiFp.productReplaceOrCreatePutProducts(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpdateAll(params: {  "where"?: string; "data"?: Product; }, options?: any) {
        return ProductApiFp.productUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpsertWithWhere(params: {  "where"?: string; "data"?: Product; }, options?: any) {
        return ProductApiFp.productUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ProductApi - factory interface
 */
export const ProductApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        productCount(params: {  "where"?: string; }, options?: any) {
            return ProductApiFp.productCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        productCreate(params: {  "data"?: Product; }, options?: any) {
            return ProductApiFp.productCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        productCreateChangeStreamGetProductsChangeStream(params: {  "options"?: string; }, options?: any) {
            return ProductApiFp.productCreateChangeStreamGetProductsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        productCreateChangeStreamPostProductsChangeStream(params: {  "options"?: string; }, options?: any) {
            return ProductApiFp.productCreateChangeStreamPostProductsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        productDeleteById(params: {  "id": string; }, options?: any) {
            return ProductApiFp.productDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        productExistsGetProductsidExists(params: {  "id": string; }, options?: any) {
            return ProductApiFp.productExistsGetProductsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        productExistsHeadProductsid(params: {  "id": string; }, options?: any) {
            return ProductApiFp.productExistsHeadProductsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        productFind(params: {  "filter"?: string; }, options?: any) {
            return ProductApiFp.productFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        productFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return ProductApiFp.productFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        productFindOne(params: {  "filter"?: string; }, options?: any) {
            return ProductApiFp.productFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        productPatchOrCreate(params: {  "data"?: Product; }, options?: any) {
            return ProductApiFp.productPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Counts order of Product.
         * @param id Product id
         * @param where Criteria to match model instances
         */
        productPrototypeCountOrder(params: {  "id": string; "where"?: string; }, options?: any) {
            return ProductApiFp.productPrototypeCountOrder(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new instance in order of this model.
         * @param id Product id
         * @param data 
         */
        productPrototypeCreateOrder(params: {  "id": string; "data"?: Order; }, options?: any) {
            return ProductApiFp.productPrototypeCreateOrder(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes all order of this model.
         * @param id Product id
         */
        productPrototypeDeleteOrder(params: {  "id": string; }, options?: any) {
            return ProductApiFp.productPrototypeDeleteOrder(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a related item by id for order.
         * @param id Product id
         * @param fk Foreign key for order
         */
        productPrototypeDestroyByIdOrder(params: {  "id": string; "fk": string; }, options?: any) {
            return ProductApiFp.productPrototypeDestroyByIdOrder(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check the existence of order relation to an item by id.
         * @param id Product id
         * @param fk Foreign key for order
         */
        productPrototypeExistsOrder(params: {  "id": string; "fk": string; }, options?: any) {
            return ProductApiFp.productPrototypeExistsOrder(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a related item by id for order.
         * @param id Product id
         * @param fk Foreign key for order
         */
        productPrototypeFindByIdOrder(params: {  "id": string; "fk": string; }, options?: any) {
            return ProductApiFp.productPrototypeFindByIdOrder(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Fetches belongsTo relation categoryProduct.
         * @param id Product id
         * @param refresh 
         */
        productPrototypeGetCategoryProduct(params: {  "id": string; "refresh"?: boolean; }, options?: any) {
            return ProductApiFp.productPrototypeGetCategoryProduct(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Queries order of Product.
         * @param id Product id
         * @param filter 
         */
        productPrototypeGetOrder(params: {  "id": string; "filter"?: string; }, options?: any) {
            return ProductApiFp.productPrototypeGetOrder(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add a related item by id for order.
         * @param id Product id
         * @param fk Foreign key for order
         * @param data 
         */
        productPrototypeLinkOrder(params: {  "id": string; "fk": string; "data"?: OrderProduct; }, options?: any) {
            return ProductApiFp.productPrototypeLinkOrder(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Product id
         * @param data An object of model property name/value pairs
         */
        productPrototypePatchAttributes(params: {  "id": string; "data"?: Product; }, options?: any) {
            return ProductApiFp.productPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove the order relation to an item by id.
         * @param id Product id
         * @param fk Foreign key for order
         */
        productPrototypeUnlinkOrder(params: {  "id": string; "fk": string; }, options?: any) {
            return ProductApiFp.productPrototypeUnlinkOrder(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a related item by id for order.
         * @param id Product id
         * @param fk Foreign key for order
         * @param data 
         */
        productPrototypeUpdateByIdOrder(params: {  "id": string; "fk": string; "data"?: Order; }, options?: any) {
            return ProductApiFp.productPrototypeUpdateByIdOrder(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        productReplaceByIdPostProductsidReplace(params: {  "id": string; "data"?: Product; }, options?: any) {
            return ProductApiFp.productReplaceByIdPostProductsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        productReplaceByIdPutProductsid(params: {  "id": string; "data"?: Product; }, options?: any) {
            return ProductApiFp.productReplaceByIdPutProductsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        productReplaceOrCreatePostProductsReplaceOrCreate(params: {  "data"?: Product; }, options?: any) {
            return ProductApiFp.productReplaceOrCreatePostProductsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        productReplaceOrCreatePutProducts(params: {  "data"?: Product; }, options?: any) {
            return ProductApiFp.productReplaceOrCreatePutProducts(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        productUpdateAll(params: {  "where"?: string; "data"?: Product; }, options?: any) {
            return ProductApiFp.productUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        productUpsertWithWhere(params: {  "where"?: string; "data"?: Product; }, options?: any) {
            return ProductApiFp.productUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};


/**
 * TagApi - fetch parameter creator
 */
export const TagApiFetchParamCreator = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    tagCount(params: {  "where"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Tags/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    tagCreate(params: {  "data"?: Tag; }, options?: any): FetchArgs {
        const baseUrl = `/Tags`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    tagCreateChangeStreamGetTagsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Tags/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    tagCreateChangeStreamPostTagsChangeStream(params: {  "options"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Tags/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    tagDeleteById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagDeleteById");
        }
        const baseUrl = `/Tags/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsGetTagsidExists(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagExistsGetTagsidExists");
        }
        const baseUrl = `/Tags/{id}/exists`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsHeadTagsid(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagExistsHeadTagsid");
        }
        const baseUrl = `/Tags/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "HEAD" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFind(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Tags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    tagFindById(params: {  "id": string; "filter"?: string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagFindById");
        }
        const baseUrl = `/Tags/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFindOne(params: {  "filter"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/Tags/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagPatchOrCreate(params: {  "data"?: Tag; }, options?: any): FetchArgs {
        const baseUrl = `/Tags`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Tag id
     * @param data An object of model property name/value pairs
     */
    tagPrototypePatchAttributes(params: {  "id": string; "data"?: Tag; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagPrototypePatchAttributes");
        }
        const baseUrl = `/Tags/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PATCH" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPostTagsidReplace(params: {  "id": string; "data"?: Tag; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagReplaceByIdPostTagsidReplace");
        }
        const baseUrl = `/Tags/{id}/replace`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPutTagsid(params: {  "id": string; "data"?: Tag; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagReplaceByIdPutTagsid");
        }
        const baseUrl = `/Tags/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePostTagsReplaceOrCreate(params: {  "data"?: Tag; }, options?: any): FetchArgs {
        const baseUrl = `/Tags/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePutTags(params: {  "data"?: Tag; }, options?: any): FetchArgs {
        const baseUrl = `/Tags`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpdateAll(params: {  "where"?: string; "data"?: Tag; }, options?: any): FetchArgs {
        const baseUrl = `/Tags/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpsertWithWhere(params: {  "where"?: string; "data"?: Tag; }, options?: any): FetchArgs {
        const baseUrl = `/Tags/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TagApi - functional programming interface
 */
export const TagApiFp = {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    tagCount(params: { "where"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
        const fetchArgs = TagApiFetchParamCreator.tagCount(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    tagCreate(params: { "data"?: Tag;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
        const fetchArgs = TagApiFetchParamCreator.tagCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    tagCreateChangeStreamGetTagsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TagApiFetchParamCreator.tagCreateChangeStreamGetTagsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    tagCreateChangeStreamPostTagsChangeStream(params: { "options"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TagApiFetchParamCreator.tagCreateChangeStreamPostTagsChangeStream(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    tagDeleteById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TagApiFetchParamCreator.tagDeleteById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsGetTagsidExists(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = TagApiFetchParamCreator.tagExistsGetTagsidExists(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsHeadTagsid(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
        const fetchArgs = TagApiFetchParamCreator.tagExistsHeadTagsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFind(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Tag>> {
        const fetchArgs = TagApiFetchParamCreator.tagFind(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    tagFindById(params: { "id": string; "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
        const fetchArgs = TagApiFetchParamCreator.tagFindById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFindOne(params: { "filter"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
        const fetchArgs = TagApiFetchParamCreator.tagFindOne(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagPatchOrCreate(params: { "data"?: Tag;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
        const fetchArgs = TagApiFetchParamCreator.tagPatchOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Tag id
     * @param data An object of model property name/value pairs
     */
    tagPrototypePatchAttributes(params: { "id": string; "data"?: Tag;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
        const fetchArgs = TagApiFetchParamCreator.tagPrototypePatchAttributes(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPostTagsidReplace(params: { "id": string; "data"?: Tag;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
        const fetchArgs = TagApiFetchParamCreator.tagReplaceByIdPostTagsidReplace(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPutTagsid(params: { "id": string; "data"?: Tag;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
        const fetchArgs = TagApiFetchParamCreator.tagReplaceByIdPutTagsid(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePostTagsReplaceOrCreate(params: { "data"?: Tag;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
        const fetchArgs = TagApiFetchParamCreator.tagReplaceOrCreatePostTagsReplaceOrCreate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePutTags(params: { "data"?: Tag;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
        const fetchArgs = TagApiFetchParamCreator.tagReplaceOrCreatePutTags(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpdateAll(params: { "where"?: string; "data"?: Tag;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2004> {
        const fetchArgs = TagApiFetchParamCreator.tagUpdateAll(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpsertWithWhere(params: { "where"?: string; "data"?: Tag;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Tag> {
        const fetchArgs = TagApiFetchParamCreator.tagUpsertWithWhere(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TagApi - object-oriented interface
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    tagCount(params: {  "where"?: string; }, options?: any) {
        return TagApiFp.tagCount(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    tagCreate(params: {  "data"?: Tag; }, options?: any) {
        return TagApiFp.tagCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    tagCreateChangeStreamGetTagsChangeStream(params: {  "options"?: string; }, options?: any) {
        return TagApiFp.tagCreateChangeStreamGetTagsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Create a change stream.
     * @param options 
     */
    tagCreateChangeStreamPostTagsChangeStream(params: {  "options"?: string; }, options?: any) {
        return TagApiFp.tagCreateChangeStreamPostTagsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    tagDeleteById(params: {  "id": string; }, options?: any) {
        return TagApiFp.tagDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsGetTagsidExists(params: {  "id": string; }, options?: any) {
        return TagApiFp.tagExistsGetTagsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsHeadTagsid(params: {  "id": string; }, options?: any) {
        return TagApiFp.tagExistsHeadTagsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFind(params: {  "filter"?: string; }, options?: any) {
        return TagApiFp.tagFind(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    tagFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
        return TagApiFp.tagFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFindOne(params: {  "filter"?: string; }, options?: any) {
        return TagApiFp.tagFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagPatchOrCreate(params: {  "data"?: Tag; }, options?: any) {
        return TagApiFp.tagPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Tag id
     * @param data An object of model property name/value pairs
     */
    tagPrototypePatchAttributes(params: {  "id": string; "data"?: Tag; }, options?: any) {
        return TagApiFp.tagPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPostTagsidReplace(params: {  "id": string; "data"?: Tag; }, options?: any) {
        return TagApiFp.tagReplaceByIdPostTagsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPutTagsid(params: {  "id": string; "data"?: Tag; }, options?: any) {
        return TagApiFp.tagReplaceByIdPutTagsid(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePostTagsReplaceOrCreate(params: {  "data"?: Tag; }, options?: any) {
        return TagApiFp.tagReplaceOrCreatePostTagsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePutTags(params: {  "data"?: Tag; }, options?: any) {
        return TagApiFp.tagReplaceOrCreatePutTags(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpdateAll(params: {  "where"?: string; "data"?: Tag; }, options?: any) {
        return TagApiFp.tagUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpsertWithWhere(params: {  "where"?: string; "data"?: Tag; }, options?: any) {
        return TagApiFp.tagUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TagApi - factory interface
 */
export const TagApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        tagCount(params: {  "where"?: string; }, options?: any) {
            return TagApiFp.tagCount(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        tagCreate(params: {  "data"?: Tag; }, options?: any) {
            return TagApiFp.tagCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        tagCreateChangeStreamGetTagsChangeStream(params: {  "options"?: string; }, options?: any) {
            return TagApiFp.tagCreateChangeStreamGetTagsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a change stream.
         * @param options 
         */
        tagCreateChangeStreamPostTagsChangeStream(params: {  "options"?: string; }, options?: any) {
            return TagApiFp.tagCreateChangeStreamPostTagsChangeStream(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        tagDeleteById(params: {  "id": string; }, options?: any) {
            return TagApiFp.tagDeleteById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        tagExistsGetTagsidExists(params: {  "id": string; }, options?: any) {
            return TagApiFp.tagExistsGetTagsidExists(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        tagExistsHeadTagsid(params: {  "id": string; }, options?: any) {
            return TagApiFp.tagExistsHeadTagsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        tagFind(params: {  "filter"?: string; }, options?: any) {
            return TagApiFp.tagFind(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        tagFindById(params: {  "id": string; "filter"?: string; }, options?: any) {
            return TagApiFp.tagFindById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        tagFindOne(params: {  "filter"?: string; }, options?: any) {
            return TagApiFp.tagFindOne(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        tagPatchOrCreate(params: {  "data"?: Tag; }, options?: any) {
            return TagApiFp.tagPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Tag id
         * @param data An object of model property name/value pairs
         */
        tagPrototypePatchAttributes(params: {  "id": string; "data"?: Tag; }, options?: any) {
            return TagApiFp.tagPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        tagReplaceByIdPostTagsidReplace(params: {  "id": string; "data"?: Tag; }, options?: any) {
            return TagApiFp.tagReplaceByIdPostTagsidReplace(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        tagReplaceByIdPutTagsid(params: {  "id": string; "data"?: Tag; }, options?: any) {
            return TagApiFp.tagReplaceByIdPutTagsid(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        tagReplaceOrCreatePostTagsReplaceOrCreate(params: {  "data"?: Tag; }, options?: any) {
            return TagApiFp.tagReplaceOrCreatePostTagsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        tagReplaceOrCreatePutTags(params: {  "data"?: Tag; }, options?: any) {
            return TagApiFp.tagReplaceOrCreatePutTags(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        tagUpdateAll(params: {  "where"?: string; "data"?: Tag; }, options?: any) {
            return TagApiFp.tagUpdateAll(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        tagUpsertWithWhere(params: {  "where"?: string; "data"?: Tag; }, options?: any) {
            return TagApiFp.tagUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};

