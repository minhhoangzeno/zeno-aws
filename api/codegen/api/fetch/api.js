"use strict";
/**
 * plan-de-transport-api
 * plan-de-transport-api
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TagApiFactory = exports.TagApi = exports.TagApiFp = exports.TagApiFetchParamCreator = exports.ProductApiFactory = exports.ProductApi = exports.ProductApiFp = exports.ProductApiFetchParamCreator = exports.OrderProductApiFactory = exports.OrderProductApi = exports.OrderProductApiFp = exports.OrderProductApiFetchParamCreator = exports.OrderApiFactory = exports.OrderApi = exports.OrderApiFp = exports.OrderApiFetchParamCreator = exports.FeedbackApiFactory = exports.FeedbackApi = exports.FeedbackApiFp = exports.FeedbackApiFetchParamCreator = exports.ContainerApiFactory = exports.ContainerApi = exports.ContainerApiFp = exports.ContainerApiFetchParamCreator = exports.ContactApiFactory = exports.ContactApi = exports.ContactApiFp = exports.ContactApiFetchParamCreator = exports.CategoryProductApiFactory = exports.CategoryProductApi = exports.CategoryProductApiFp = exports.CategoryProductApiFetchParamCreator = exports.BlogApiFactory = exports.BlogApi = exports.BlogApiFp = exports.BlogApiFetchParamCreator = exports.BannerApiFactory = exports.BannerApi = exports.BannerApiFp = exports.BannerApiFetchParamCreator = exports.AccountTokenApiFactory = exports.AccountTokenApi = exports.AccountTokenApiFp = exports.AccountTokenApiFetchParamCreator = exports.AccountApiFactory = exports.AccountApi = exports.AccountApiFp = exports.AccountApiFetchParamCreator = exports.BaseAPI = void 0;
const querystring = require("querystring");
const url = require("url");
const isomorphicFetch = require("isomorphic-fetch");
const assign = require("core-js/library/fn/object/assign");
const BASE_PATH = "https://localhost/api".replace(/\/+$/, "");
class BaseAPI {
    basePath;
    fetch;
    constructor(fetch = isomorphicFetch, basePath = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 * AccountApi - fetch parameter creator
 */
exports.AccountApiFetchParamCreator = {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    accountChangePassword(params, options) {
        // verify required parameter "oldPassword" is set
        if (params["oldPassword"] == null) {
            throw new Error("Missing required parameter oldPassword when calling accountChangePassword");
        }
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountChangePassword");
        }
        const baseUrl = `/Accounts/change-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "oldPassword": params["oldPassword"],
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Change role of user
     * @param data context of request
     */
    accountChangeRole(params, options) {
        // verify required parameter "data" is set
        if (params["data"] == null) {
            throw new Error("Missing required parameter data when calling accountChangeRole");
        }
        const baseUrl = `/Accounts/change-role`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "data": params["data"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    accountConfirm(params, options) {
        // verify required parameter "uid" is set
        if (params["uid"] == null) {
            throw new Error("Missing required parameter uid when calling accountConfirm");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            throw new Error("Missing required parameter token when calling accountConfirm");
        }
        const baseUrl = `/Accounts/confirm`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "uid": params["uid"],
            "token": params["token"],
            "redirect": params["redirect"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params, options) {
        const baseUrl = `/Accounts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamGetAccountsChangeStream(params, options) {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamPostAccountsChangeStream(params, options) {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountDeleteById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsGetAccountsidExists");
        }
        const baseUrl = `/Accounts/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsHeadAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountFindById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params, options) {
        const baseUrl = `/Accounts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Get account by token
     */
    accountGetMe(options) {
        const baseUrl = `/Accounts/get-me`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params, options) {
        // verify required parameter "credentials" is set
        if (params["credentials"] == null) {
            throw new Error("Missing required parameter credentials when calling accountLogin");
        }
        const baseUrl = `/Accounts/login`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "include": params["include"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["credentials"]) {
            fetchOptions.body = JSON.stringify(params["credentials"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Logout a user with access token.
     */
    accountLogout(options) {
        const baseUrl = `/Accounts/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/count`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/count`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeExistsRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeExistsRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeLinkRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeLinkRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeLinkRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypePatchAttributes");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUnlinkRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUnlinkRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    accountPrototypeUpdateByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeUpdateByIdRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeVerify");
        }
        const baseUrl = `/Accounts/{id}/verify`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPostAccountsidReplace");
        }
        const baseUrl = `/Accounts/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPutAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
        const baseUrl = `/Accounts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    accountResetPassword(params, options) {
        // verify required parameter "options" is set
        if (params["options"] == null) {
            throw new Error("Missing required parameter options when calling accountResetPassword");
        }
        const baseUrl = `/Accounts/reset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    accountSetPassword(params, options) {
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountSetPassword");
        }
        const baseUrl = `/Accounts/reset-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params, options) {
        const baseUrl = `/Accounts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params, options) {
        const baseUrl = `/Accounts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * AccountApi - functional programming interface
 */
exports.AccountApiFp = {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    accountChangePassword(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountChangePassword(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Change role of user
     * @param data context of request
     */
    accountChangeRole(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountChangeRole(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    accountConfirm(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountConfirm(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamGetAccountsChangeStream(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCreateChangeStreamGetAccountsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamPostAccountsChangeStream(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCreateChangeStreamPostAccountsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountExistsGetAccountsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountExistsHeadAccountsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Get account by token
     */
    accountGetMe(options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountGetMe(options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountLogin(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Logout a user with access token.
     */
    accountLogout(options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountLogout(options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeExistsRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeLinkRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeLinkRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUnlinkRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    accountPrototypeUpdateByIdAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeUpdateByIdRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeVerify(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceByIdPostAccountsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceByIdPutAccountsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceOrCreatePutAccounts(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    accountResetPassword(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountResetPassword(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    accountSetPassword(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountSetPassword(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * AccountApi - object-oriented interface
 */
class AccountApi extends BaseAPI {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    accountChangePassword(params, options) {
        return exports.AccountApiFp.accountChangePassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Change role of user
     * @param data context of request
     */
    accountChangeRole(params, options) {
        return exports.AccountApiFp.accountChangeRole(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    accountConfirm(params, options) {
        return exports.AccountApiFp.accountConfirm(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params, options) {
        return exports.AccountApiFp.accountCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params, options) {
        return exports.AccountApiFp.accountCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamGetAccountsChangeStream(params, options) {
        return exports.AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamPostAccountsChangeStream(params, options) {
        return exports.AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params, options) {
        return exports.AccountApiFp.accountDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params, options) {
        return exports.AccountApiFp.accountExistsGetAccountsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params, options) {
        return exports.AccountApiFp.accountExistsHeadAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params, options) {
        return exports.AccountApiFp.accountFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params, options) {
        return exports.AccountApiFp.accountFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params, options) {
        return exports.AccountApiFp.accountFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get account by token
     */
    accountGetMe(options) {
        return exports.AccountApiFp.accountGetMe(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params, options) {
        return exports.AccountApiFp.accountLogin(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Logout a user with access token.
     */
    accountLogout(options) {
        return exports.AccountApiFp.accountLogout(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params, options) {
        return exports.AccountApiFp.accountPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeCountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeCountRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeExistsRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeGetAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeGetRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeLinkRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeLinkRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params, options) {
        return exports.AccountApiFp.accountPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeUnlinkRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    accountPrototypeUpdateByIdAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeUpdateByIdRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params, options) {
        return exports.AccountApiFp.accountPrototypeVerify(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params, options) {
        return exports.AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params, options) {
        return exports.AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
        return exports.AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params, options) {
        return exports.AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    accountResetPassword(params, options) {
        return exports.AccountApiFp.accountResetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    accountSetPassword(params, options) {
        return exports.AccountApiFp.accountSetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params, options) {
        return exports.AccountApiFp.accountUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params, options) {
        return exports.AccountApiFp.accountUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.AccountApi = AccountApi;
;
/**
 * AccountApi - factory interface
 */
const AccountApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Change a user's password.
         * @param oldPassword
         * @param newPassword
         */
        accountChangePassword(params, options) {
            return exports.AccountApiFp.accountChangePassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Change role of user
         * @param data context of request
         */
        accountChangeRole(params, options) {
            return exports.AccountApiFp.accountChangeRole(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Confirm a user registration with identity verification token.
         * @param uid
         * @param token
         * @param redirect
         */
        accountConfirm(params, options) {
            return exports.AccountApiFp.accountConfirm(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountCount(params, options) {
            return exports.AccountApiFp.accountCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountCreate(params, options) {
            return exports.AccountApiFp.accountCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountCreateChangeStreamGetAccountsChangeStream(params, options) {
            return exports.AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountCreateChangeStreamPostAccountsChangeStream(params, options) {
            return exports.AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountDeleteById(params, options) {
            return exports.AccountApiFp.accountDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsGetAccountsidExists(params, options) {
            return exports.AccountApiFp.accountExistsGetAccountsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsHeadAccountsid(params, options) {
            return exports.AccountApiFp.accountExistsHeadAccountsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFind(params, options) {
            return exports.AccountApiFp.accountFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountFindById(params, options) {
            return exports.AccountApiFp.accountFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFindOne(params, options) {
            return exports.AccountApiFp.accountFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get account by token
         */
        accountGetMe(options) {
            return exports.AccountApiFp.accountGetMe(options)(fetch, basePath);
        },
        /**
         *
         * @summary Login a user with username/email and password.
         * @param credentials
         * @param include Related objects to include in the response. See the description of return value for more details.
         */
        accountLogin(params, options) {
            return exports.AccountApiFp.accountLogin(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Logout a user with access token.
         */
        accountLogout(options) {
            return exports.AccountApiFp.accountLogout(options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountPatchOrCreate(params, options) {
            return exports.AccountApiFp.accountPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts accessTokens of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeCountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts roles of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeCountRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in accessTokens of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in roles of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all accessTokens of this model.
         * @param id Account id
         */
        accountPrototypeDeleteAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all roles of this model.
         * @param id Account id
         */
        accountPrototypeDeleteRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeDestroyByIdAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeDestroyByIdRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of roles relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeExistsRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeExistsRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeFindByIdAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeFindByIdRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries accessTokens of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeGetAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries roles of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeGetRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         * @param data
         */
        accountPrototypeLinkRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeLinkRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Account id
         * @param data An object of model property name/value pairs
         */
        accountPrototypePatchAttributes(params, options) {
            return exports.AccountApiFp.accountPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the roles relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeUnlinkRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeUnlinkRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         * @param data
         */
        accountPrototypeUpdateByIdAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         * @param data
         */
        accountPrototypeUpdateByIdRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Trigger user's identity verification with configured verifyOptions
         * @param id Account id
         */
        accountPrototypeVerify(params, options) {
            return exports.AccountApiFp.accountPrototypeVerify(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPostAccountsidReplace(params, options) {
            return exports.AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPutAccountsid(params, options) {
            return exports.AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
            return exports.AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePutAccounts(params, options) {
            return exports.AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Reset password for a user with email.
         * @param options
         */
        accountResetPassword(params, options) {
            return exports.AccountApiFp.accountResetPassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Reset user's password via a password-reset token.
         * @param newPassword
         */
        accountSetPassword(params, options) {
            return exports.AccountApiFp.accountSetPassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpdateAll(params, options) {
            return exports.AccountApiFp.accountUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpsertWithWhere(params, options) {
            return exports.AccountApiFp.accountUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.AccountApiFactory = AccountApiFactory;
/**
 * AccountTokenApi - fetch parameter creator
 */
exports.AccountTokenApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params, options) {
        const baseUrl = `/AccountTokens/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params, options) {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options) {
        const baseUrl = `/AccountTokens/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options) {
        const baseUrl = `/AccountTokens/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenDeleteById");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenExistsGetAccountTokensidExists");
        }
        const baseUrl = `/AccountTokens/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenExistsHeadAccountTokensid");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params, options) {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenFindById");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params, options) {
        const baseUrl = `/AccountTokens/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params, options) {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh
     */
    accountTokenPrototypeGetUser(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenPrototypeGetUser");
        }
        const baseUrl = `/AccountTokens/{id}/user`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenPrototypePatchAttributes");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenReplaceByIdPostAccountTokensidReplace");
        }
        const baseUrl = `/AccountTokens/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenReplaceByIdPutAccountTokensid");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options) {
        const baseUrl = `/AccountTokens/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params, options) {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params, options) {
        const baseUrl = `/AccountTokens/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params, options) {
        const baseUrl = `/AccountTokens/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * AccountTokenApi - functional programming interface
 */
exports.AccountTokenApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenExistsGetAccountTokensidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenExistsHeadAccountTokensid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh
     */
    accountTokenPrototypeGetUser(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenPrototypeGetUser(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenReplaceByIdPostAccountTokensidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenReplaceByIdPutAccountTokensid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenReplaceOrCreatePutAccountTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * AccountTokenApi - object-oriented interface
 */
class AccountTokenApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params, options) {
        return exports.AccountTokenApiFp.accountTokenCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params, options) {
        return exports.AccountTokenApiFp.accountTokenCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options) {
        return exports.AccountTokenApiFp.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options) {
        return exports.AccountTokenApiFp.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params, options) {
        return exports.AccountTokenApiFp.accountTokenDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params, options) {
        return exports.AccountTokenApiFp.accountTokenExistsGetAccountTokensidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params, options) {
        return exports.AccountTokenApiFp.accountTokenExistsHeadAccountTokensid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params, options) {
        return exports.AccountTokenApiFp.accountTokenFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params, options) {
        return exports.AccountTokenApiFp.accountTokenFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params, options) {
        return exports.AccountTokenApiFp.accountTokenFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params, options) {
        return exports.AccountTokenApiFp.accountTokenPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh
     */
    accountTokenPrototypeGetUser(params, options) {
        return exports.AccountTokenApiFp.accountTokenPrototypeGetUser(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params, options) {
        return exports.AccountTokenApiFp.accountTokenPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params, options) {
        return exports.AccountTokenApiFp.accountTokenReplaceByIdPostAccountTokensidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params, options) {
        return exports.AccountTokenApiFp.accountTokenReplaceByIdPutAccountTokensid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options) {
        return exports.AccountTokenApiFp.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params, options) {
        return exports.AccountTokenApiFp.accountTokenReplaceOrCreatePutAccountTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params, options) {
        return exports.AccountTokenApiFp.accountTokenUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params, options) {
        return exports.AccountTokenApiFp.accountTokenUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.AccountTokenApi = AccountTokenApi;
;
/**
 * AccountTokenApi - factory interface
 */
const AccountTokenApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountTokenCount(params, options) {
            return exports.AccountTokenApiFp.accountTokenCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountTokenCreate(params, options) {
            return exports.AccountTokenApiFp.accountTokenCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options) {
            return exports.AccountTokenApiFp.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options) {
            return exports.AccountTokenApiFp.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountTokenDeleteById(params, options) {
            return exports.AccountTokenApiFp.accountTokenDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountTokenExistsGetAccountTokensidExists(params, options) {
            return exports.AccountTokenApiFp.accountTokenExistsGetAccountTokensidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountTokenExistsHeadAccountTokensid(params, options) {
            return exports.AccountTokenApiFp.accountTokenExistsHeadAccountTokensid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountTokenFind(params, options) {
            return exports.AccountTokenApiFp.accountTokenFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountTokenFindById(params, options) {
            return exports.AccountTokenApiFp.accountTokenFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountTokenFindOne(params, options) {
            return exports.AccountTokenApiFp.accountTokenFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenPatchOrCreate(params, options) {
            return exports.AccountTokenApiFp.accountTokenPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation user.
         * @param id AccountToken id
         * @param refresh
         */
        accountTokenPrototypeGetUser(params, options) {
            return exports.AccountTokenApiFp.accountTokenPrototypeGetUser(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id AccountToken id
         * @param data An object of model property name/value pairs
         */
        accountTokenPrototypePatchAttributes(params, options) {
            return exports.AccountTokenApiFp.accountTokenPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountTokenReplaceByIdPostAccountTokensidReplace(params, options) {
            return exports.AccountTokenApiFp.accountTokenReplaceByIdPostAccountTokensidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountTokenReplaceByIdPutAccountTokensid(params, options) {
            return exports.AccountTokenApiFp.accountTokenReplaceByIdPutAccountTokensid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options) {
            return exports.AccountTokenApiFp.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenReplaceOrCreatePutAccountTokens(params, options) {
            return exports.AccountTokenApiFp.accountTokenReplaceOrCreatePutAccountTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountTokenUpdateAll(params, options) {
            return exports.AccountTokenApiFp.accountTokenUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountTokenUpsertWithWhere(params, options) {
            return exports.AccountTokenApiFp.accountTokenUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.AccountTokenApiFactory = AccountTokenApiFactory;
/**
 * BannerApi - fetch parameter creator
 */
exports.BannerApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    bannerCount(params, options) {
        const baseUrl = `/Banners/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    bannerCreate(params, options) {
        const baseUrl = `/Banners`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    bannerCreateChangeStreamGetBannersChangeStream(params, options) {
        const baseUrl = `/Banners/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    bannerCreateChangeStreamPostBannersChangeStream(params, options) {
        const baseUrl = `/Banners/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    bannerDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling bannerDeleteById");
        }
        const baseUrl = `/Banners/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    bannerExistsGetBannersidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling bannerExistsGetBannersidExists");
        }
        const baseUrl = `/Banners/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    bannerExistsHeadBannersid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling bannerExistsHeadBannersid");
        }
        const baseUrl = `/Banners/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    bannerFind(params, options) {
        const baseUrl = `/Banners`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    bannerFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling bannerFindById");
        }
        const baseUrl = `/Banners/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    bannerFindOne(params, options) {
        const baseUrl = `/Banners/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerPatchOrCreate(params, options) {
        const baseUrl = `/Banners`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Banner id
     * @param data An object of model property name/value pairs
     */
    bannerPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling bannerPrototypePatchAttributes");
        }
        const baseUrl = `/Banners/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    bannerReplaceByIdPostBannersidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling bannerReplaceByIdPostBannersidReplace");
        }
        const baseUrl = `/Banners/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    bannerReplaceByIdPutBannersid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling bannerReplaceByIdPutBannersid");
        }
        const baseUrl = `/Banners/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerReplaceOrCreatePostBannersReplaceOrCreate(params, options) {
        const baseUrl = `/Banners/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerReplaceOrCreatePutBanners(params, options) {
        const baseUrl = `/Banners`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    bannerUpdateAll(params, options) {
        const baseUrl = `/Banners/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    bannerUpsertWithWhere(params, options) {
        const baseUrl = `/Banners/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * BannerApi - functional programming interface
 */
exports.BannerApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    bannerCount(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    bannerCreate(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    bannerCreateChangeStreamGetBannersChangeStream(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerCreateChangeStreamGetBannersChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    bannerCreateChangeStreamPostBannersChangeStream(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerCreateChangeStreamPostBannersChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    bannerDeleteById(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    bannerExistsGetBannersidExists(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerExistsGetBannersidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    bannerExistsHeadBannersid(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerExistsHeadBannersid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    bannerFind(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    bannerFindById(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    bannerFindOne(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerPatchOrCreate(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Banner id
     * @param data An object of model property name/value pairs
     */
    bannerPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    bannerReplaceByIdPostBannersidReplace(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerReplaceByIdPostBannersidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    bannerReplaceByIdPutBannersid(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerReplaceByIdPutBannersid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerReplaceOrCreatePostBannersReplaceOrCreate(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerReplaceOrCreatePostBannersReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerReplaceOrCreatePutBanners(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerReplaceOrCreatePutBanners(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    bannerUpdateAll(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    bannerUpsertWithWhere(params, options) {
        const fetchArgs = exports.BannerApiFetchParamCreator.bannerUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * BannerApi - object-oriented interface
 */
class BannerApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    bannerCount(params, options) {
        return exports.BannerApiFp.bannerCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    bannerCreate(params, options) {
        return exports.BannerApiFp.bannerCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    bannerCreateChangeStreamGetBannersChangeStream(params, options) {
        return exports.BannerApiFp.bannerCreateChangeStreamGetBannersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    bannerCreateChangeStreamPostBannersChangeStream(params, options) {
        return exports.BannerApiFp.bannerCreateChangeStreamPostBannersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    bannerDeleteById(params, options) {
        return exports.BannerApiFp.bannerDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    bannerExistsGetBannersidExists(params, options) {
        return exports.BannerApiFp.bannerExistsGetBannersidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    bannerExistsHeadBannersid(params, options) {
        return exports.BannerApiFp.bannerExistsHeadBannersid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    bannerFind(params, options) {
        return exports.BannerApiFp.bannerFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    bannerFindById(params, options) {
        return exports.BannerApiFp.bannerFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    bannerFindOne(params, options) {
        return exports.BannerApiFp.bannerFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerPatchOrCreate(params, options) {
        return exports.BannerApiFp.bannerPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Banner id
     * @param data An object of model property name/value pairs
     */
    bannerPrototypePatchAttributes(params, options) {
        return exports.BannerApiFp.bannerPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    bannerReplaceByIdPostBannersidReplace(params, options) {
        return exports.BannerApiFp.bannerReplaceByIdPostBannersidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    bannerReplaceByIdPutBannersid(params, options) {
        return exports.BannerApiFp.bannerReplaceByIdPutBannersid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerReplaceOrCreatePostBannersReplaceOrCreate(params, options) {
        return exports.BannerApiFp.bannerReplaceOrCreatePostBannersReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    bannerReplaceOrCreatePutBanners(params, options) {
        return exports.BannerApiFp.bannerReplaceOrCreatePutBanners(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    bannerUpdateAll(params, options) {
        return exports.BannerApiFp.bannerUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    bannerUpsertWithWhere(params, options) {
        return exports.BannerApiFp.bannerUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.BannerApi = BannerApi;
;
/**
 * BannerApi - factory interface
 */
const BannerApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        bannerCount(params, options) {
            return exports.BannerApiFp.bannerCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        bannerCreate(params, options) {
            return exports.BannerApiFp.bannerCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        bannerCreateChangeStreamGetBannersChangeStream(params, options) {
            return exports.BannerApiFp.bannerCreateChangeStreamGetBannersChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        bannerCreateChangeStreamPostBannersChangeStream(params, options) {
            return exports.BannerApiFp.bannerCreateChangeStreamPostBannersChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        bannerDeleteById(params, options) {
            return exports.BannerApiFp.bannerDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        bannerExistsGetBannersidExists(params, options) {
            return exports.BannerApiFp.bannerExistsGetBannersidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        bannerExistsHeadBannersid(params, options) {
            return exports.BannerApiFp.bannerExistsHeadBannersid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        bannerFind(params, options) {
            return exports.BannerApiFp.bannerFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        bannerFindById(params, options) {
            return exports.BannerApiFp.bannerFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        bannerFindOne(params, options) {
            return exports.BannerApiFp.bannerFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        bannerPatchOrCreate(params, options) {
            return exports.BannerApiFp.bannerPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Banner id
         * @param data An object of model property name/value pairs
         */
        bannerPrototypePatchAttributes(params, options) {
            return exports.BannerApiFp.bannerPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        bannerReplaceByIdPostBannersidReplace(params, options) {
            return exports.BannerApiFp.bannerReplaceByIdPostBannersidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        bannerReplaceByIdPutBannersid(params, options) {
            return exports.BannerApiFp.bannerReplaceByIdPutBannersid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        bannerReplaceOrCreatePostBannersReplaceOrCreate(params, options) {
            return exports.BannerApiFp.bannerReplaceOrCreatePostBannersReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        bannerReplaceOrCreatePutBanners(params, options) {
            return exports.BannerApiFp.bannerReplaceOrCreatePutBanners(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        bannerUpdateAll(params, options) {
            return exports.BannerApiFp.bannerUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        bannerUpsertWithWhere(params, options) {
            return exports.BannerApiFp.bannerUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.BannerApiFactory = BannerApiFactory;
/**
 * BlogApi - fetch parameter creator
 */
exports.BlogApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    blogCount(params, options) {
        const baseUrl = `/Blogs/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    blogCreate(params, options) {
        const baseUrl = `/Blogs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    blogCreateChangeStreamGetBlogsChangeStream(params, options) {
        const baseUrl = `/Blogs/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    blogCreateChangeStreamPostBlogsChangeStream(params, options) {
        const baseUrl = `/Blogs/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    blogDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogDeleteById");
        }
        const baseUrl = `/Blogs/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsGetBlogsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogExistsGetBlogsidExists");
        }
        const baseUrl = `/Blogs/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsHeadBlogsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogExistsHeadBlogsid");
        }
        const baseUrl = `/Blogs/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFind(params, options) {
        const baseUrl = `/Blogs`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    blogFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogFindById");
        }
        const baseUrl = `/Blogs/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFindOne(params, options) {
        const baseUrl = `/Blogs/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogPatchOrCreate(params, options) {
        const baseUrl = `/Blogs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Blog id
     * @param refresh
     */
    blogPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogPrototypeGetAccount");
        }
        const baseUrl = `/Blogs/{id}/account`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation tag.
     * @param id Blog id
     * @param refresh
     */
    blogPrototypeGetTag(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogPrototypeGetTag");
        }
        const baseUrl = `/Blogs/{id}/tag`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Blog id
     * @param data An object of model property name/value pairs
     */
    blogPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogPrototypePatchAttributes");
        }
        const baseUrl = `/Blogs/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPostBlogsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogReplaceByIdPostBlogsidReplace");
        }
        const baseUrl = `/Blogs/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPutBlogsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling blogReplaceByIdPutBlogsid");
        }
        const baseUrl = `/Blogs/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options) {
        const baseUrl = `/Blogs/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePutBlogs(params, options) {
        const baseUrl = `/Blogs`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpdateAll(params, options) {
        const baseUrl = `/Blogs/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpsertWithWhere(params, options) {
        const baseUrl = `/Blogs/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * BlogApi - functional programming interface
 */
exports.BlogApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    blogCount(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    blogCreate(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    blogCreateChangeStreamGetBlogsChangeStream(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogCreateChangeStreamGetBlogsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    blogCreateChangeStreamPostBlogsChangeStream(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogCreateChangeStreamPostBlogsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    blogDeleteById(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsGetBlogsidExists(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogExistsGetBlogsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsHeadBlogsid(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogExistsHeadBlogsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFind(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    blogFindById(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFindOne(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogPatchOrCreate(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Blog id
     * @param refresh
     */
    blogPrototypeGetAccount(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation tag.
     * @param id Blog id
     * @param refresh
     */
    blogPrototypeGetTag(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogPrototypeGetTag(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Blog id
     * @param data An object of model property name/value pairs
     */
    blogPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPostBlogsidReplace(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogReplaceByIdPostBlogsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPutBlogsid(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogReplaceByIdPutBlogsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePutBlogs(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogReplaceOrCreatePutBlogs(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpdateAll(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpsertWithWhere(params, options) {
        const fetchArgs = exports.BlogApiFetchParamCreator.blogUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * BlogApi - object-oriented interface
 */
class BlogApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    blogCount(params, options) {
        return exports.BlogApiFp.blogCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    blogCreate(params, options) {
        return exports.BlogApiFp.blogCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    blogCreateChangeStreamGetBlogsChangeStream(params, options) {
        return exports.BlogApiFp.blogCreateChangeStreamGetBlogsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    blogCreateChangeStreamPostBlogsChangeStream(params, options) {
        return exports.BlogApiFp.blogCreateChangeStreamPostBlogsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    blogDeleteById(params, options) {
        return exports.BlogApiFp.blogDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsGetBlogsidExists(params, options) {
        return exports.BlogApiFp.blogExistsGetBlogsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    blogExistsHeadBlogsid(params, options) {
        return exports.BlogApiFp.blogExistsHeadBlogsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFind(params, options) {
        return exports.BlogApiFp.blogFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    blogFindById(params, options) {
        return exports.BlogApiFp.blogFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    blogFindOne(params, options) {
        return exports.BlogApiFp.blogFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogPatchOrCreate(params, options) {
        return exports.BlogApiFp.blogPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Blog id
     * @param refresh
     */
    blogPrototypeGetAccount(params, options) {
        return exports.BlogApiFp.blogPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation tag.
     * @param id Blog id
     * @param refresh
     */
    blogPrototypeGetTag(params, options) {
        return exports.BlogApiFp.blogPrototypeGetTag(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Blog id
     * @param data An object of model property name/value pairs
     */
    blogPrototypePatchAttributes(params, options) {
        return exports.BlogApiFp.blogPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPostBlogsidReplace(params, options) {
        return exports.BlogApiFp.blogReplaceByIdPostBlogsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    blogReplaceByIdPutBlogsid(params, options) {
        return exports.BlogApiFp.blogReplaceByIdPutBlogsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options) {
        return exports.BlogApiFp.blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    blogReplaceOrCreatePutBlogs(params, options) {
        return exports.BlogApiFp.blogReplaceOrCreatePutBlogs(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpdateAll(params, options) {
        return exports.BlogApiFp.blogUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    blogUpsertWithWhere(params, options) {
        return exports.BlogApiFp.blogUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.BlogApi = BlogApi;
;
/**
 * BlogApi - factory interface
 */
const BlogApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        blogCount(params, options) {
            return exports.BlogApiFp.blogCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        blogCreate(params, options) {
            return exports.BlogApiFp.blogCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        blogCreateChangeStreamGetBlogsChangeStream(params, options) {
            return exports.BlogApiFp.blogCreateChangeStreamGetBlogsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        blogCreateChangeStreamPostBlogsChangeStream(params, options) {
            return exports.BlogApiFp.blogCreateChangeStreamPostBlogsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        blogDeleteById(params, options) {
            return exports.BlogApiFp.blogDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        blogExistsGetBlogsidExists(params, options) {
            return exports.BlogApiFp.blogExistsGetBlogsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        blogExistsHeadBlogsid(params, options) {
            return exports.BlogApiFp.blogExistsHeadBlogsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        blogFind(params, options) {
            return exports.BlogApiFp.blogFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        blogFindById(params, options) {
            return exports.BlogApiFp.blogFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        blogFindOne(params, options) {
            return exports.BlogApiFp.blogFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        blogPatchOrCreate(params, options) {
            return exports.BlogApiFp.blogPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id Blog id
         * @param refresh
         */
        blogPrototypeGetAccount(params, options) {
            return exports.BlogApiFp.blogPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation tag.
         * @param id Blog id
         * @param refresh
         */
        blogPrototypeGetTag(params, options) {
            return exports.BlogApiFp.blogPrototypeGetTag(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Blog id
         * @param data An object of model property name/value pairs
         */
        blogPrototypePatchAttributes(params, options) {
            return exports.BlogApiFp.blogPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        blogReplaceByIdPostBlogsidReplace(params, options) {
            return exports.BlogApiFp.blogReplaceByIdPostBlogsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        blogReplaceByIdPutBlogsid(params, options) {
            return exports.BlogApiFp.blogReplaceByIdPutBlogsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options) {
            return exports.BlogApiFp.blogReplaceOrCreatePostBlogsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        blogReplaceOrCreatePutBlogs(params, options) {
            return exports.BlogApiFp.blogReplaceOrCreatePutBlogs(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        blogUpdateAll(params, options) {
            return exports.BlogApiFp.blogUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        blogUpsertWithWhere(params, options) {
            return exports.BlogApiFp.blogUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.BlogApiFactory = BlogApiFactory;
/**
 * CategoryProductApi - fetch parameter creator
 */
exports.CategoryProductApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    categoryProductCount(params, options) {
        const baseUrl = `/CategoryProducts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    categoryProductCreate(params, options) {
        const baseUrl = `/CategoryProducts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options) {
        const baseUrl = `/CategoryProducts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options) {
        const baseUrl = `/CategoryProducts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    categoryProductDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductDeleteById");
        }
        const baseUrl = `/CategoryProducts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsGetCategoryProductsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductExistsGetCategoryProductsidExists");
        }
        const baseUrl = `/CategoryProducts/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsHeadCategoryProductsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductExistsHeadCategoryProductsid");
        }
        const baseUrl = `/CategoryProducts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFind(params, options) {
        const baseUrl = `/CategoryProducts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    categoryProductFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductFindById");
        }
        const baseUrl = `/CategoryProducts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFindOne(params, options) {
        const baseUrl = `/CategoryProducts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductPatchOrCreate(params, options) {
        const baseUrl = `/CategoryProducts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id CategoryProduct id
     * @param data An object of model property name/value pairs
     */
    categoryProductPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductPrototypePatchAttributes");
        }
        const baseUrl = `/CategoryProducts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPostCategoryProductsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductReplaceByIdPostCategoryProductsidReplace");
        }
        const baseUrl = `/CategoryProducts/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPutCategoryProductsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling categoryProductReplaceByIdPutCategoryProductsid");
        }
        const baseUrl = `/CategoryProducts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options) {
        const baseUrl = `/CategoryProducts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePutCategoryProducts(params, options) {
        const baseUrl = `/CategoryProducts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpdateAll(params, options) {
        const baseUrl = `/CategoryProducts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpsertWithWhere(params, options) {
        const baseUrl = `/CategoryProducts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * CategoryProductApi - functional programming interface
 */
exports.CategoryProductApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    categoryProductCount(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    categoryProductCreate(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    categoryProductDeleteById(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsGetCategoryProductsidExists(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductExistsGetCategoryProductsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsHeadCategoryProductsid(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductExistsHeadCategoryProductsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFind(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    categoryProductFindById(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFindOne(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductPatchOrCreate(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id CategoryProduct id
     * @param data An object of model property name/value pairs
     */
    categoryProductPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPostCategoryProductsidReplace(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductReplaceByIdPostCategoryProductsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPutCategoryProductsid(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductReplaceByIdPutCategoryProductsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePutCategoryProducts(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductReplaceOrCreatePutCategoryProducts(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpdateAll(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpsertWithWhere(params, options) {
        const fetchArgs = exports.CategoryProductApiFetchParamCreator.categoryProductUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * CategoryProductApi - object-oriented interface
 */
class CategoryProductApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    categoryProductCount(params, options) {
        return exports.CategoryProductApiFp.categoryProductCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    categoryProductCreate(params, options) {
        return exports.CategoryProductApiFp.categoryProductCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options) {
        return exports.CategoryProductApiFp.categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options) {
        return exports.CategoryProductApiFp.categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    categoryProductDeleteById(params, options) {
        return exports.CategoryProductApiFp.categoryProductDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsGetCategoryProductsidExists(params, options) {
        return exports.CategoryProductApiFp.categoryProductExistsGetCategoryProductsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    categoryProductExistsHeadCategoryProductsid(params, options) {
        return exports.CategoryProductApiFp.categoryProductExistsHeadCategoryProductsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFind(params, options) {
        return exports.CategoryProductApiFp.categoryProductFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    categoryProductFindById(params, options) {
        return exports.CategoryProductApiFp.categoryProductFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    categoryProductFindOne(params, options) {
        return exports.CategoryProductApiFp.categoryProductFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductPatchOrCreate(params, options) {
        return exports.CategoryProductApiFp.categoryProductPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id CategoryProduct id
     * @param data An object of model property name/value pairs
     */
    categoryProductPrototypePatchAttributes(params, options) {
        return exports.CategoryProductApiFp.categoryProductPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPostCategoryProductsidReplace(params, options) {
        return exports.CategoryProductApiFp.categoryProductReplaceByIdPostCategoryProductsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    categoryProductReplaceByIdPutCategoryProductsid(params, options) {
        return exports.CategoryProductApiFp.categoryProductReplaceByIdPutCategoryProductsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options) {
        return exports.CategoryProductApiFp.categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    categoryProductReplaceOrCreatePutCategoryProducts(params, options) {
        return exports.CategoryProductApiFp.categoryProductReplaceOrCreatePutCategoryProducts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpdateAll(params, options) {
        return exports.CategoryProductApiFp.categoryProductUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    categoryProductUpsertWithWhere(params, options) {
        return exports.CategoryProductApiFp.categoryProductUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.CategoryProductApi = CategoryProductApi;
;
/**
 * CategoryProductApi - factory interface
 */
const CategoryProductApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        categoryProductCount(params, options) {
            return exports.CategoryProductApiFp.categoryProductCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        categoryProductCreate(params, options) {
            return exports.CategoryProductApiFp.categoryProductCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options) {
            return exports.CategoryProductApiFp.categoryProductCreateChangeStreamGetCategoryProductsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options) {
            return exports.CategoryProductApiFp.categoryProductCreateChangeStreamPostCategoryProductsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        categoryProductDeleteById(params, options) {
            return exports.CategoryProductApiFp.categoryProductDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        categoryProductExistsGetCategoryProductsidExists(params, options) {
            return exports.CategoryProductApiFp.categoryProductExistsGetCategoryProductsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        categoryProductExistsHeadCategoryProductsid(params, options) {
            return exports.CategoryProductApiFp.categoryProductExistsHeadCategoryProductsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        categoryProductFind(params, options) {
            return exports.CategoryProductApiFp.categoryProductFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        categoryProductFindById(params, options) {
            return exports.CategoryProductApiFp.categoryProductFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        categoryProductFindOne(params, options) {
            return exports.CategoryProductApiFp.categoryProductFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        categoryProductPatchOrCreate(params, options) {
            return exports.CategoryProductApiFp.categoryProductPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id CategoryProduct id
         * @param data An object of model property name/value pairs
         */
        categoryProductPrototypePatchAttributes(params, options) {
            return exports.CategoryProductApiFp.categoryProductPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        categoryProductReplaceByIdPostCategoryProductsidReplace(params, options) {
            return exports.CategoryProductApiFp.categoryProductReplaceByIdPostCategoryProductsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        categoryProductReplaceByIdPutCategoryProductsid(params, options) {
            return exports.CategoryProductApiFp.categoryProductReplaceByIdPutCategoryProductsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options) {
            return exports.CategoryProductApiFp.categoryProductReplaceOrCreatePostCategoryProductsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        categoryProductReplaceOrCreatePutCategoryProducts(params, options) {
            return exports.CategoryProductApiFp.categoryProductReplaceOrCreatePutCategoryProducts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        categoryProductUpdateAll(params, options) {
            return exports.CategoryProductApiFp.categoryProductUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        categoryProductUpsertWithWhere(params, options) {
            return exports.CategoryProductApiFp.categoryProductUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.CategoryProductApiFactory = CategoryProductApiFactory;
/**
 * ContactApi - fetch parameter creator
 */
exports.ContactApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    contactCount(params, options) {
        const baseUrl = `/Contacts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    contactCreate(params, options) {
        const baseUrl = `/Contacts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    contactCreateChangeStreamGetContactsChangeStream(params, options) {
        const baseUrl = `/Contacts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    contactCreateChangeStreamPostContactsChangeStream(params, options) {
        const baseUrl = `/Contacts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    contactDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactDeleteById");
        }
        const baseUrl = `/Contacts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsGetContactsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactExistsGetContactsidExists");
        }
        const baseUrl = `/Contacts/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsHeadContactsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactExistsHeadContactsid");
        }
        const baseUrl = `/Contacts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFind(params, options) {
        const baseUrl = `/Contacts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    contactFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactFindById");
        }
        const baseUrl = `/Contacts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFindOne(params, options) {
        const baseUrl = `/Contacts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactPatchOrCreate(params, options) {
        const baseUrl = `/Contacts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Contact id
     * @param data An object of model property name/value pairs
     */
    contactPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactPrototypePatchAttributes");
        }
        const baseUrl = `/Contacts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPostContactsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactReplaceByIdPostContactsidReplace");
        }
        const baseUrl = `/Contacts/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPutContactsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling contactReplaceByIdPutContactsid");
        }
        const baseUrl = `/Contacts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePostContactsReplaceOrCreate(params, options) {
        const baseUrl = `/Contacts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePutContacts(params, options) {
        const baseUrl = `/Contacts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpdateAll(params, options) {
        const baseUrl = `/Contacts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpsertWithWhere(params, options) {
        const baseUrl = `/Contacts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * ContactApi - functional programming interface
 */
exports.ContactApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    contactCount(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    contactCreate(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    contactCreateChangeStreamGetContactsChangeStream(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactCreateChangeStreamGetContactsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    contactCreateChangeStreamPostContactsChangeStream(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactCreateChangeStreamPostContactsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    contactDeleteById(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsGetContactsidExists(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactExistsGetContactsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsHeadContactsid(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactExistsHeadContactsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFind(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    contactFindById(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFindOne(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactPatchOrCreate(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Contact id
     * @param data An object of model property name/value pairs
     */
    contactPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPostContactsidReplace(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactReplaceByIdPostContactsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPutContactsid(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactReplaceByIdPutContactsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePostContactsReplaceOrCreate(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactReplaceOrCreatePostContactsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePutContacts(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactReplaceOrCreatePutContacts(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpdateAll(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpsertWithWhere(params, options) {
        const fetchArgs = exports.ContactApiFetchParamCreator.contactUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * ContactApi - object-oriented interface
 */
class ContactApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    contactCount(params, options) {
        return exports.ContactApiFp.contactCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    contactCreate(params, options) {
        return exports.ContactApiFp.contactCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    contactCreateChangeStreamGetContactsChangeStream(params, options) {
        return exports.ContactApiFp.contactCreateChangeStreamGetContactsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    contactCreateChangeStreamPostContactsChangeStream(params, options) {
        return exports.ContactApiFp.contactCreateChangeStreamPostContactsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    contactDeleteById(params, options) {
        return exports.ContactApiFp.contactDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsGetContactsidExists(params, options) {
        return exports.ContactApiFp.contactExistsGetContactsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    contactExistsHeadContactsid(params, options) {
        return exports.ContactApiFp.contactExistsHeadContactsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFind(params, options) {
        return exports.ContactApiFp.contactFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    contactFindById(params, options) {
        return exports.ContactApiFp.contactFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    contactFindOne(params, options) {
        return exports.ContactApiFp.contactFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactPatchOrCreate(params, options) {
        return exports.ContactApiFp.contactPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Contact id
     * @param data An object of model property name/value pairs
     */
    contactPrototypePatchAttributes(params, options) {
        return exports.ContactApiFp.contactPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPostContactsidReplace(params, options) {
        return exports.ContactApiFp.contactReplaceByIdPostContactsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    contactReplaceByIdPutContactsid(params, options) {
        return exports.ContactApiFp.contactReplaceByIdPutContactsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePostContactsReplaceOrCreate(params, options) {
        return exports.ContactApiFp.contactReplaceOrCreatePostContactsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    contactReplaceOrCreatePutContacts(params, options) {
        return exports.ContactApiFp.contactReplaceOrCreatePutContacts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpdateAll(params, options) {
        return exports.ContactApiFp.contactUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    contactUpsertWithWhere(params, options) {
        return exports.ContactApiFp.contactUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.ContactApi = ContactApi;
;
/**
 * ContactApi - factory interface
 */
const ContactApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        contactCount(params, options) {
            return exports.ContactApiFp.contactCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        contactCreate(params, options) {
            return exports.ContactApiFp.contactCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        contactCreateChangeStreamGetContactsChangeStream(params, options) {
            return exports.ContactApiFp.contactCreateChangeStreamGetContactsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        contactCreateChangeStreamPostContactsChangeStream(params, options) {
            return exports.ContactApiFp.contactCreateChangeStreamPostContactsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        contactDeleteById(params, options) {
            return exports.ContactApiFp.contactDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        contactExistsGetContactsidExists(params, options) {
            return exports.ContactApiFp.contactExistsGetContactsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        contactExistsHeadContactsid(params, options) {
            return exports.ContactApiFp.contactExistsHeadContactsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        contactFind(params, options) {
            return exports.ContactApiFp.contactFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        contactFindById(params, options) {
            return exports.ContactApiFp.contactFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        contactFindOne(params, options) {
            return exports.ContactApiFp.contactFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        contactPatchOrCreate(params, options) {
            return exports.ContactApiFp.contactPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Contact id
         * @param data An object of model property name/value pairs
         */
        contactPrototypePatchAttributes(params, options) {
            return exports.ContactApiFp.contactPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        contactReplaceByIdPostContactsidReplace(params, options) {
            return exports.ContactApiFp.contactReplaceByIdPostContactsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        contactReplaceByIdPutContactsid(params, options) {
            return exports.ContactApiFp.contactReplaceByIdPutContactsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        contactReplaceOrCreatePostContactsReplaceOrCreate(params, options) {
            return exports.ContactApiFp.contactReplaceOrCreatePostContactsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        contactReplaceOrCreatePutContacts(params, options) {
            return exports.ContactApiFp.contactReplaceOrCreatePutContacts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        contactUpdateAll(params, options) {
            return exports.ContactApiFp.contactUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        contactUpsertWithWhere(params, options) {
            return exports.ContactApiFp.contactUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.ContactApiFactory = ContactApiFactory;
/**
 * ContainerApi - fetch parameter creator
 */
exports.ContainerApiFetchParamCreator = {
    /**
     *
     * @param options
     */
    containerCreateContainer(params, options) {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     */
    containerDestroyContainer(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerDestroyContainer");
        }
        const baseUrl = `/Containers/{container}`
            .replace(`{${"container"}}`, `${params["container"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerDownload(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerDownload");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerDownload");
        }
        const baseUrl = `/Containers/{container}/download/{file}`
            .replace(`{${"container"}}`, `${params["container"]}`)
            .replace(`{${"file"}}`, `${params["file"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     */
    containerGetContainer(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetContainer");
        }
        const baseUrl = `/Containers/{container}`
            .replace(`{${"container"}}`, `${params["container"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     */
    containerGetContainers(options) {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerGetFile(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetFile");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerGetFile");
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${"container"}}`, `${params["container"]}`)
            .replace(`{${"file"}}`, `${params["file"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     */
    containerGetFiles(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetFiles");
        }
        const baseUrl = `/Containers/{container}/files`
            .replace(`{${"container"}}`, `${params["container"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerRemoveFile(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerRemoveFile");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerRemoveFile");
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${"container"}}`, `${params["container"]}`)
            .replace(`{${"file"}}`, `${params["file"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     */
    containerUpload(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerUpload");
        }
        const baseUrl = `/Containers/{container}/upload`
            .replace(`{${"container"}}`, `${params["container"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * ContainerApi - functional programming interface
 */
exports.ContainerApiFp = {
    /**
     *
     * @param options
     */
    containerCreateContainer(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerCreateContainer(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     */
    containerDestroyContainer(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerDestroyContainer(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerDownload(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerDownload(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     */
    containerGetContainer(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerGetContainer(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     */
    containerGetContainers(options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerGetContainers(options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerGetFile(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerGetFile(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     */
    containerGetFiles(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerGetFiles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerRemoveFile(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerRemoveFile(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     */
    containerUpload(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerUpload(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * ContainerApi - object-oriented interface
 */
class ContainerApi extends BaseAPI {
    /**
     *
     * @param options
     */
    containerCreateContainer(params, options) {
        return exports.ContainerApiFp.containerCreateContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     */
    containerDestroyContainer(params, options) {
        return exports.ContainerApiFp.containerDestroyContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     * @param file
     */
    containerDownload(params, options) {
        return exports.ContainerApiFp.containerDownload(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     */
    containerGetContainer(params, options) {
        return exports.ContainerApiFp.containerGetContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     */
    containerGetContainers(options) {
        return exports.ContainerApiFp.containerGetContainers(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     * @param file
     */
    containerGetFile(params, options) {
        return exports.ContainerApiFp.containerGetFile(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     */
    containerGetFiles(params, options) {
        return exports.ContainerApiFp.containerGetFiles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     * @param file
     */
    containerRemoveFile(params, options) {
        return exports.ContainerApiFp.containerRemoveFile(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     */
    containerUpload(params, options) {
        return exports.ContainerApiFp.containerUpload(params, options)(this.fetch, this.basePath);
    }
}
exports.ContainerApi = ContainerApi;
;
/**
 * ContainerApi - factory interface
 */
const ContainerApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @param options
         */
        containerCreateContainer(params, options) {
            return exports.ContainerApiFp.containerCreateContainer(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         */
        containerDestroyContainer(params, options) {
            return exports.ContainerApiFp.containerDestroyContainer(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         * @param file
         */
        containerDownload(params, options) {
            return exports.ContainerApiFp.containerDownload(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         */
        containerGetContainer(params, options) {
            return exports.ContainerApiFp.containerGetContainer(params, options)(fetch, basePath);
        },
        /**
         *
         */
        containerGetContainers(options) {
            return exports.ContainerApiFp.containerGetContainers(options)(fetch, basePath);
        },
        /**
         *
         * @param container
         * @param file
         */
        containerGetFile(params, options) {
            return exports.ContainerApiFp.containerGetFile(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         */
        containerGetFiles(params, options) {
            return exports.ContainerApiFp.containerGetFiles(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         * @param file
         */
        containerRemoveFile(params, options) {
            return exports.ContainerApiFp.containerRemoveFile(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         */
        containerUpload(params, options) {
            return exports.ContainerApiFp.containerUpload(params, options)(fetch, basePath);
        },
    };
};
exports.ContainerApiFactory = ContainerApiFactory;
/**
 * FeedbackApi - fetch parameter creator
 */
exports.FeedbackApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    feedbackCount(params, options) {
        const baseUrl = `/Feedbacks/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    feedbackCreate(params, options) {
        const baseUrl = `/Feedbacks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options) {
        const baseUrl = `/Feedbacks/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options) {
        const baseUrl = `/Feedbacks/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    feedbackDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackDeleteById");
        }
        const baseUrl = `/Feedbacks/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsGetFeedbacksidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackExistsGetFeedbacksidExists");
        }
        const baseUrl = `/Feedbacks/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsHeadFeedbacksid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackExistsHeadFeedbacksid");
        }
        const baseUrl = `/Feedbacks/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFind(params, options) {
        const baseUrl = `/Feedbacks`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    feedbackFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackFindById");
        }
        const baseUrl = `/Feedbacks/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFindOne(params, options) {
        const baseUrl = `/Feedbacks/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackPatchOrCreate(params, options) {
        const baseUrl = `/Feedbacks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Feedback id
     * @param refresh
     */
    feedbackPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackPrototypeGetAccount");
        }
        const baseUrl = `/Feedbacks/{id}/account`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Feedback id
     * @param data An object of model property name/value pairs
     */
    feedbackPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackPrototypePatchAttributes");
        }
        const baseUrl = `/Feedbacks/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPostFeedbacksidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackReplaceByIdPostFeedbacksidReplace");
        }
        const baseUrl = `/Feedbacks/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPutFeedbacksid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling feedbackReplaceByIdPutFeedbacksid");
        }
        const baseUrl = `/Feedbacks/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options) {
        const baseUrl = `/Feedbacks/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePutFeedbacks(params, options) {
        const baseUrl = `/Feedbacks`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpdateAll(params, options) {
        const baseUrl = `/Feedbacks/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpsertWithWhere(params, options) {
        const baseUrl = `/Feedbacks/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * FeedbackApi - functional programming interface
 */
exports.FeedbackApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    feedbackCount(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    feedbackCreate(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    feedbackDeleteById(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsGetFeedbacksidExists(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackExistsGetFeedbacksidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsHeadFeedbacksid(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackExistsHeadFeedbacksid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFind(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    feedbackFindById(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFindOne(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackPatchOrCreate(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Feedback id
     * @param refresh
     */
    feedbackPrototypeGetAccount(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Feedback id
     * @param data An object of model property name/value pairs
     */
    feedbackPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPostFeedbacksidReplace(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackReplaceByIdPostFeedbacksidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPutFeedbacksid(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackReplaceByIdPutFeedbacksid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePutFeedbacks(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackReplaceOrCreatePutFeedbacks(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpdateAll(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpsertWithWhere(params, options) {
        const fetchArgs = exports.FeedbackApiFetchParamCreator.feedbackUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * FeedbackApi - object-oriented interface
 */
class FeedbackApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    feedbackCount(params, options) {
        return exports.FeedbackApiFp.feedbackCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    feedbackCreate(params, options) {
        return exports.FeedbackApiFp.feedbackCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options) {
        return exports.FeedbackApiFp.feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options) {
        return exports.FeedbackApiFp.feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    feedbackDeleteById(params, options) {
        return exports.FeedbackApiFp.feedbackDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsGetFeedbacksidExists(params, options) {
        return exports.FeedbackApiFp.feedbackExistsGetFeedbacksidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    feedbackExistsHeadFeedbacksid(params, options) {
        return exports.FeedbackApiFp.feedbackExistsHeadFeedbacksid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFind(params, options) {
        return exports.FeedbackApiFp.feedbackFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    feedbackFindById(params, options) {
        return exports.FeedbackApiFp.feedbackFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    feedbackFindOne(params, options) {
        return exports.FeedbackApiFp.feedbackFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackPatchOrCreate(params, options) {
        return exports.FeedbackApiFp.feedbackPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Feedback id
     * @param refresh
     */
    feedbackPrototypeGetAccount(params, options) {
        return exports.FeedbackApiFp.feedbackPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Feedback id
     * @param data An object of model property name/value pairs
     */
    feedbackPrototypePatchAttributes(params, options) {
        return exports.FeedbackApiFp.feedbackPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPostFeedbacksidReplace(params, options) {
        return exports.FeedbackApiFp.feedbackReplaceByIdPostFeedbacksidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    feedbackReplaceByIdPutFeedbacksid(params, options) {
        return exports.FeedbackApiFp.feedbackReplaceByIdPutFeedbacksid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options) {
        return exports.FeedbackApiFp.feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    feedbackReplaceOrCreatePutFeedbacks(params, options) {
        return exports.FeedbackApiFp.feedbackReplaceOrCreatePutFeedbacks(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpdateAll(params, options) {
        return exports.FeedbackApiFp.feedbackUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    feedbackUpsertWithWhere(params, options) {
        return exports.FeedbackApiFp.feedbackUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.FeedbackApi = FeedbackApi;
;
/**
 * FeedbackApi - factory interface
 */
const FeedbackApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        feedbackCount(params, options) {
            return exports.FeedbackApiFp.feedbackCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        feedbackCreate(params, options) {
            return exports.FeedbackApiFp.feedbackCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options) {
            return exports.FeedbackApiFp.feedbackCreateChangeStreamGetFeedbacksChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options) {
            return exports.FeedbackApiFp.feedbackCreateChangeStreamPostFeedbacksChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        feedbackDeleteById(params, options) {
            return exports.FeedbackApiFp.feedbackDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        feedbackExistsGetFeedbacksidExists(params, options) {
            return exports.FeedbackApiFp.feedbackExistsGetFeedbacksidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        feedbackExistsHeadFeedbacksid(params, options) {
            return exports.FeedbackApiFp.feedbackExistsHeadFeedbacksid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        feedbackFind(params, options) {
            return exports.FeedbackApiFp.feedbackFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        feedbackFindById(params, options) {
            return exports.FeedbackApiFp.feedbackFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        feedbackFindOne(params, options) {
            return exports.FeedbackApiFp.feedbackFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        feedbackPatchOrCreate(params, options) {
            return exports.FeedbackApiFp.feedbackPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id Feedback id
         * @param refresh
         */
        feedbackPrototypeGetAccount(params, options) {
            return exports.FeedbackApiFp.feedbackPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Feedback id
         * @param data An object of model property name/value pairs
         */
        feedbackPrototypePatchAttributes(params, options) {
            return exports.FeedbackApiFp.feedbackPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        feedbackReplaceByIdPostFeedbacksidReplace(params, options) {
            return exports.FeedbackApiFp.feedbackReplaceByIdPostFeedbacksidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        feedbackReplaceByIdPutFeedbacksid(params, options) {
            return exports.FeedbackApiFp.feedbackReplaceByIdPutFeedbacksid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options) {
            return exports.FeedbackApiFp.feedbackReplaceOrCreatePostFeedbacksReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        feedbackReplaceOrCreatePutFeedbacks(params, options) {
            return exports.FeedbackApiFp.feedbackReplaceOrCreatePutFeedbacks(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        feedbackUpdateAll(params, options) {
            return exports.FeedbackApiFp.feedbackUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        feedbackUpsertWithWhere(params, options) {
            return exports.FeedbackApiFp.feedbackUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.FeedbackApiFactory = FeedbackApiFactory;
/**
 * OrderApi - fetch parameter creator
 */
exports.OrderApiFetchParamCreator = {
    /**
     *
     * @summary check order by account token and product
     * @param product product
     */
    orderAddToCart(params, options) {
        // verify required parameter "product" is set
        if (params["product"] == null) {
            throw new Error("Missing required parameter product when calling orderAddToCart");
        }
        const baseUrl = `/Orders/add-to-cart`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "product": params["product"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderCount(params, options) {
        const baseUrl = `/Orders/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderCreate(params, options) {
        const baseUrl = `/Orders`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderCreateChangeStreamGetOrdersChangeStream(params, options) {
        const baseUrl = `/Orders/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderCreateChangeStreamPostOrdersChangeStream(params, options) {
        const baseUrl = `/Orders/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderDeleteById");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsGetOrdersidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderExistsGetOrdersidExists");
        }
        const baseUrl = `/Orders/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsHeadOrdersid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderExistsHeadOrdersid");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFind(params, options) {
        const baseUrl = `/Orders`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderFindById");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFindOne(params, options) {
        const baseUrl = `/Orders/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderPatchOrCreate(params, options) {
        const baseUrl = `/Orders`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary payment online
     * @param data information payment
     */
    orderPaymentOrder(params, options) {
        // verify required parameter "data" is set
        if (params["data"] == null) {
            throw new Error("Missing required parameter data when calling orderPaymentOrder");
        }
        const baseUrl = `/Orders/payment-order`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts product of Order.
     * @param id Order id
     * @param where Criteria to match model instances
     */
    orderPrototypeCountProduct(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeCountProduct");
        }
        const baseUrl = `/Orders/{id}/product/count`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in product of this model.
     * @param id Order id
     * @param data
     */
    orderPrototypeCreateProduct(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeCreateProduct");
        }
        const baseUrl = `/Orders/{id}/product`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all product of this model.
     * @param id Order id
     */
    orderPrototypeDeleteProduct(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeDeleteProduct");
        }
        const baseUrl = `/Orders/{id}/product`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeDestroyByIdProduct(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeDestroyByIdProduct");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling orderPrototypeDestroyByIdProduct");
        }
        const baseUrl = `/Orders/{id}/product/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of product relation to an item by id.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeExistsProduct(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeExistsProduct");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling orderPrototypeExistsProduct");
        }
        const baseUrl = `/Orders/{id}/product/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeFindByIdProduct(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeFindByIdProduct");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling orderPrototypeFindByIdProduct");
        }
        const baseUrl = `/Orders/{id}/product/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Order id
     * @param refresh
     */
    orderPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeGetAccount");
        }
        const baseUrl = `/Orders/{id}/account`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries product of Order.
     * @param id Order id
     * @param filter
     */
    orderPrototypeGetProduct(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeGetProduct");
        }
        const baseUrl = `/Orders/{id}/product`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     * @param data
     */
    orderPrototypeLinkProduct(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeLinkProduct");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling orderPrototypeLinkProduct");
        }
        const baseUrl = `/Orders/{id}/product/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Order id
     * @param data An object of model property name/value pairs
     */
    orderPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypePatchAttributes");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the product relation to an item by id.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeUnlinkProduct(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeUnlinkProduct");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling orderPrototypeUnlinkProduct");
        }
        const baseUrl = `/Orders/{id}/product/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     * @param data
     */
    orderPrototypeUpdateByIdProduct(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeUpdateByIdProduct");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling orderPrototypeUpdateByIdProduct");
        }
        const baseUrl = `/Orders/{id}/product/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPostOrdersidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderReplaceByIdPostOrdersidReplace");
        }
        const baseUrl = `/Orders/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPutOrdersid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderReplaceByIdPutOrdersid");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options) {
        const baseUrl = `/Orders/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePutOrders(params, options) {
        const baseUrl = `/Orders`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary statistic order by year
     * @param year year
     */
    orderStatisticByAmount(params, options) {
        // verify required parameter "year" is set
        if (params["year"] == null) {
            throw new Error("Missing required parameter year when calling orderStatisticByAmount");
        }
        const baseUrl = `/Orders/statistic-amount`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "year": params["year"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary statistic order by year
     * @param year year
     */
    orderStatisticByRevenue(params, options) {
        // verify required parameter "year" is set
        if (params["year"] == null) {
            throw new Error("Missing required parameter year when calling orderStatisticByRevenue");
        }
        const baseUrl = `/Orders/statistic-revenue`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "year": params["year"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpdateAll(params, options) {
        const baseUrl = `/Orders/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpsertWithWhere(params, options) {
        const baseUrl = `/Orders/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * OrderApi - functional programming interface
 */
exports.OrderApiFp = {
    /**
     *
     * @summary check order by account token and product
     * @param product product
     */
    orderAddToCart(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderAddToCart(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderCount(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderCreate(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderCreateChangeStreamGetOrdersChangeStream(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderCreateChangeStreamGetOrdersChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderCreateChangeStreamPostOrdersChangeStream(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderCreateChangeStreamPostOrdersChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderDeleteById(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsGetOrdersidExists(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderExistsGetOrdersidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsHeadOrdersid(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderExistsHeadOrdersid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFind(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderFindById(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFindOne(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderPatchOrCreate(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary payment online
     * @param data information payment
     */
    orderPaymentOrder(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPaymentOrder(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts product of Order.
     * @param id Order id
     * @param where Criteria to match model instances
     */
    orderPrototypeCountProduct(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPrototypeCountProduct(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in product of this model.
     * @param id Order id
     * @param data
     */
    orderPrototypeCreateProduct(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPrototypeCreateProduct(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all product of this model.
     * @param id Order id
     */
    orderPrototypeDeleteProduct(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPrototypeDeleteProduct(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeDestroyByIdProduct(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPrototypeDestroyByIdProduct(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of product relation to an item by id.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeExistsProduct(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPrototypeExistsProduct(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeFindByIdProduct(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPrototypeFindByIdProduct(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Order id
     * @param refresh
     */
    orderPrototypeGetAccount(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries product of Order.
     * @param id Order id
     * @param filter
     */
    orderPrototypeGetProduct(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPrototypeGetProduct(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     * @param data
     */
    orderPrototypeLinkProduct(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPrototypeLinkProduct(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Order id
     * @param data An object of model property name/value pairs
     */
    orderPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the product relation to an item by id.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeUnlinkProduct(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPrototypeUnlinkProduct(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     * @param data
     */
    orderPrototypeUpdateByIdProduct(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPrototypeUpdateByIdProduct(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPostOrdersidReplace(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderReplaceByIdPostOrdersidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPutOrdersid(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderReplaceByIdPutOrdersid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePutOrders(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderReplaceOrCreatePutOrders(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary statistic order by year
     * @param year year
     */
    orderStatisticByAmount(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderStatisticByAmount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary statistic order by year
     * @param year year
     */
    orderStatisticByRevenue(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderStatisticByRevenue(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpdateAll(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpsertWithWhere(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * OrderApi - object-oriented interface
 */
class OrderApi extends BaseAPI {
    /**
     *
     * @summary check order by account token and product
     * @param product product
     */
    orderAddToCart(params, options) {
        return exports.OrderApiFp.orderAddToCart(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderCount(params, options) {
        return exports.OrderApiFp.orderCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderCreate(params, options) {
        return exports.OrderApiFp.orderCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderCreateChangeStreamGetOrdersChangeStream(params, options) {
        return exports.OrderApiFp.orderCreateChangeStreamGetOrdersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderCreateChangeStreamPostOrdersChangeStream(params, options) {
        return exports.OrderApiFp.orderCreateChangeStreamPostOrdersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderDeleteById(params, options) {
        return exports.OrderApiFp.orderDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsGetOrdersidExists(params, options) {
        return exports.OrderApiFp.orderExistsGetOrdersidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsHeadOrdersid(params, options) {
        return exports.OrderApiFp.orderExistsHeadOrdersid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFind(params, options) {
        return exports.OrderApiFp.orderFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderFindById(params, options) {
        return exports.OrderApiFp.orderFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFindOne(params, options) {
        return exports.OrderApiFp.orderFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderPatchOrCreate(params, options) {
        return exports.OrderApiFp.orderPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary payment online
     * @param data information payment
     */
    orderPaymentOrder(params, options) {
        return exports.OrderApiFp.orderPaymentOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts product of Order.
     * @param id Order id
     * @param where Criteria to match model instances
     */
    orderPrototypeCountProduct(params, options) {
        return exports.OrderApiFp.orderPrototypeCountProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in product of this model.
     * @param id Order id
     * @param data
     */
    orderPrototypeCreateProduct(params, options) {
        return exports.OrderApiFp.orderPrototypeCreateProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all product of this model.
     * @param id Order id
     */
    orderPrototypeDeleteProduct(params, options) {
        return exports.OrderApiFp.orderPrototypeDeleteProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeDestroyByIdProduct(params, options) {
        return exports.OrderApiFp.orderPrototypeDestroyByIdProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of product relation to an item by id.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeExistsProduct(params, options) {
        return exports.OrderApiFp.orderPrototypeExistsProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeFindByIdProduct(params, options) {
        return exports.OrderApiFp.orderPrototypeFindByIdProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Order id
     * @param refresh
     */
    orderPrototypeGetAccount(params, options) {
        return exports.OrderApiFp.orderPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries product of Order.
     * @param id Order id
     * @param filter
     */
    orderPrototypeGetProduct(params, options) {
        return exports.OrderApiFp.orderPrototypeGetProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     * @param data
     */
    orderPrototypeLinkProduct(params, options) {
        return exports.OrderApiFp.orderPrototypeLinkProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Order id
     * @param data An object of model property name/value pairs
     */
    orderPrototypePatchAttributes(params, options) {
        return exports.OrderApiFp.orderPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the product relation to an item by id.
     * @param id Order id
     * @param fk Foreign key for product
     */
    orderPrototypeUnlinkProduct(params, options) {
        return exports.OrderApiFp.orderPrototypeUnlinkProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for product.
     * @param id Order id
     * @param fk Foreign key for product
     * @param data
     */
    orderPrototypeUpdateByIdProduct(params, options) {
        return exports.OrderApiFp.orderPrototypeUpdateByIdProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPostOrdersidReplace(params, options) {
        return exports.OrderApiFp.orderReplaceByIdPostOrdersidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPutOrdersid(params, options) {
        return exports.OrderApiFp.orderReplaceByIdPutOrdersid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options) {
        return exports.OrderApiFp.orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePutOrders(params, options) {
        return exports.OrderApiFp.orderReplaceOrCreatePutOrders(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary statistic order by year
     * @param year year
     */
    orderStatisticByAmount(params, options) {
        return exports.OrderApiFp.orderStatisticByAmount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary statistic order by year
     * @param year year
     */
    orderStatisticByRevenue(params, options) {
        return exports.OrderApiFp.orderStatisticByRevenue(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpdateAll(params, options) {
        return exports.OrderApiFp.orderUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpsertWithWhere(params, options) {
        return exports.OrderApiFp.orderUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.OrderApi = OrderApi;
;
/**
 * OrderApi - factory interface
 */
const OrderApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary check order by account token and product
         * @param product product
         */
        orderAddToCart(params, options) {
            return exports.OrderApiFp.orderAddToCart(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        orderCount(params, options) {
            return exports.OrderApiFp.orderCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        orderCreate(params, options) {
            return exports.OrderApiFp.orderCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        orderCreateChangeStreamGetOrdersChangeStream(params, options) {
            return exports.OrderApiFp.orderCreateChangeStreamGetOrdersChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        orderCreateChangeStreamPostOrdersChangeStream(params, options) {
            return exports.OrderApiFp.orderCreateChangeStreamPostOrdersChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        orderDeleteById(params, options) {
            return exports.OrderApiFp.orderDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        orderExistsGetOrdersidExists(params, options) {
            return exports.OrderApiFp.orderExistsGetOrdersidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        orderExistsHeadOrdersid(params, options) {
            return exports.OrderApiFp.orderExistsHeadOrdersid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        orderFind(params, options) {
            return exports.OrderApiFp.orderFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        orderFindById(params, options) {
            return exports.OrderApiFp.orderFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        orderFindOne(params, options) {
            return exports.OrderApiFp.orderFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderPatchOrCreate(params, options) {
            return exports.OrderApiFp.orderPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary payment online
         * @param data information payment
         */
        orderPaymentOrder(params, options) {
            return exports.OrderApiFp.orderPaymentOrder(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts product of Order.
         * @param id Order id
         * @param where Criteria to match model instances
         */
        orderPrototypeCountProduct(params, options) {
            return exports.OrderApiFp.orderPrototypeCountProduct(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in product of this model.
         * @param id Order id
         * @param data
         */
        orderPrototypeCreateProduct(params, options) {
            return exports.OrderApiFp.orderPrototypeCreateProduct(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all product of this model.
         * @param id Order id
         */
        orderPrototypeDeleteProduct(params, options) {
            return exports.OrderApiFp.orderPrototypeDeleteProduct(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for product.
         * @param id Order id
         * @param fk Foreign key for product
         */
        orderPrototypeDestroyByIdProduct(params, options) {
            return exports.OrderApiFp.orderPrototypeDestroyByIdProduct(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of product relation to an item by id.
         * @param id Order id
         * @param fk Foreign key for product
         */
        orderPrototypeExistsProduct(params, options) {
            return exports.OrderApiFp.orderPrototypeExistsProduct(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for product.
         * @param id Order id
         * @param fk Foreign key for product
         */
        orderPrototypeFindByIdProduct(params, options) {
            return exports.OrderApiFp.orderPrototypeFindByIdProduct(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id Order id
         * @param refresh
         */
        orderPrototypeGetAccount(params, options) {
            return exports.OrderApiFp.orderPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries product of Order.
         * @param id Order id
         * @param filter
         */
        orderPrototypeGetProduct(params, options) {
            return exports.OrderApiFp.orderPrototypeGetProduct(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for product.
         * @param id Order id
         * @param fk Foreign key for product
         * @param data
         */
        orderPrototypeLinkProduct(params, options) {
            return exports.OrderApiFp.orderPrototypeLinkProduct(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Order id
         * @param data An object of model property name/value pairs
         */
        orderPrototypePatchAttributes(params, options) {
            return exports.OrderApiFp.orderPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the product relation to an item by id.
         * @param id Order id
         * @param fk Foreign key for product
         */
        orderPrototypeUnlinkProduct(params, options) {
            return exports.OrderApiFp.orderPrototypeUnlinkProduct(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for product.
         * @param id Order id
         * @param fk Foreign key for product
         * @param data
         */
        orderPrototypeUpdateByIdProduct(params, options) {
            return exports.OrderApiFp.orderPrototypeUpdateByIdProduct(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        orderReplaceByIdPostOrdersidReplace(params, options) {
            return exports.OrderApiFp.orderReplaceByIdPostOrdersidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        orderReplaceByIdPutOrdersid(params, options) {
            return exports.OrderApiFp.orderReplaceByIdPutOrdersid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options) {
            return exports.OrderApiFp.orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderReplaceOrCreatePutOrders(params, options) {
            return exports.OrderApiFp.orderReplaceOrCreatePutOrders(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary statistic order by year
         * @param year year
         */
        orderStatisticByAmount(params, options) {
            return exports.OrderApiFp.orderStatisticByAmount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary statistic order by year
         * @param year year
         */
        orderStatisticByRevenue(params, options) {
            return exports.OrderApiFp.orderStatisticByRevenue(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        orderUpdateAll(params, options) {
            return exports.OrderApiFp.orderUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        orderUpsertWithWhere(params, options) {
            return exports.OrderApiFp.orderUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.OrderApiFactory = OrderApiFactory;
/**
 * OrderProductApi - fetch parameter creator
 */
exports.OrderProductApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderProductCount(params, options) {
        const baseUrl = `/OrderProducts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderProductCreate(params, options) {
        const baseUrl = `/OrderProducts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderProductCreateChangeStreamGetOrderProductsChangeStream(params, options) {
        const baseUrl = `/OrderProducts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderProductCreateChangeStreamPostOrderProductsChangeStream(params, options) {
        const baseUrl = `/OrderProducts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderProductDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductDeleteById");
        }
        const baseUrl = `/OrderProducts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderProductExistsGetOrderProductsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductExistsGetOrderProductsidExists");
        }
        const baseUrl = `/OrderProducts/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderProductExistsHeadOrderProductsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductExistsHeadOrderProductsid");
        }
        const baseUrl = `/OrderProducts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderProductFind(params, options) {
        const baseUrl = `/OrderProducts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderProductFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductFindById");
        }
        const baseUrl = `/OrderProducts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderProductFindOne(params, options) {
        const baseUrl = `/OrderProducts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Get order product in cart by token
     * @param user userId
     */
    orderProductGetOrder(params, options) {
        // verify required parameter "user" is set
        if (params["user"] == null) {
            throw new Error("Missing required parameter user when calling orderProductGetOrder");
        }
        const baseUrl = `/OrderProducts/get-order-cart`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "user": params["user"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductPatchOrCreate(params, options) {
        const baseUrl = `/OrderProducts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation order.
     * @param id OrderProduct id
     * @param refresh
     */
    orderProductPrototypeGetOrder(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductPrototypeGetOrder");
        }
        const baseUrl = `/OrderProducts/{id}/order`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation product.
     * @param id OrderProduct id
     * @param refresh
     */
    orderProductPrototypeGetProduct(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductPrototypeGetProduct");
        }
        const baseUrl = `/OrderProducts/{id}/product`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id OrderProduct id
     * @param data An object of model property name/value pairs
     */
    orderProductPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductPrototypePatchAttributes");
        }
        const baseUrl = `/OrderProducts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderProductReplaceByIdPostOrderProductsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductReplaceByIdPostOrderProductsidReplace");
        }
        const baseUrl = `/OrderProducts/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderProductReplaceByIdPutOrderProductsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderProductReplaceByIdPutOrderProductsid");
        }
        const baseUrl = `/OrderProducts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductReplaceOrCreatePostOrderProductsReplaceOrCreate(params, options) {
        const baseUrl = `/OrderProducts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductReplaceOrCreatePutOrderProducts(params, options) {
        const baseUrl = `/OrderProducts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderProductUpdateAll(params, options) {
        const baseUrl = `/OrderProducts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderProductUpsertWithWhere(params, options) {
        const baseUrl = `/OrderProducts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * OrderProductApi - functional programming interface
 */
exports.OrderProductApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderProductCount(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderProductCreate(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderProductCreateChangeStreamGetOrderProductsChangeStream(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductCreateChangeStreamGetOrderProductsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderProductCreateChangeStreamPostOrderProductsChangeStream(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductCreateChangeStreamPostOrderProductsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderProductDeleteById(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderProductExistsGetOrderProductsidExists(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductExistsGetOrderProductsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderProductExistsHeadOrderProductsid(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductExistsHeadOrderProductsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderProductFind(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderProductFindById(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderProductFindOne(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Get order product in cart by token
     * @param user userId
     */
    orderProductGetOrder(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductGetOrder(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductPatchOrCreate(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation order.
     * @param id OrderProduct id
     * @param refresh
     */
    orderProductPrototypeGetOrder(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductPrototypeGetOrder(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation product.
     * @param id OrderProduct id
     * @param refresh
     */
    orderProductPrototypeGetProduct(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductPrototypeGetProduct(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id OrderProduct id
     * @param data An object of model property name/value pairs
     */
    orderProductPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderProductReplaceByIdPostOrderProductsidReplace(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductReplaceByIdPostOrderProductsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderProductReplaceByIdPutOrderProductsid(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductReplaceByIdPutOrderProductsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductReplaceOrCreatePostOrderProductsReplaceOrCreate(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductReplaceOrCreatePostOrderProductsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductReplaceOrCreatePutOrderProducts(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductReplaceOrCreatePutOrderProducts(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderProductUpdateAll(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderProductUpsertWithWhere(params, options) {
        const fetchArgs = exports.OrderProductApiFetchParamCreator.orderProductUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * OrderProductApi - object-oriented interface
 */
class OrderProductApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderProductCount(params, options) {
        return exports.OrderProductApiFp.orderProductCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderProductCreate(params, options) {
        return exports.OrderProductApiFp.orderProductCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderProductCreateChangeStreamGetOrderProductsChangeStream(params, options) {
        return exports.OrderProductApiFp.orderProductCreateChangeStreamGetOrderProductsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderProductCreateChangeStreamPostOrderProductsChangeStream(params, options) {
        return exports.OrderProductApiFp.orderProductCreateChangeStreamPostOrderProductsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderProductDeleteById(params, options) {
        return exports.OrderProductApiFp.orderProductDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderProductExistsGetOrderProductsidExists(params, options) {
        return exports.OrderProductApiFp.orderProductExistsGetOrderProductsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderProductExistsHeadOrderProductsid(params, options) {
        return exports.OrderProductApiFp.orderProductExistsHeadOrderProductsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderProductFind(params, options) {
        return exports.OrderProductApiFp.orderProductFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderProductFindById(params, options) {
        return exports.OrderProductApiFp.orderProductFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderProductFindOne(params, options) {
        return exports.OrderProductApiFp.orderProductFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get order product in cart by token
     * @param user userId
     */
    orderProductGetOrder(params, options) {
        return exports.OrderProductApiFp.orderProductGetOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductPatchOrCreate(params, options) {
        return exports.OrderProductApiFp.orderProductPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation order.
     * @param id OrderProduct id
     * @param refresh
     */
    orderProductPrototypeGetOrder(params, options) {
        return exports.OrderProductApiFp.orderProductPrototypeGetOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation product.
     * @param id OrderProduct id
     * @param refresh
     */
    orderProductPrototypeGetProduct(params, options) {
        return exports.OrderProductApiFp.orderProductPrototypeGetProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id OrderProduct id
     * @param data An object of model property name/value pairs
     */
    orderProductPrototypePatchAttributes(params, options) {
        return exports.OrderProductApiFp.orderProductPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderProductReplaceByIdPostOrderProductsidReplace(params, options) {
        return exports.OrderProductApiFp.orderProductReplaceByIdPostOrderProductsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderProductReplaceByIdPutOrderProductsid(params, options) {
        return exports.OrderProductApiFp.orderProductReplaceByIdPutOrderProductsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductReplaceOrCreatePostOrderProductsReplaceOrCreate(params, options) {
        return exports.OrderProductApiFp.orderProductReplaceOrCreatePostOrderProductsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderProductReplaceOrCreatePutOrderProducts(params, options) {
        return exports.OrderProductApiFp.orderProductReplaceOrCreatePutOrderProducts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderProductUpdateAll(params, options) {
        return exports.OrderProductApiFp.orderProductUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderProductUpsertWithWhere(params, options) {
        return exports.OrderProductApiFp.orderProductUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.OrderProductApi = OrderProductApi;
;
/**
 * OrderProductApi - factory interface
 */
const OrderProductApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        orderProductCount(params, options) {
            return exports.OrderProductApiFp.orderProductCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        orderProductCreate(params, options) {
            return exports.OrderProductApiFp.orderProductCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        orderProductCreateChangeStreamGetOrderProductsChangeStream(params, options) {
            return exports.OrderProductApiFp.orderProductCreateChangeStreamGetOrderProductsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        orderProductCreateChangeStreamPostOrderProductsChangeStream(params, options) {
            return exports.OrderProductApiFp.orderProductCreateChangeStreamPostOrderProductsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        orderProductDeleteById(params, options) {
            return exports.OrderProductApiFp.orderProductDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        orderProductExistsGetOrderProductsidExists(params, options) {
            return exports.OrderProductApiFp.orderProductExistsGetOrderProductsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        orderProductExistsHeadOrderProductsid(params, options) {
            return exports.OrderProductApiFp.orderProductExistsHeadOrderProductsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        orderProductFind(params, options) {
            return exports.OrderProductApiFp.orderProductFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        orderProductFindById(params, options) {
            return exports.OrderProductApiFp.orderProductFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        orderProductFindOne(params, options) {
            return exports.OrderProductApiFp.orderProductFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get order product in cart by token
         * @param user userId
         */
        orderProductGetOrder(params, options) {
            return exports.OrderProductApiFp.orderProductGetOrder(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderProductPatchOrCreate(params, options) {
            return exports.OrderProductApiFp.orderProductPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation order.
         * @param id OrderProduct id
         * @param refresh
         */
        orderProductPrototypeGetOrder(params, options) {
            return exports.OrderProductApiFp.orderProductPrototypeGetOrder(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation product.
         * @param id OrderProduct id
         * @param refresh
         */
        orderProductPrototypeGetProduct(params, options) {
            return exports.OrderProductApiFp.orderProductPrototypeGetProduct(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id OrderProduct id
         * @param data An object of model property name/value pairs
         */
        orderProductPrototypePatchAttributes(params, options) {
            return exports.OrderProductApiFp.orderProductPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        orderProductReplaceByIdPostOrderProductsidReplace(params, options) {
            return exports.OrderProductApiFp.orderProductReplaceByIdPostOrderProductsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        orderProductReplaceByIdPutOrderProductsid(params, options) {
            return exports.OrderProductApiFp.orderProductReplaceByIdPutOrderProductsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderProductReplaceOrCreatePostOrderProductsReplaceOrCreate(params, options) {
            return exports.OrderProductApiFp.orderProductReplaceOrCreatePostOrderProductsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderProductReplaceOrCreatePutOrderProducts(params, options) {
            return exports.OrderProductApiFp.orderProductReplaceOrCreatePutOrderProducts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        orderProductUpdateAll(params, options) {
            return exports.OrderProductApiFp.orderProductUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        orderProductUpsertWithWhere(params, options) {
            return exports.OrderProductApiFp.orderProductUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.OrderProductApiFactory = OrderProductApiFactory;
/**
 * ProductApi - fetch parameter creator
 */
exports.ProductApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    productCount(params, options) {
        const baseUrl = `/Products/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    productCreate(params, options) {
        const baseUrl = `/Products`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    productCreateChangeStreamGetProductsChangeStream(params, options) {
        const baseUrl = `/Products/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    productCreateChangeStreamPostProductsChangeStream(params, options) {
        const baseUrl = `/Products/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    productDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productDeleteById");
        }
        const baseUrl = `/Products/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsGetProductsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productExistsGetProductsidExists");
        }
        const baseUrl = `/Products/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsHeadProductsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productExistsHeadProductsid");
        }
        const baseUrl = `/Products/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    productFind(params, options) {
        const baseUrl = `/Products`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    productFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productFindById");
        }
        const baseUrl = `/Products/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    productFindOne(params, options) {
        const baseUrl = `/Products/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productPatchOrCreate(params, options) {
        const baseUrl = `/Products`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts order of Product.
     * @param id Product id
     * @param where Criteria to match model instances
     */
    productPrototypeCountOrder(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeCountOrder");
        }
        const baseUrl = `/Products/{id}/order/count`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in order of this model.
     * @param id Product id
     * @param data
     */
    productPrototypeCreateOrder(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeCreateOrder");
        }
        const baseUrl = `/Products/{id}/order`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all order of this model.
     * @param id Product id
     */
    productPrototypeDeleteOrder(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeDeleteOrder");
        }
        const baseUrl = `/Products/{id}/order`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeDestroyByIdOrder(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeDestroyByIdOrder");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling productPrototypeDestroyByIdOrder");
        }
        const baseUrl = `/Products/{id}/order/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of order relation to an item by id.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeExistsOrder(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeExistsOrder");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling productPrototypeExistsOrder");
        }
        const baseUrl = `/Products/{id}/order/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeFindByIdOrder(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeFindByIdOrder");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling productPrototypeFindByIdOrder");
        }
        const baseUrl = `/Products/{id}/order/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation categoryProduct.
     * @param id Product id
     * @param refresh
     */
    productPrototypeGetCategoryProduct(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeGetCategoryProduct");
        }
        const baseUrl = `/Products/{id}/categoryProduct`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries order of Product.
     * @param id Product id
     * @param filter
     */
    productPrototypeGetOrder(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeGetOrder");
        }
        const baseUrl = `/Products/{id}/order`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     * @param data
     */
    productPrototypeLinkOrder(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeLinkOrder");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling productPrototypeLinkOrder");
        }
        const baseUrl = `/Products/{id}/order/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Product id
     * @param data An object of model property name/value pairs
     */
    productPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypePatchAttributes");
        }
        const baseUrl = `/Products/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the order relation to an item by id.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeUnlinkOrder(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeUnlinkOrder");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling productPrototypeUnlinkOrder");
        }
        const baseUrl = `/Products/{id}/order/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     * @param data
     */
    productPrototypeUpdateByIdOrder(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productPrototypeUpdateByIdOrder");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling productPrototypeUpdateByIdOrder");
        }
        const baseUrl = `/Products/{id}/order/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPostProductsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productReplaceByIdPostProductsidReplace");
        }
        const baseUrl = `/Products/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPutProductsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling productReplaceByIdPutProductsid");
        }
        const baseUrl = `/Products/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePostProductsReplaceOrCreate(params, options) {
        const baseUrl = `/Products/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePutProducts(params, options) {
        const baseUrl = `/Products`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpdateAll(params, options) {
        const baseUrl = `/Products/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpsertWithWhere(params, options) {
        const baseUrl = `/Products/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * ProductApi - functional programming interface
 */
exports.ProductApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    productCount(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    productCreate(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    productCreateChangeStreamGetProductsChangeStream(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productCreateChangeStreamGetProductsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    productCreateChangeStreamPostProductsChangeStream(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productCreateChangeStreamPostProductsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    productDeleteById(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsGetProductsidExists(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productExistsGetProductsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsHeadProductsid(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productExistsHeadProductsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    productFind(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    productFindById(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    productFindOne(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productPatchOrCreate(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts order of Product.
     * @param id Product id
     * @param where Criteria to match model instances
     */
    productPrototypeCountOrder(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productPrototypeCountOrder(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in order of this model.
     * @param id Product id
     * @param data
     */
    productPrototypeCreateOrder(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productPrototypeCreateOrder(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all order of this model.
     * @param id Product id
     */
    productPrototypeDeleteOrder(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productPrototypeDeleteOrder(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeDestroyByIdOrder(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productPrototypeDestroyByIdOrder(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of order relation to an item by id.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeExistsOrder(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productPrototypeExistsOrder(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeFindByIdOrder(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productPrototypeFindByIdOrder(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation categoryProduct.
     * @param id Product id
     * @param refresh
     */
    productPrototypeGetCategoryProduct(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productPrototypeGetCategoryProduct(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries order of Product.
     * @param id Product id
     * @param filter
     */
    productPrototypeGetOrder(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productPrototypeGetOrder(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     * @param data
     */
    productPrototypeLinkOrder(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productPrototypeLinkOrder(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Product id
     * @param data An object of model property name/value pairs
     */
    productPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the order relation to an item by id.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeUnlinkOrder(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productPrototypeUnlinkOrder(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     * @param data
     */
    productPrototypeUpdateByIdOrder(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productPrototypeUpdateByIdOrder(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPostProductsidReplace(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productReplaceByIdPostProductsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPutProductsid(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productReplaceByIdPutProductsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePostProductsReplaceOrCreate(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productReplaceOrCreatePostProductsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePutProducts(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productReplaceOrCreatePutProducts(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpdateAll(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpsertWithWhere(params, options) {
        const fetchArgs = exports.ProductApiFetchParamCreator.productUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * ProductApi - object-oriented interface
 */
class ProductApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    productCount(params, options) {
        return exports.ProductApiFp.productCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    productCreate(params, options) {
        return exports.ProductApiFp.productCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    productCreateChangeStreamGetProductsChangeStream(params, options) {
        return exports.ProductApiFp.productCreateChangeStreamGetProductsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    productCreateChangeStreamPostProductsChangeStream(params, options) {
        return exports.ProductApiFp.productCreateChangeStreamPostProductsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    productDeleteById(params, options) {
        return exports.ProductApiFp.productDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsGetProductsidExists(params, options) {
        return exports.ProductApiFp.productExistsGetProductsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    productExistsHeadProductsid(params, options) {
        return exports.ProductApiFp.productExistsHeadProductsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    productFind(params, options) {
        return exports.ProductApiFp.productFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    productFindById(params, options) {
        return exports.ProductApiFp.productFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    productFindOne(params, options) {
        return exports.ProductApiFp.productFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productPatchOrCreate(params, options) {
        return exports.ProductApiFp.productPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts order of Product.
     * @param id Product id
     * @param where Criteria to match model instances
     */
    productPrototypeCountOrder(params, options) {
        return exports.ProductApiFp.productPrototypeCountOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in order of this model.
     * @param id Product id
     * @param data
     */
    productPrototypeCreateOrder(params, options) {
        return exports.ProductApiFp.productPrototypeCreateOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all order of this model.
     * @param id Product id
     */
    productPrototypeDeleteOrder(params, options) {
        return exports.ProductApiFp.productPrototypeDeleteOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeDestroyByIdOrder(params, options) {
        return exports.ProductApiFp.productPrototypeDestroyByIdOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of order relation to an item by id.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeExistsOrder(params, options) {
        return exports.ProductApiFp.productPrototypeExistsOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeFindByIdOrder(params, options) {
        return exports.ProductApiFp.productPrototypeFindByIdOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation categoryProduct.
     * @param id Product id
     * @param refresh
     */
    productPrototypeGetCategoryProduct(params, options) {
        return exports.ProductApiFp.productPrototypeGetCategoryProduct(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries order of Product.
     * @param id Product id
     * @param filter
     */
    productPrototypeGetOrder(params, options) {
        return exports.ProductApiFp.productPrototypeGetOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     * @param data
     */
    productPrototypeLinkOrder(params, options) {
        return exports.ProductApiFp.productPrototypeLinkOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Product id
     * @param data An object of model property name/value pairs
     */
    productPrototypePatchAttributes(params, options) {
        return exports.ProductApiFp.productPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the order relation to an item by id.
     * @param id Product id
     * @param fk Foreign key for order
     */
    productPrototypeUnlinkOrder(params, options) {
        return exports.ProductApiFp.productPrototypeUnlinkOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for order.
     * @param id Product id
     * @param fk Foreign key for order
     * @param data
     */
    productPrototypeUpdateByIdOrder(params, options) {
        return exports.ProductApiFp.productPrototypeUpdateByIdOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPostProductsidReplace(params, options) {
        return exports.ProductApiFp.productReplaceByIdPostProductsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    productReplaceByIdPutProductsid(params, options) {
        return exports.ProductApiFp.productReplaceByIdPutProductsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePostProductsReplaceOrCreate(params, options) {
        return exports.ProductApiFp.productReplaceOrCreatePostProductsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    productReplaceOrCreatePutProducts(params, options) {
        return exports.ProductApiFp.productReplaceOrCreatePutProducts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpdateAll(params, options) {
        return exports.ProductApiFp.productUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    productUpsertWithWhere(params, options) {
        return exports.ProductApiFp.productUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.ProductApi = ProductApi;
;
/**
 * ProductApi - factory interface
 */
const ProductApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        productCount(params, options) {
            return exports.ProductApiFp.productCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        productCreate(params, options) {
            return exports.ProductApiFp.productCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        productCreateChangeStreamGetProductsChangeStream(params, options) {
            return exports.ProductApiFp.productCreateChangeStreamGetProductsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        productCreateChangeStreamPostProductsChangeStream(params, options) {
            return exports.ProductApiFp.productCreateChangeStreamPostProductsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        productDeleteById(params, options) {
            return exports.ProductApiFp.productDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        productExistsGetProductsidExists(params, options) {
            return exports.ProductApiFp.productExistsGetProductsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        productExistsHeadProductsid(params, options) {
            return exports.ProductApiFp.productExistsHeadProductsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        productFind(params, options) {
            return exports.ProductApiFp.productFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        productFindById(params, options) {
            return exports.ProductApiFp.productFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        productFindOne(params, options) {
            return exports.ProductApiFp.productFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        productPatchOrCreate(params, options) {
            return exports.ProductApiFp.productPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts order of Product.
         * @param id Product id
         * @param where Criteria to match model instances
         */
        productPrototypeCountOrder(params, options) {
            return exports.ProductApiFp.productPrototypeCountOrder(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in order of this model.
         * @param id Product id
         * @param data
         */
        productPrototypeCreateOrder(params, options) {
            return exports.ProductApiFp.productPrototypeCreateOrder(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all order of this model.
         * @param id Product id
         */
        productPrototypeDeleteOrder(params, options) {
            return exports.ProductApiFp.productPrototypeDeleteOrder(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for order.
         * @param id Product id
         * @param fk Foreign key for order
         */
        productPrototypeDestroyByIdOrder(params, options) {
            return exports.ProductApiFp.productPrototypeDestroyByIdOrder(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of order relation to an item by id.
         * @param id Product id
         * @param fk Foreign key for order
         */
        productPrototypeExistsOrder(params, options) {
            return exports.ProductApiFp.productPrototypeExistsOrder(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for order.
         * @param id Product id
         * @param fk Foreign key for order
         */
        productPrototypeFindByIdOrder(params, options) {
            return exports.ProductApiFp.productPrototypeFindByIdOrder(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation categoryProduct.
         * @param id Product id
         * @param refresh
         */
        productPrototypeGetCategoryProduct(params, options) {
            return exports.ProductApiFp.productPrototypeGetCategoryProduct(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries order of Product.
         * @param id Product id
         * @param filter
         */
        productPrototypeGetOrder(params, options) {
            return exports.ProductApiFp.productPrototypeGetOrder(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for order.
         * @param id Product id
         * @param fk Foreign key for order
         * @param data
         */
        productPrototypeLinkOrder(params, options) {
            return exports.ProductApiFp.productPrototypeLinkOrder(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Product id
         * @param data An object of model property name/value pairs
         */
        productPrototypePatchAttributes(params, options) {
            return exports.ProductApiFp.productPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the order relation to an item by id.
         * @param id Product id
         * @param fk Foreign key for order
         */
        productPrototypeUnlinkOrder(params, options) {
            return exports.ProductApiFp.productPrototypeUnlinkOrder(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for order.
         * @param id Product id
         * @param fk Foreign key for order
         * @param data
         */
        productPrototypeUpdateByIdOrder(params, options) {
            return exports.ProductApiFp.productPrototypeUpdateByIdOrder(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        productReplaceByIdPostProductsidReplace(params, options) {
            return exports.ProductApiFp.productReplaceByIdPostProductsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        productReplaceByIdPutProductsid(params, options) {
            return exports.ProductApiFp.productReplaceByIdPutProductsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        productReplaceOrCreatePostProductsReplaceOrCreate(params, options) {
            return exports.ProductApiFp.productReplaceOrCreatePostProductsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        productReplaceOrCreatePutProducts(params, options) {
            return exports.ProductApiFp.productReplaceOrCreatePutProducts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        productUpdateAll(params, options) {
            return exports.ProductApiFp.productUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        productUpsertWithWhere(params, options) {
            return exports.ProductApiFp.productUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.ProductApiFactory = ProductApiFactory;
/**
 * TagApi - fetch parameter creator
 */
exports.TagApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    tagCount(params, options) {
        const baseUrl = `/Tags/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    tagCreate(params, options) {
        const baseUrl = `/Tags`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamGetTagsChangeStream(params, options) {
        const baseUrl = `/Tags/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamPostTagsChangeStream(params, options) {
        const baseUrl = `/Tags/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    tagDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagDeleteById");
        }
        const baseUrl = `/Tags/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsGetTagsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagExistsGetTagsidExists");
        }
        const baseUrl = `/Tags/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsHeadTagsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagExistsHeadTagsid");
        }
        const baseUrl = `/Tags/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFind(params, options) {
        const baseUrl = `/Tags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    tagFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagFindById");
        }
        const baseUrl = `/Tags/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFindOne(params, options) {
        const baseUrl = `/Tags/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagPatchOrCreate(params, options) {
        const baseUrl = `/Tags`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Tag id
     * @param data An object of model property name/value pairs
     */
    tagPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagPrototypePatchAttributes");
        }
        const baseUrl = `/Tags/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPostTagsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagReplaceByIdPostTagsidReplace");
        }
        const baseUrl = `/Tags/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPutTagsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling tagReplaceByIdPutTagsid");
        }
        const baseUrl = `/Tags/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePostTagsReplaceOrCreate(params, options) {
        const baseUrl = `/Tags/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePutTags(params, options) {
        const baseUrl = `/Tags`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpdateAll(params, options) {
        const baseUrl = `/Tags/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpsertWithWhere(params, options) {
        const baseUrl = `/Tags/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * TagApi - functional programming interface
 */
exports.TagApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    tagCount(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    tagCreate(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamGetTagsChangeStream(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagCreateChangeStreamGetTagsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamPostTagsChangeStream(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagCreateChangeStreamPostTagsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    tagDeleteById(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsGetTagsidExists(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagExistsGetTagsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsHeadTagsid(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagExistsHeadTagsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFind(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    tagFindById(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFindOne(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagPatchOrCreate(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Tag id
     * @param data An object of model property name/value pairs
     */
    tagPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPostTagsidReplace(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagReplaceByIdPostTagsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPutTagsid(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagReplaceByIdPutTagsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePostTagsReplaceOrCreate(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagReplaceOrCreatePostTagsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePutTags(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagReplaceOrCreatePutTags(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpdateAll(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpsertWithWhere(params, options) {
        const fetchArgs = exports.TagApiFetchParamCreator.tagUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * TagApi - object-oriented interface
 */
class TagApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    tagCount(params, options) {
        return exports.TagApiFp.tagCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    tagCreate(params, options) {
        return exports.TagApiFp.tagCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamGetTagsChangeStream(params, options) {
        return exports.TagApiFp.tagCreateChangeStreamGetTagsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    tagCreateChangeStreamPostTagsChangeStream(params, options) {
        return exports.TagApiFp.tagCreateChangeStreamPostTagsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    tagDeleteById(params, options) {
        return exports.TagApiFp.tagDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsGetTagsidExists(params, options) {
        return exports.TagApiFp.tagExistsGetTagsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    tagExistsHeadTagsid(params, options) {
        return exports.TagApiFp.tagExistsHeadTagsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFind(params, options) {
        return exports.TagApiFp.tagFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    tagFindById(params, options) {
        return exports.TagApiFp.tagFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    tagFindOne(params, options) {
        return exports.TagApiFp.tagFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagPatchOrCreate(params, options) {
        return exports.TagApiFp.tagPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Tag id
     * @param data An object of model property name/value pairs
     */
    tagPrototypePatchAttributes(params, options) {
        return exports.TagApiFp.tagPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPostTagsidReplace(params, options) {
        return exports.TagApiFp.tagReplaceByIdPostTagsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    tagReplaceByIdPutTagsid(params, options) {
        return exports.TagApiFp.tagReplaceByIdPutTagsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePostTagsReplaceOrCreate(params, options) {
        return exports.TagApiFp.tagReplaceOrCreatePostTagsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    tagReplaceOrCreatePutTags(params, options) {
        return exports.TagApiFp.tagReplaceOrCreatePutTags(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpdateAll(params, options) {
        return exports.TagApiFp.tagUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    tagUpsertWithWhere(params, options) {
        return exports.TagApiFp.tagUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.TagApi = TagApi;
;
/**
 * TagApi - factory interface
 */
const TagApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        tagCount(params, options) {
            return exports.TagApiFp.tagCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        tagCreate(params, options) {
            return exports.TagApiFp.tagCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        tagCreateChangeStreamGetTagsChangeStream(params, options) {
            return exports.TagApiFp.tagCreateChangeStreamGetTagsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        tagCreateChangeStreamPostTagsChangeStream(params, options) {
            return exports.TagApiFp.tagCreateChangeStreamPostTagsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        tagDeleteById(params, options) {
            return exports.TagApiFp.tagDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        tagExistsGetTagsidExists(params, options) {
            return exports.TagApiFp.tagExistsGetTagsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        tagExistsHeadTagsid(params, options) {
            return exports.TagApiFp.tagExistsHeadTagsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        tagFind(params, options) {
            return exports.TagApiFp.tagFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        tagFindById(params, options) {
            return exports.TagApiFp.tagFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        tagFindOne(params, options) {
            return exports.TagApiFp.tagFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        tagPatchOrCreate(params, options) {
            return exports.TagApiFp.tagPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Tag id
         * @param data An object of model property name/value pairs
         */
        tagPrototypePatchAttributes(params, options) {
            return exports.TagApiFp.tagPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        tagReplaceByIdPostTagsidReplace(params, options) {
            return exports.TagApiFp.tagReplaceByIdPostTagsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        tagReplaceByIdPutTagsid(params, options) {
            return exports.TagApiFp.tagReplaceByIdPutTagsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        tagReplaceOrCreatePostTagsReplaceOrCreate(params, options) {
            return exports.TagApiFp.tagReplaceOrCreatePostTagsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        tagReplaceOrCreatePutTags(params, options) {
            return exports.TagApiFp.tagReplaceOrCreatePutTags(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        tagUpdateAll(params, options) {
            return exports.TagApiFp.tagUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        tagUpsertWithWhere(params, options) {
            return exports.TagApiFp.tagUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.TagApiFactory = TagApiFactory;
//# sourceMappingURL=api.js.map