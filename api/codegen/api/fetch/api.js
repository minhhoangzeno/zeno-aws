"use strict";
/**
 * api
 * plan-de-transport-api
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamApiFactory = exports.TeamApi = exports.TeamApiFp = exports.TeamApiFetchParamCreator = exports.TargetApiFactory = exports.TargetApi = exports.TargetApiFp = exports.TargetApiFetchParamCreator = exports.OrderApiFactory = exports.OrderApi = exports.OrderApiFp = exports.OrderApiFetchParamCreator = exports.DurationTimeApiFactory = exports.DurationTimeApi = exports.DurationTimeApiFp = exports.DurationTimeApiFetchParamCreator = exports.ContainerApiFactory = exports.ContainerApi = exports.ContainerApiFp = exports.ContainerApiFetchParamCreator = exports.AccountTokenApiFactory = exports.AccountTokenApi = exports.AccountTokenApiFp = exports.AccountTokenApiFetchParamCreator = exports.AccountApiFactory = exports.AccountApi = exports.AccountApiFp = exports.AccountApiFetchParamCreator = exports.BaseAPI = void 0;
const querystring = require("querystring");
const url = require("url");
const isomorphicFetch = require("isomorphic-fetch");
const assign = require("core-js/library/fn/object/assign");
const BASE_PATH = "https://localhost/api".replace(/\/+$/, "");
class BaseAPI {
    basePath;
    fetch;
    constructor(fetch = isomorphicFetch, basePath = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 * AccountApi - fetch parameter creator
 */
exports.AccountApiFetchParamCreator = {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    accountChangePassword(params, options) {
        // verify required parameter "oldPassword" is set
        if (params["oldPassword"] == null) {
            throw new Error("Missing required parameter oldPassword when calling accountChangePassword");
        }
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountChangePassword");
        }
        const baseUrl = `/Accounts/change-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "oldPassword": params["oldPassword"],
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Change role of user
     * @param data context of request
     */
    accountChangeRole(params, options) {
        // verify required parameter "data" is set
        if (params["data"] == null) {
            throw new Error("Missing required parameter data when calling accountChangeRole");
        }
        const baseUrl = `/Accounts/change-role`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "data": params["data"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    accountConfirm(params, options) {
        // verify required parameter "uid" is set
        if (params["uid"] == null) {
            throw new Error("Missing required parameter uid when calling accountConfirm");
        }
        // verify required parameter "token" is set
        if (params["token"] == null) {
            throw new Error("Missing required parameter token when calling accountConfirm");
        }
        const baseUrl = `/Accounts/confirm`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "uid": params["uid"],
            "token": params["token"],
            "redirect": params["redirect"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params, options) {
        const baseUrl = `/Accounts/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamGetAccountsChangeStream(params, options) {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamPostAccountsChangeStream(params, options) {
        const baseUrl = `/Accounts/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountDeleteById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsGetAccountsidExists");
        }
        const baseUrl = `/Accounts/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountExistsHeadAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountFindById");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find user no team
     */
    accountFindNoTeam(options) {
        const baseUrl = `/Accounts/no-team`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params, options) {
        const baseUrl = `/Accounts/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Get account by token
     */
    accountGetMe(options) {
        const baseUrl = `/Accounts/get-me`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params, options) {
        // verify required parameter "credentials" is set
        if (params["credentials"] == null) {
            throw new Error("Missing required parameter credentials when calling accountLogin");
        }
        const baseUrl = `/Accounts/login`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "include": params["include"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["credentials"]) {
            fetchOptions.body = JSON.stringify(params["credentials"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Logout a user with access token.
     */
    accountLogout(options) {
        const baseUrl = `/Accounts/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/count`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCountRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/count`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeCreateRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDeleteRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeDestroyByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeDestroyByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeExistsRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeExistsRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeFindByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeFindByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetRoles");
        }
        const baseUrl = `/Accounts/{id}/roles`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation team.
     * @param id Account id
     * @param refresh
     */
    accountPrototypeGetTeam(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeGetTeam");
        }
        const baseUrl = `/Accounts/{id}/team`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeLinkRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeLinkRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeLinkRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypePatchAttributes");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUnlinkRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUnlinkRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/rel/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    accountPrototypeUpdateByIdAccessTokens(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdAccessTokens");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdAccessTokens");
        }
        const baseUrl = `/Accounts/{id}/accessTokens/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeUpdateByIdRoles(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeUpdateByIdRoles");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling accountPrototypeUpdateByIdRoles");
        }
        const baseUrl = `/Accounts/{id}/roles/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountPrototypeVerify");
        }
        const baseUrl = `/Accounts/{id}/verify`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPostAccountsidReplace");
        }
        const baseUrl = `/Accounts/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountReplaceByIdPutAccountsid");
        }
        const baseUrl = `/Accounts/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
        const baseUrl = `/Accounts/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params, options) {
        const baseUrl = `/Accounts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    accountResetPassword(params, options) {
        // verify required parameter "options" is set
        if (params["options"] == null) {
            throw new Error("Missing required parameter options when calling accountResetPassword");
        }
        const baseUrl = `/Accounts/reset`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    accountSetPassword(params, options) {
        // verify required parameter "newPassword" is set
        if (params["newPassword"] == null) {
            throw new Error("Missing required parameter newPassword when calling accountSetPassword");
        }
        const baseUrl = `/Accounts/reset-password`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "newPassword": params["newPassword"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params, options) {
        const baseUrl = `/Accounts/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params, options) {
        const baseUrl = `/Accounts/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * AccountApi - functional programming interface
 */
exports.AccountApiFp = {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    accountChangePassword(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountChangePassword(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Change role of user
     * @param data context of request
     */
    accountChangeRole(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountChangeRole(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    accountConfirm(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountConfirm(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamGetAccountsChangeStream(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCreateChangeStreamGetAccountsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamPostAccountsChangeStream(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountCreateChangeStreamPostAccountsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountExistsGetAccountsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountExistsHeadAccountsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find user no team
     */
    accountFindNoTeam(options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountFindNoTeam(options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Get account by token
     */
    accountGetMe(options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountGetMe(options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountLogin(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Logout a user with access token.
     */
    accountLogout(options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountLogout(options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCountRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeCreateRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDeleteRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeDestroyByIdRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeExistsRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeFindByIdRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation team.
     * @param id Account id
     * @param refresh
     */
    accountPrototypeGetTeam(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeGetTeam(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeLinkRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeLinkRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUnlinkRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    accountPrototypeUpdateByIdAccessTokens(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdAccessTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeUpdateByIdRoles(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeUpdateByIdRoles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountPrototypeVerify(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceByIdPostAccountsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceByIdPutAccountsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountReplaceOrCreatePutAccounts(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    accountResetPassword(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountResetPassword(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    accountSetPassword(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountSetPassword(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params, options) {
        const fetchArgs = exports.AccountApiFetchParamCreator.accountUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * AccountApi - object-oriented interface
 */
class AccountApi extends BaseAPI {
    /**
     *
     * @summary Change a user's password.
     * @param oldPassword
     * @param newPassword
     */
    accountChangePassword(params, options) {
        return exports.AccountApiFp.accountChangePassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Change role of user
     * @param data context of request
     */
    accountChangeRole(params, options) {
        return exports.AccountApiFp.accountChangeRole(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Confirm a user registration with identity verification token.
     * @param uid
     * @param token
     * @param redirect
     */
    accountConfirm(params, options) {
        return exports.AccountApiFp.accountConfirm(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountCount(params, options) {
        return exports.AccountApiFp.accountCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountCreate(params, options) {
        return exports.AccountApiFp.accountCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamGetAccountsChangeStream(params, options) {
        return exports.AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountCreateChangeStreamPostAccountsChangeStream(params, options) {
        return exports.AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountDeleteById(params, options) {
        return exports.AccountApiFp.accountDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsGetAccountsidExists(params, options) {
        return exports.AccountApiFp.accountExistsGetAccountsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountExistsHeadAccountsid(params, options) {
        return exports.AccountApiFp.accountExistsHeadAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFind(params, options) {
        return exports.AccountApiFp.accountFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountFindById(params, options) {
        return exports.AccountApiFp.accountFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find user no team
     */
    accountFindNoTeam(options) {
        return exports.AccountApiFp.accountFindNoTeam(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountFindOne(params, options) {
        return exports.AccountApiFp.accountFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Get account by token
     */
    accountGetMe(options) {
        return exports.AccountApiFp.accountGetMe(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Login a user with username/email and password.
     * @param credentials
     * @param include Related objects to include in the response. See the description of return value for more details.
     */
    accountLogin(params, options) {
        return exports.AccountApiFp.accountLogin(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Logout a user with access token.
     */
    accountLogout(options) {
        return exports.AccountApiFp.accountLogout(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountPatchOrCreate(params, options) {
        return exports.AccountApiFp.accountPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts accessTokens of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeCountAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts roles of Account.
     * @param id Account id
     * @param where Criteria to match model instances
     */
    accountPrototypeCountRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeCountRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in accessTokens of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in roles of this model.
     * @param id Account id
     * @param data
     */
    accountPrototypeCreateRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeCreateRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all accessTokens of this model.
     * @param id Account id
     */
    accountPrototypeDeleteAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all roles of this model.
     * @param id Account id
     */
    accountPrototypeDeleteRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeDeleteRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeDestroyByIdAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeDestroyByIdRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check the existence of roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeExistsRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeExistsRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     */
    accountPrototypeFindByIdAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeFindByIdRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeFindByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries accessTokens of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeGetAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries roles of Account.
     * @param id Account id
     * @param filter
     */
    accountPrototypeGetRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeGetRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation team.
     * @param id Account id
     * @param refresh
     */
    accountPrototypeGetTeam(params, options) {
        return exports.AccountApiFp.accountPrototypeGetTeam(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Add a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeLinkRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeLinkRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Account id
     * @param data An object of model property name/value pairs
     */
    accountPrototypePatchAttributes(params, options) {
        return exports.AccountApiFp.accountPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Remove the roles relation to an item by id.
     * @param id Account id
     * @param fk Foreign key for roles
     */
    accountPrototypeUnlinkRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeUnlinkRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for accessTokens.
     * @param id Account id
     * @param fk Foreign key for accessTokens
     * @param data
     */
    accountPrototypeUpdateByIdAccessTokens(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for roles.
     * @param id Account id
     * @param fk Foreign key for roles
     * @param data
     */
    accountPrototypeUpdateByIdRoles(params, options) {
        return exports.AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Trigger user's identity verification with configured verifyOptions
     * @param id Account id
     */
    accountPrototypeVerify(params, options) {
        return exports.AccountApiFp.accountPrototypeVerify(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPostAccountsidReplace(params, options) {
        return exports.AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountReplaceByIdPutAccountsid(params, options) {
        return exports.AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
        return exports.AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountReplaceOrCreatePutAccounts(params, options) {
        return exports.AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Reset password for a user with email.
     * @param options
     */
    accountResetPassword(params, options) {
        return exports.AccountApiFp.accountResetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Reset user's password via a password-reset token.
     * @param newPassword
     */
    accountSetPassword(params, options) {
        return exports.AccountApiFp.accountSetPassword(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpdateAll(params, options) {
        return exports.AccountApiFp.accountUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountUpsertWithWhere(params, options) {
        return exports.AccountApiFp.accountUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.AccountApi = AccountApi;
;
/**
 * AccountApi - factory interface
 */
const AccountApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Change a user's password.
         * @param oldPassword
         * @param newPassword
         */
        accountChangePassword(params, options) {
            return exports.AccountApiFp.accountChangePassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Change role of user
         * @param data context of request
         */
        accountChangeRole(params, options) {
            return exports.AccountApiFp.accountChangeRole(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Confirm a user registration with identity verification token.
         * @param uid
         * @param token
         * @param redirect
         */
        accountConfirm(params, options) {
            return exports.AccountApiFp.accountConfirm(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountCount(params, options) {
            return exports.AccountApiFp.accountCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountCreate(params, options) {
            return exports.AccountApiFp.accountCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountCreateChangeStreamGetAccountsChangeStream(params, options) {
            return exports.AccountApiFp.accountCreateChangeStreamGetAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountCreateChangeStreamPostAccountsChangeStream(params, options) {
            return exports.AccountApiFp.accountCreateChangeStreamPostAccountsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountDeleteById(params, options) {
            return exports.AccountApiFp.accountDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsGetAccountsidExists(params, options) {
            return exports.AccountApiFp.accountExistsGetAccountsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountExistsHeadAccountsid(params, options) {
            return exports.AccountApiFp.accountExistsHeadAccountsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFind(params, options) {
            return exports.AccountApiFp.accountFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountFindById(params, options) {
            return exports.AccountApiFp.accountFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find user no team
         */
        accountFindNoTeam(options) {
            return exports.AccountApiFp.accountFindNoTeam(options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountFindOne(params, options) {
            return exports.AccountApiFp.accountFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Get account by token
         */
        accountGetMe(options) {
            return exports.AccountApiFp.accountGetMe(options)(fetch, basePath);
        },
        /**
         *
         * @summary Login a user with username/email and password.
         * @param credentials
         * @param include Related objects to include in the response. See the description of return value for more details.
         */
        accountLogin(params, options) {
            return exports.AccountApiFp.accountLogin(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Logout a user with access token.
         */
        accountLogout(options) {
            return exports.AccountApiFp.accountLogout(options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountPatchOrCreate(params, options) {
            return exports.AccountApiFp.accountPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts accessTokens of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeCountAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts roles of Account.
         * @param id Account id
         * @param where Criteria to match model instances
         */
        accountPrototypeCountRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeCountRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in accessTokens of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in roles of this model.
         * @param id Account id
         * @param data
         */
        accountPrototypeCreateRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeCreateRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all accessTokens of this model.
         * @param id Account id
         */
        accountPrototypeDeleteAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all roles of this model.
         * @param id Account id
         */
        accountPrototypeDeleteRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeDeleteRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeDestroyByIdAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeDestroyByIdRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeDestroyByIdRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check the existence of roles relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeExistsRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeExistsRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         */
        accountPrototypeFindByIdAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeFindByIdRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeFindByIdRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries accessTokens of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeGetAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries roles of Account.
         * @param id Account id
         * @param filter
         */
        accountPrototypeGetRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeGetRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation team.
         * @param id Account id
         * @param refresh
         */
        accountPrototypeGetTeam(params, options) {
            return exports.AccountApiFp.accountPrototypeGetTeam(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Add a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         * @param data
         */
        accountPrototypeLinkRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeLinkRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Account id
         * @param data An object of model property name/value pairs
         */
        accountPrototypePatchAttributes(params, options) {
            return exports.AccountApiFp.accountPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Remove the roles relation to an item by id.
         * @param id Account id
         * @param fk Foreign key for roles
         */
        accountPrototypeUnlinkRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeUnlinkRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for accessTokens.
         * @param id Account id
         * @param fk Foreign key for accessTokens
         * @param data
         */
        accountPrototypeUpdateByIdAccessTokens(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdAccessTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for roles.
         * @param id Account id
         * @param fk Foreign key for roles
         * @param data
         */
        accountPrototypeUpdateByIdRoles(params, options) {
            return exports.AccountApiFp.accountPrototypeUpdateByIdRoles(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Trigger user's identity verification with configured verifyOptions
         * @param id Account id
         */
        accountPrototypeVerify(params, options) {
            return exports.AccountApiFp.accountPrototypeVerify(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPostAccountsidReplace(params, options) {
            return exports.AccountApiFp.accountReplaceByIdPostAccountsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountReplaceByIdPutAccountsid(params, options) {
            return exports.AccountApiFp.accountReplaceByIdPutAccountsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options) {
            return exports.AccountApiFp.accountReplaceOrCreatePostAccountsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountReplaceOrCreatePutAccounts(params, options) {
            return exports.AccountApiFp.accountReplaceOrCreatePutAccounts(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Reset password for a user with email.
         * @param options
         */
        accountResetPassword(params, options) {
            return exports.AccountApiFp.accountResetPassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Reset user's password via a password-reset token.
         * @param newPassword
         */
        accountSetPassword(params, options) {
            return exports.AccountApiFp.accountSetPassword(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpdateAll(params, options) {
            return exports.AccountApiFp.accountUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountUpsertWithWhere(params, options) {
            return exports.AccountApiFp.accountUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.AccountApiFactory = AccountApiFactory;
/**
 * AccountTokenApi - fetch parameter creator
 */
exports.AccountTokenApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params, options) {
        const baseUrl = `/AccountTokens/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params, options) {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options) {
        const baseUrl = `/AccountTokens/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options) {
        const baseUrl = `/AccountTokens/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenDeleteById");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenExistsGetAccountTokensidExists");
        }
        const baseUrl = `/AccountTokens/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenExistsHeadAccountTokensid");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params, options) {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenFindById");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params, options) {
        const baseUrl = `/AccountTokens/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params, options) {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh
     */
    accountTokenPrototypeGetUser(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenPrototypeGetUser");
        }
        const baseUrl = `/AccountTokens/{id}/user`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenPrototypePatchAttributes");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenReplaceByIdPostAccountTokensidReplace");
        }
        const baseUrl = `/AccountTokens/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling accountTokenReplaceByIdPutAccountTokensid");
        }
        const baseUrl = `/AccountTokens/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options) {
        const baseUrl = `/AccountTokens/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params, options) {
        const baseUrl = `/AccountTokens`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params, options) {
        const baseUrl = `/AccountTokens/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params, options) {
        const baseUrl = `/AccountTokens/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * AccountTokenApi - functional programming interface
 */
exports.AccountTokenApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenExistsGetAccountTokensidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenExistsHeadAccountTokensid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh
     */
    accountTokenPrototypeGetUser(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenPrototypeGetUser(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenReplaceByIdPostAccountTokensidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenReplaceByIdPutAccountTokensid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenReplaceOrCreatePutAccountTokens(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params, options) {
        const fetchArgs = exports.AccountTokenApiFetchParamCreator.accountTokenUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * AccountTokenApi - object-oriented interface
 */
class AccountTokenApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    accountTokenCount(params, options) {
        return exports.AccountTokenApiFp.accountTokenCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    accountTokenCreate(params, options) {
        return exports.AccountTokenApiFp.accountTokenCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options) {
        return exports.AccountTokenApiFp.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options) {
        return exports.AccountTokenApiFp.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    accountTokenDeleteById(params, options) {
        return exports.AccountTokenApiFp.accountTokenDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsGetAccountTokensidExists(params, options) {
        return exports.AccountTokenApiFp.accountTokenExistsGetAccountTokensidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    accountTokenExistsHeadAccountTokensid(params, options) {
        return exports.AccountTokenApiFp.accountTokenExistsHeadAccountTokensid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFind(params, options) {
        return exports.AccountTokenApiFp.accountTokenFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    accountTokenFindById(params, options) {
        return exports.AccountTokenApiFp.accountTokenFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    accountTokenFindOne(params, options) {
        return exports.AccountTokenApiFp.accountTokenFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenPatchOrCreate(params, options) {
        return exports.AccountTokenApiFp.accountTokenPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation user.
     * @param id AccountToken id
     * @param refresh
     */
    accountTokenPrototypeGetUser(params, options) {
        return exports.AccountTokenApiFp.accountTokenPrototypeGetUser(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id AccountToken id
     * @param data An object of model property name/value pairs
     */
    accountTokenPrototypePatchAttributes(params, options) {
        return exports.AccountTokenApiFp.accountTokenPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPostAccountTokensidReplace(params, options) {
        return exports.AccountTokenApiFp.accountTokenReplaceByIdPostAccountTokensidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    accountTokenReplaceByIdPutAccountTokensid(params, options) {
        return exports.AccountTokenApiFp.accountTokenReplaceByIdPutAccountTokensid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options) {
        return exports.AccountTokenApiFp.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    accountTokenReplaceOrCreatePutAccountTokens(params, options) {
        return exports.AccountTokenApiFp.accountTokenReplaceOrCreatePutAccountTokens(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpdateAll(params, options) {
        return exports.AccountTokenApiFp.accountTokenUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    accountTokenUpsertWithWhere(params, options) {
        return exports.AccountTokenApiFp.accountTokenUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.AccountTokenApi = AccountTokenApi;
;
/**
 * AccountTokenApi - factory interface
 */
const AccountTokenApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        accountTokenCount(params, options) {
            return exports.AccountTokenApiFp.accountTokenCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        accountTokenCreate(params, options) {
            return exports.AccountTokenApiFp.accountTokenCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options) {
            return exports.AccountTokenApiFp.accountTokenCreateChangeStreamGetAccountTokensChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options) {
            return exports.AccountTokenApiFp.accountTokenCreateChangeStreamPostAccountTokensChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        accountTokenDeleteById(params, options) {
            return exports.AccountTokenApiFp.accountTokenDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountTokenExistsGetAccountTokensidExists(params, options) {
            return exports.AccountTokenApiFp.accountTokenExistsGetAccountTokensidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        accountTokenExistsHeadAccountTokensid(params, options) {
            return exports.AccountTokenApiFp.accountTokenExistsHeadAccountTokensid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountTokenFind(params, options) {
            return exports.AccountTokenApiFp.accountTokenFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        accountTokenFindById(params, options) {
            return exports.AccountTokenApiFp.accountTokenFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        accountTokenFindOne(params, options) {
            return exports.AccountTokenApiFp.accountTokenFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenPatchOrCreate(params, options) {
            return exports.AccountTokenApiFp.accountTokenPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation user.
         * @param id AccountToken id
         * @param refresh
         */
        accountTokenPrototypeGetUser(params, options) {
            return exports.AccountTokenApiFp.accountTokenPrototypeGetUser(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id AccountToken id
         * @param data An object of model property name/value pairs
         */
        accountTokenPrototypePatchAttributes(params, options) {
            return exports.AccountTokenApiFp.accountTokenPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountTokenReplaceByIdPostAccountTokensidReplace(params, options) {
            return exports.AccountTokenApiFp.accountTokenReplaceByIdPostAccountTokensidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        accountTokenReplaceByIdPutAccountTokensid(params, options) {
            return exports.AccountTokenApiFp.accountTokenReplaceByIdPutAccountTokensid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options) {
            return exports.AccountTokenApiFp.accountTokenReplaceOrCreatePostAccountTokensReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        accountTokenReplaceOrCreatePutAccountTokens(params, options) {
            return exports.AccountTokenApiFp.accountTokenReplaceOrCreatePutAccountTokens(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountTokenUpdateAll(params, options) {
            return exports.AccountTokenApiFp.accountTokenUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        accountTokenUpsertWithWhere(params, options) {
            return exports.AccountTokenApiFp.accountTokenUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.AccountTokenApiFactory = AccountTokenApiFactory;
/**
 * ContainerApi - fetch parameter creator
 */
exports.ContainerApiFetchParamCreator = {
    /**
     *
     * @param options
     */
    containerCreateContainer(params, options) {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["options"]) {
            fetchOptions.body = JSON.stringify(params["options"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     */
    containerDestroyContainer(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerDestroyContainer");
        }
        const baseUrl = `/Containers/{container}`
            .replace(`{${"container"}}`, `${params["container"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerDownload(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerDownload");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerDownload");
        }
        const baseUrl = `/Containers/{container}/download/{file}`
            .replace(`{${"container"}}`, `${params["container"]}`)
            .replace(`{${"file"}}`, `${params["file"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     */
    containerGetContainer(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetContainer");
        }
        const baseUrl = `/Containers/{container}`
            .replace(`{${"container"}}`, `${params["container"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     */
    containerGetContainers(options) {
        const baseUrl = `/Containers`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerGetFile(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetFile");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerGetFile");
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${"container"}}`, `${params["container"]}`)
            .replace(`{${"file"}}`, `${params["file"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     */
    containerGetFiles(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerGetFiles");
        }
        const baseUrl = `/Containers/{container}/files`
            .replace(`{${"container"}}`, `${params["container"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerRemoveFile(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerRemoveFile");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling containerRemoveFile");
        }
        const baseUrl = `/Containers/{container}/files/{file}`
            .replace(`{${"container"}}`, `${params["container"]}`)
            .replace(`{${"file"}}`, `${params["file"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @param container
     */
    containerUpload(params, options) {
        // verify required parameter "container" is set
        if (params["container"] == null) {
            throw new Error("Missing required parameter container when calling containerUpload");
        }
        const baseUrl = `/Containers/{container}/upload`
            .replace(`{${"container"}}`, `${params["container"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * ContainerApi - functional programming interface
 */
exports.ContainerApiFp = {
    /**
     *
     * @param options
     */
    containerCreateContainer(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerCreateContainer(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     */
    containerDestroyContainer(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerDestroyContainer(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerDownload(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerDownload(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     */
    containerGetContainer(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerGetContainer(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     */
    containerGetContainers(options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerGetContainers(options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerGetFile(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerGetFile(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     */
    containerGetFiles(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerGetFiles(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     * @param file
     */
    containerRemoveFile(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerRemoveFile(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @param container
     */
    containerUpload(params, options) {
        const fetchArgs = exports.ContainerApiFetchParamCreator.containerUpload(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * ContainerApi - object-oriented interface
 */
class ContainerApi extends BaseAPI {
    /**
     *
     * @param options
     */
    containerCreateContainer(params, options) {
        return exports.ContainerApiFp.containerCreateContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     */
    containerDestroyContainer(params, options) {
        return exports.ContainerApiFp.containerDestroyContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     * @param file
     */
    containerDownload(params, options) {
        return exports.ContainerApiFp.containerDownload(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     */
    containerGetContainer(params, options) {
        return exports.ContainerApiFp.containerGetContainer(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     */
    containerGetContainers(options) {
        return exports.ContainerApiFp.containerGetContainers(options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     * @param file
     */
    containerGetFile(params, options) {
        return exports.ContainerApiFp.containerGetFile(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     */
    containerGetFiles(params, options) {
        return exports.ContainerApiFp.containerGetFiles(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     * @param file
     */
    containerRemoveFile(params, options) {
        return exports.ContainerApiFp.containerRemoveFile(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @param container
     */
    containerUpload(params, options) {
        return exports.ContainerApiFp.containerUpload(params, options)(this.fetch, this.basePath);
    }
}
exports.ContainerApi = ContainerApi;
;
/**
 * ContainerApi - factory interface
 */
const ContainerApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @param options
         */
        containerCreateContainer(params, options) {
            return exports.ContainerApiFp.containerCreateContainer(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         */
        containerDestroyContainer(params, options) {
            return exports.ContainerApiFp.containerDestroyContainer(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         * @param file
         */
        containerDownload(params, options) {
            return exports.ContainerApiFp.containerDownload(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         */
        containerGetContainer(params, options) {
            return exports.ContainerApiFp.containerGetContainer(params, options)(fetch, basePath);
        },
        /**
         *
         */
        containerGetContainers(options) {
            return exports.ContainerApiFp.containerGetContainers(options)(fetch, basePath);
        },
        /**
         *
         * @param container
         * @param file
         */
        containerGetFile(params, options) {
            return exports.ContainerApiFp.containerGetFile(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         */
        containerGetFiles(params, options) {
            return exports.ContainerApiFp.containerGetFiles(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         * @param file
         */
        containerRemoveFile(params, options) {
            return exports.ContainerApiFp.containerRemoveFile(params, options)(fetch, basePath);
        },
        /**
         *
         * @param container
         */
        containerUpload(params, options) {
            return exports.ContainerApiFp.containerUpload(params, options)(fetch, basePath);
        },
    };
};
exports.ContainerApiFactory = ContainerApiFactory;
/**
 * DurationTimeApi - fetch parameter creator
 */
exports.DurationTimeApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    durationTimeCount(params, options) {
        const baseUrl = `/DurationTimes/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    durationTimeCreate(params, options) {
        const baseUrl = `/DurationTimes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    durationTimeCreateChangeStreamGetDurationTimesChangeStream(params, options) {
        const baseUrl = `/DurationTimes/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    durationTimeCreateChangeStreamPostDurationTimesChangeStream(params, options) {
        const baseUrl = `/DurationTimes/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    durationTimeDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling durationTimeDeleteById");
        }
        const baseUrl = `/DurationTimes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    durationTimeExistsGetDurationTimesidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling durationTimeExistsGetDurationTimesidExists");
        }
        const baseUrl = `/DurationTimes/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    durationTimeExistsHeadDurationTimesid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling durationTimeExistsHeadDurationTimesid");
        }
        const baseUrl = `/DurationTimes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    durationTimeFind(params, options) {
        const baseUrl = `/DurationTimes`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    durationTimeFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling durationTimeFindById");
        }
        const baseUrl = `/DurationTimes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    durationTimeFindOne(params, options) {
        const baseUrl = `/DurationTimes/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimePatchOrCreate(params, options) {
        const baseUrl = `/DurationTimes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation leader.
     * @param id DurationTime id
     * @param refresh
     */
    durationTimePrototypeGetLeader(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling durationTimePrototypeGetLeader");
        }
        const baseUrl = `/DurationTimes/{id}/leader`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id DurationTime id
     * @param data An object of model property name/value pairs
     */
    durationTimePrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling durationTimePrototypePatchAttributes");
        }
        const baseUrl = `/DurationTimes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    durationTimeReplaceByIdPostDurationTimesidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling durationTimeReplaceByIdPostDurationTimesidReplace");
        }
        const baseUrl = `/DurationTimes/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    durationTimeReplaceByIdPutDurationTimesid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling durationTimeReplaceByIdPutDurationTimesid");
        }
        const baseUrl = `/DurationTimes/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimeReplaceOrCreatePostDurationTimesReplaceOrCreate(params, options) {
        const baseUrl = `/DurationTimes/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimeReplaceOrCreatePutDurationTimes(params, options) {
        const baseUrl = `/DurationTimes`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    durationTimeUpdateAll(params, options) {
        const baseUrl = `/DurationTimes/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    durationTimeUpsertWithWhere(params, options) {
        const baseUrl = `/DurationTimes/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * DurationTimeApi - functional programming interface
 */
exports.DurationTimeApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    durationTimeCount(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimeCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    durationTimeCreate(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimeCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    durationTimeCreateChangeStreamGetDurationTimesChangeStream(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimeCreateChangeStreamGetDurationTimesChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    durationTimeCreateChangeStreamPostDurationTimesChangeStream(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimeCreateChangeStreamPostDurationTimesChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    durationTimeDeleteById(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimeDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    durationTimeExistsGetDurationTimesidExists(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimeExistsGetDurationTimesidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    durationTimeExistsHeadDurationTimesid(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimeExistsHeadDurationTimesid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    durationTimeFind(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimeFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    durationTimeFindById(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimeFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    durationTimeFindOne(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimeFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimePatchOrCreate(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimePatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation leader.
     * @param id DurationTime id
     * @param refresh
     */
    durationTimePrototypeGetLeader(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimePrototypeGetLeader(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id DurationTime id
     * @param data An object of model property name/value pairs
     */
    durationTimePrototypePatchAttributes(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimePrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    durationTimeReplaceByIdPostDurationTimesidReplace(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimeReplaceByIdPostDurationTimesidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    durationTimeReplaceByIdPutDurationTimesid(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimeReplaceByIdPutDurationTimesid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimeReplaceOrCreatePostDurationTimesReplaceOrCreate(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimeReplaceOrCreatePostDurationTimesReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimeReplaceOrCreatePutDurationTimes(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimeReplaceOrCreatePutDurationTimes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    durationTimeUpdateAll(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimeUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    durationTimeUpsertWithWhere(params, options) {
        const fetchArgs = exports.DurationTimeApiFetchParamCreator.durationTimeUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * DurationTimeApi - object-oriented interface
 */
class DurationTimeApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    durationTimeCount(params, options) {
        return exports.DurationTimeApiFp.durationTimeCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    durationTimeCreate(params, options) {
        return exports.DurationTimeApiFp.durationTimeCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    durationTimeCreateChangeStreamGetDurationTimesChangeStream(params, options) {
        return exports.DurationTimeApiFp.durationTimeCreateChangeStreamGetDurationTimesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    durationTimeCreateChangeStreamPostDurationTimesChangeStream(params, options) {
        return exports.DurationTimeApiFp.durationTimeCreateChangeStreamPostDurationTimesChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    durationTimeDeleteById(params, options) {
        return exports.DurationTimeApiFp.durationTimeDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    durationTimeExistsGetDurationTimesidExists(params, options) {
        return exports.DurationTimeApiFp.durationTimeExistsGetDurationTimesidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    durationTimeExistsHeadDurationTimesid(params, options) {
        return exports.DurationTimeApiFp.durationTimeExistsHeadDurationTimesid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    durationTimeFind(params, options) {
        return exports.DurationTimeApiFp.durationTimeFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    durationTimeFindById(params, options) {
        return exports.DurationTimeApiFp.durationTimeFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    durationTimeFindOne(params, options) {
        return exports.DurationTimeApiFp.durationTimeFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimePatchOrCreate(params, options) {
        return exports.DurationTimeApiFp.durationTimePatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation leader.
     * @param id DurationTime id
     * @param refresh
     */
    durationTimePrototypeGetLeader(params, options) {
        return exports.DurationTimeApiFp.durationTimePrototypeGetLeader(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id DurationTime id
     * @param data An object of model property name/value pairs
     */
    durationTimePrototypePatchAttributes(params, options) {
        return exports.DurationTimeApiFp.durationTimePrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    durationTimeReplaceByIdPostDurationTimesidReplace(params, options) {
        return exports.DurationTimeApiFp.durationTimeReplaceByIdPostDurationTimesidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    durationTimeReplaceByIdPutDurationTimesid(params, options) {
        return exports.DurationTimeApiFp.durationTimeReplaceByIdPutDurationTimesid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimeReplaceOrCreatePostDurationTimesReplaceOrCreate(params, options) {
        return exports.DurationTimeApiFp.durationTimeReplaceOrCreatePostDurationTimesReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    durationTimeReplaceOrCreatePutDurationTimes(params, options) {
        return exports.DurationTimeApiFp.durationTimeReplaceOrCreatePutDurationTimes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    durationTimeUpdateAll(params, options) {
        return exports.DurationTimeApiFp.durationTimeUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    durationTimeUpsertWithWhere(params, options) {
        return exports.DurationTimeApiFp.durationTimeUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.DurationTimeApi = DurationTimeApi;
;
/**
 * DurationTimeApi - factory interface
 */
const DurationTimeApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        durationTimeCount(params, options) {
            return exports.DurationTimeApiFp.durationTimeCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        durationTimeCreate(params, options) {
            return exports.DurationTimeApiFp.durationTimeCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        durationTimeCreateChangeStreamGetDurationTimesChangeStream(params, options) {
            return exports.DurationTimeApiFp.durationTimeCreateChangeStreamGetDurationTimesChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        durationTimeCreateChangeStreamPostDurationTimesChangeStream(params, options) {
            return exports.DurationTimeApiFp.durationTimeCreateChangeStreamPostDurationTimesChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        durationTimeDeleteById(params, options) {
            return exports.DurationTimeApiFp.durationTimeDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        durationTimeExistsGetDurationTimesidExists(params, options) {
            return exports.DurationTimeApiFp.durationTimeExistsGetDurationTimesidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        durationTimeExistsHeadDurationTimesid(params, options) {
            return exports.DurationTimeApiFp.durationTimeExistsHeadDurationTimesid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        durationTimeFind(params, options) {
            return exports.DurationTimeApiFp.durationTimeFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        durationTimeFindById(params, options) {
            return exports.DurationTimeApiFp.durationTimeFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        durationTimeFindOne(params, options) {
            return exports.DurationTimeApiFp.durationTimeFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        durationTimePatchOrCreate(params, options) {
            return exports.DurationTimeApiFp.durationTimePatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation leader.
         * @param id DurationTime id
         * @param refresh
         */
        durationTimePrototypeGetLeader(params, options) {
            return exports.DurationTimeApiFp.durationTimePrototypeGetLeader(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id DurationTime id
         * @param data An object of model property name/value pairs
         */
        durationTimePrototypePatchAttributes(params, options) {
            return exports.DurationTimeApiFp.durationTimePrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        durationTimeReplaceByIdPostDurationTimesidReplace(params, options) {
            return exports.DurationTimeApiFp.durationTimeReplaceByIdPostDurationTimesidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        durationTimeReplaceByIdPutDurationTimesid(params, options) {
            return exports.DurationTimeApiFp.durationTimeReplaceByIdPutDurationTimesid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        durationTimeReplaceOrCreatePostDurationTimesReplaceOrCreate(params, options) {
            return exports.DurationTimeApiFp.durationTimeReplaceOrCreatePostDurationTimesReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        durationTimeReplaceOrCreatePutDurationTimes(params, options) {
            return exports.DurationTimeApiFp.durationTimeReplaceOrCreatePutDurationTimes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        durationTimeUpdateAll(params, options) {
            return exports.DurationTimeApiFp.durationTimeUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        durationTimeUpsertWithWhere(params, options) {
            return exports.DurationTimeApiFp.durationTimeUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.DurationTimeApiFactory = DurationTimeApiFactory;
/**
 * OrderApi - fetch parameter creator
 */
exports.OrderApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderCount(params, options) {
        const baseUrl = `/Orders/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderCreate(params, options) {
        const baseUrl = `/Orders`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderCreateChangeStreamGetOrdersChangeStream(params, options) {
        const baseUrl = `/Orders/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderCreateChangeStreamPostOrdersChangeStream(params, options) {
        const baseUrl = `/Orders/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderDeleteById");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsGetOrdersidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderExistsGetOrdersidExists");
        }
        const baseUrl = `/Orders/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsHeadOrdersid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderExistsHeadOrdersid");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFind(params, options) {
        const baseUrl = `/Orders`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderFindById");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFindOne(params, options) {
        const baseUrl = `/Orders/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderPatchOrCreate(params, options) {
        const baseUrl = `/Orders`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Order id
     * @param refresh
     */
    orderPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeGetAccount");
        }
        const baseUrl = `/Orders/{id}/account`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation durationTime.
     * @param id Order id
     * @param refresh
     */
    orderPrototypeGetDurationTime(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeGetDurationTime");
        }
        const baseUrl = `/Orders/{id}/durationTime`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation team.
     * @param id Order id
     * @param refresh
     */
    orderPrototypeGetTeam(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypeGetTeam");
        }
        const baseUrl = `/Orders/{id}/team`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Order id
     * @param data An object of model property name/value pairs
     */
    orderPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderPrototypePatchAttributes");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPostOrdersidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderReplaceByIdPostOrdersidReplace");
        }
        const baseUrl = `/Orders/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPutOrdersid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling orderReplaceByIdPutOrdersid");
        }
        const baseUrl = `/Orders/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options) {
        const baseUrl = `/Orders/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePutOrders(params, options) {
        const baseUrl = `/Orders`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpdateAll(params, options) {
        const baseUrl = `/Orders/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpsertWithWhere(params, options) {
        const baseUrl = `/Orders/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * OrderApi - functional programming interface
 */
exports.OrderApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderCount(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderCreate(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderCreateChangeStreamGetOrdersChangeStream(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderCreateChangeStreamGetOrdersChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderCreateChangeStreamPostOrdersChangeStream(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderCreateChangeStreamPostOrdersChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderDeleteById(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsGetOrdersidExists(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderExistsGetOrdersidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsHeadOrdersid(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderExistsHeadOrdersid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFind(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderFindById(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFindOne(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderPatchOrCreate(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Order id
     * @param refresh
     */
    orderPrototypeGetAccount(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation durationTime.
     * @param id Order id
     * @param refresh
     */
    orderPrototypeGetDurationTime(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPrototypeGetDurationTime(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation team.
     * @param id Order id
     * @param refresh
     */
    orderPrototypeGetTeam(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPrototypeGetTeam(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Order id
     * @param data An object of model property name/value pairs
     */
    orderPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPostOrdersidReplace(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderReplaceByIdPostOrdersidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPutOrdersid(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderReplaceByIdPutOrdersid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePutOrders(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderReplaceOrCreatePutOrders(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpdateAll(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpsertWithWhere(params, options) {
        const fetchArgs = exports.OrderApiFetchParamCreator.orderUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * OrderApi - object-oriented interface
 */
class OrderApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    orderCount(params, options) {
        return exports.OrderApiFp.orderCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    orderCreate(params, options) {
        return exports.OrderApiFp.orderCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderCreateChangeStreamGetOrdersChangeStream(params, options) {
        return exports.OrderApiFp.orderCreateChangeStreamGetOrdersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    orderCreateChangeStreamPostOrdersChangeStream(params, options) {
        return exports.OrderApiFp.orderCreateChangeStreamPostOrdersChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    orderDeleteById(params, options) {
        return exports.OrderApiFp.orderDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsGetOrdersidExists(params, options) {
        return exports.OrderApiFp.orderExistsGetOrdersidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    orderExistsHeadOrdersid(params, options) {
        return exports.OrderApiFp.orderExistsHeadOrdersid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFind(params, options) {
        return exports.OrderApiFp.orderFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    orderFindById(params, options) {
        return exports.OrderApiFp.orderFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    orderFindOne(params, options) {
        return exports.OrderApiFp.orderFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderPatchOrCreate(params, options) {
        return exports.OrderApiFp.orderPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Order id
     * @param refresh
     */
    orderPrototypeGetAccount(params, options) {
        return exports.OrderApiFp.orderPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation durationTime.
     * @param id Order id
     * @param refresh
     */
    orderPrototypeGetDurationTime(params, options) {
        return exports.OrderApiFp.orderPrototypeGetDurationTime(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation team.
     * @param id Order id
     * @param refresh
     */
    orderPrototypeGetTeam(params, options) {
        return exports.OrderApiFp.orderPrototypeGetTeam(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Order id
     * @param data An object of model property name/value pairs
     */
    orderPrototypePatchAttributes(params, options) {
        return exports.OrderApiFp.orderPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPostOrdersidReplace(params, options) {
        return exports.OrderApiFp.orderReplaceByIdPostOrdersidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    orderReplaceByIdPutOrdersid(params, options) {
        return exports.OrderApiFp.orderReplaceByIdPutOrdersid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options) {
        return exports.OrderApiFp.orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    orderReplaceOrCreatePutOrders(params, options) {
        return exports.OrderApiFp.orderReplaceOrCreatePutOrders(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpdateAll(params, options) {
        return exports.OrderApiFp.orderUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    orderUpsertWithWhere(params, options) {
        return exports.OrderApiFp.orderUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.OrderApi = OrderApi;
;
/**
 * OrderApi - factory interface
 */
const OrderApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        orderCount(params, options) {
            return exports.OrderApiFp.orderCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        orderCreate(params, options) {
            return exports.OrderApiFp.orderCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        orderCreateChangeStreamGetOrdersChangeStream(params, options) {
            return exports.OrderApiFp.orderCreateChangeStreamGetOrdersChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        orderCreateChangeStreamPostOrdersChangeStream(params, options) {
            return exports.OrderApiFp.orderCreateChangeStreamPostOrdersChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        orderDeleteById(params, options) {
            return exports.OrderApiFp.orderDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        orderExistsGetOrdersidExists(params, options) {
            return exports.OrderApiFp.orderExistsGetOrdersidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        orderExistsHeadOrdersid(params, options) {
            return exports.OrderApiFp.orderExistsHeadOrdersid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        orderFind(params, options) {
            return exports.OrderApiFp.orderFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        orderFindById(params, options) {
            return exports.OrderApiFp.orderFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        orderFindOne(params, options) {
            return exports.OrderApiFp.orderFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderPatchOrCreate(params, options) {
            return exports.OrderApiFp.orderPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id Order id
         * @param refresh
         */
        orderPrototypeGetAccount(params, options) {
            return exports.OrderApiFp.orderPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation durationTime.
         * @param id Order id
         * @param refresh
         */
        orderPrototypeGetDurationTime(params, options) {
            return exports.OrderApiFp.orderPrototypeGetDurationTime(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation team.
         * @param id Order id
         * @param refresh
         */
        orderPrototypeGetTeam(params, options) {
            return exports.OrderApiFp.orderPrototypeGetTeam(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Order id
         * @param data An object of model property name/value pairs
         */
        orderPrototypePatchAttributes(params, options) {
            return exports.OrderApiFp.orderPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        orderReplaceByIdPostOrdersidReplace(params, options) {
            return exports.OrderApiFp.orderReplaceByIdPostOrdersidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        orderReplaceByIdPutOrdersid(params, options) {
            return exports.OrderApiFp.orderReplaceByIdPutOrdersid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options) {
            return exports.OrderApiFp.orderReplaceOrCreatePostOrdersReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        orderReplaceOrCreatePutOrders(params, options) {
            return exports.OrderApiFp.orderReplaceOrCreatePutOrders(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        orderUpdateAll(params, options) {
            return exports.OrderApiFp.orderUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        orderUpsertWithWhere(params, options) {
            return exports.OrderApiFp.orderUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.OrderApiFactory = OrderApiFactory;
/**
 * TargetApi - fetch parameter creator
 */
exports.TargetApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    targetCount(params, options) {
        const baseUrl = `/Targets/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    targetCreate(params, options) {
        const baseUrl = `/Targets`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    targetCreateChangeStreamGetTargetsChangeStream(params, options) {
        const baseUrl = `/Targets/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    targetCreateChangeStreamPostTargetsChangeStream(params, options) {
        const baseUrl = `/Targets/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    targetDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling targetDeleteById");
        }
        const baseUrl = `/Targets/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    targetExistsGetTargetsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling targetExistsGetTargetsidExists");
        }
        const baseUrl = `/Targets/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    targetExistsHeadTargetsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling targetExistsHeadTargetsid");
        }
        const baseUrl = `/Targets/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    targetFind(params, options) {
        const baseUrl = `/Targets`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    targetFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling targetFindById");
        }
        const baseUrl = `/Targets/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    targetFindOne(params, options) {
        const baseUrl = `/Targets/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetPatchOrCreate(params, options) {
        const baseUrl = `/Targets`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Target id
     * @param refresh
     */
    targetPrototypeGetAccount(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling targetPrototypeGetAccount");
        }
        const baseUrl = `/Targets/{id}/account`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Target id
     * @param data An object of model property name/value pairs
     */
    targetPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling targetPrototypePatchAttributes");
        }
        const baseUrl = `/Targets/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    targetReplaceByIdPostTargetsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling targetReplaceByIdPostTargetsidReplace");
        }
        const baseUrl = `/Targets/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    targetReplaceByIdPutTargetsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling targetReplaceByIdPutTargetsid");
        }
        const baseUrl = `/Targets/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetReplaceOrCreatePostTargetsReplaceOrCreate(params, options) {
        const baseUrl = `/Targets/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetReplaceOrCreatePutTargets(params, options) {
        const baseUrl = `/Targets`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    targetUpdateAll(params, options) {
        const baseUrl = `/Targets/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    targetUpsertWithWhere(params, options) {
        const baseUrl = `/Targets/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * TargetApi - functional programming interface
 */
exports.TargetApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    targetCount(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    targetCreate(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    targetCreateChangeStreamGetTargetsChangeStream(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetCreateChangeStreamGetTargetsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    targetCreateChangeStreamPostTargetsChangeStream(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetCreateChangeStreamPostTargetsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    targetDeleteById(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    targetExistsGetTargetsidExists(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetExistsGetTargetsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    targetExistsHeadTargetsid(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetExistsHeadTargetsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    targetFind(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    targetFindById(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    targetFindOne(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetPatchOrCreate(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Target id
     * @param refresh
     */
    targetPrototypeGetAccount(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetPrototypeGetAccount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Target id
     * @param data An object of model property name/value pairs
     */
    targetPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    targetReplaceByIdPostTargetsidReplace(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetReplaceByIdPostTargetsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    targetReplaceByIdPutTargetsid(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetReplaceByIdPutTargetsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetReplaceOrCreatePostTargetsReplaceOrCreate(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetReplaceOrCreatePostTargetsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetReplaceOrCreatePutTargets(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetReplaceOrCreatePutTargets(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    targetUpdateAll(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    targetUpsertWithWhere(params, options) {
        const fetchArgs = exports.TargetApiFetchParamCreator.targetUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * TargetApi - object-oriented interface
 */
class TargetApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    targetCount(params, options) {
        return exports.TargetApiFp.targetCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    targetCreate(params, options) {
        return exports.TargetApiFp.targetCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    targetCreateChangeStreamGetTargetsChangeStream(params, options) {
        return exports.TargetApiFp.targetCreateChangeStreamGetTargetsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    targetCreateChangeStreamPostTargetsChangeStream(params, options) {
        return exports.TargetApiFp.targetCreateChangeStreamPostTargetsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    targetDeleteById(params, options) {
        return exports.TargetApiFp.targetDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    targetExistsGetTargetsidExists(params, options) {
        return exports.TargetApiFp.targetExistsGetTargetsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    targetExistsHeadTargetsid(params, options) {
        return exports.TargetApiFp.targetExistsHeadTargetsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    targetFind(params, options) {
        return exports.TargetApiFp.targetFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    targetFindById(params, options) {
        return exports.TargetApiFp.targetFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    targetFindOne(params, options) {
        return exports.TargetApiFp.targetFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetPatchOrCreate(params, options) {
        return exports.TargetApiFp.targetPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation account.
     * @param id Target id
     * @param refresh
     */
    targetPrototypeGetAccount(params, options) {
        return exports.TargetApiFp.targetPrototypeGetAccount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Target id
     * @param data An object of model property name/value pairs
     */
    targetPrototypePatchAttributes(params, options) {
        return exports.TargetApiFp.targetPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    targetReplaceByIdPostTargetsidReplace(params, options) {
        return exports.TargetApiFp.targetReplaceByIdPostTargetsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    targetReplaceByIdPutTargetsid(params, options) {
        return exports.TargetApiFp.targetReplaceByIdPutTargetsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetReplaceOrCreatePostTargetsReplaceOrCreate(params, options) {
        return exports.TargetApiFp.targetReplaceOrCreatePostTargetsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    targetReplaceOrCreatePutTargets(params, options) {
        return exports.TargetApiFp.targetReplaceOrCreatePutTargets(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    targetUpdateAll(params, options) {
        return exports.TargetApiFp.targetUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    targetUpsertWithWhere(params, options) {
        return exports.TargetApiFp.targetUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.TargetApi = TargetApi;
;
/**
 * TargetApi - factory interface
 */
const TargetApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        targetCount(params, options) {
            return exports.TargetApiFp.targetCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        targetCreate(params, options) {
            return exports.TargetApiFp.targetCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        targetCreateChangeStreamGetTargetsChangeStream(params, options) {
            return exports.TargetApiFp.targetCreateChangeStreamGetTargetsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        targetCreateChangeStreamPostTargetsChangeStream(params, options) {
            return exports.TargetApiFp.targetCreateChangeStreamPostTargetsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        targetDeleteById(params, options) {
            return exports.TargetApiFp.targetDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        targetExistsGetTargetsidExists(params, options) {
            return exports.TargetApiFp.targetExistsGetTargetsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        targetExistsHeadTargetsid(params, options) {
            return exports.TargetApiFp.targetExistsHeadTargetsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        targetFind(params, options) {
            return exports.TargetApiFp.targetFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        targetFindById(params, options) {
            return exports.TargetApiFp.targetFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        targetFindOne(params, options) {
            return exports.TargetApiFp.targetFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        targetPatchOrCreate(params, options) {
            return exports.TargetApiFp.targetPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation account.
         * @param id Target id
         * @param refresh
         */
        targetPrototypeGetAccount(params, options) {
            return exports.TargetApiFp.targetPrototypeGetAccount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Target id
         * @param data An object of model property name/value pairs
         */
        targetPrototypePatchAttributes(params, options) {
            return exports.TargetApiFp.targetPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        targetReplaceByIdPostTargetsidReplace(params, options) {
            return exports.TargetApiFp.targetReplaceByIdPostTargetsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        targetReplaceByIdPutTargetsid(params, options) {
            return exports.TargetApiFp.targetReplaceByIdPutTargetsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        targetReplaceOrCreatePostTargetsReplaceOrCreate(params, options) {
            return exports.TargetApiFp.targetReplaceOrCreatePostTargetsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        targetReplaceOrCreatePutTargets(params, options) {
            return exports.TargetApiFp.targetReplaceOrCreatePutTargets(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        targetUpdateAll(params, options) {
            return exports.TargetApiFp.targetUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        targetUpsertWithWhere(params, options) {
            return exports.TargetApiFp.targetUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.TargetApiFactory = TargetApiFactory;
/**
 * TeamApi - fetch parameter creator
 */
exports.TeamApiFetchParamCreator = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    teamCount(params, options) {
        const baseUrl = `/Teams/count`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    teamCreate(params, options) {
        const baseUrl = `/Teams`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    teamCreateChangeStreamGetTeamsChangeStream(params, options) {
        const baseUrl = `/Teams/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "options": params["options"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    teamCreateChangeStreamPostTeamsChangeStream(params, options) {
        const baseUrl = `/Teams/change-stream`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "options": params["options"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    teamDeleteById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamDeleteById");
        }
        const baseUrl = `/Teams/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    teamExistsGetTeamsidExists(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamExistsGetTeamsidExists");
        }
        const baseUrl = `/Teams/{id}/exists`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    teamExistsHeadTeamsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamExistsHeadTeamsid");
        }
        const baseUrl = `/Teams/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "HEAD" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    teamFind(params, options) {
        const baseUrl = `/Teams`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    teamFindById(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamFindById");
        }
        const baseUrl = `/Teams/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    teamFindOne(params, options) {
        const baseUrl = `/Teams/findOne`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamPatchOrCreate(params, options) {
        const baseUrl = `/Teams`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Counts members of Team.
     * @param id Team id
     * @param where Criteria to match model instances
     */
    teamPrototypeCountMembers(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypeCountMembers");
        }
        const baseUrl = `/Teams/{id}/members/count`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Creates a new instance in members of this model.
     * @param id Team id
     * @param data
     */
    teamPrototypeCreateMembers(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypeCreateMembers");
        }
        const baseUrl = `/Teams/{id}/members`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Deletes all members of this model.
     * @param id Team id
     */
    teamPrototypeDeleteMembers(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypeDeleteMembers");
        }
        const baseUrl = `/Teams/{id}/members`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Delete a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     */
    teamPrototypeDestroyByIdMembers(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypeDestroyByIdMembers");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling teamPrototypeDestroyByIdMembers");
        }
        const baseUrl = `/Teams/{id}/members/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "DELETE" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Find a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     */
    teamPrototypeFindByIdMembers(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypeFindByIdMembers");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling teamPrototypeFindByIdMembers");
        }
        const baseUrl = `/Teams/{id}/members/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation leader.
     * @param id Team id
     * @param refresh
     */
    teamPrototypeGetLeader(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypeGetLeader");
        }
        const baseUrl = `/Teams/{id}/leader`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "refresh": params["refresh"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Queries members of Team.
     * @param id Team id
     * @param filter
     */
    teamPrototypeGetMembers(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypeGetMembers");
        }
        const baseUrl = `/Teams/{id}/members`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
        });
        let fetchOptions = assign({}, { method: "GET" }, options);
        let contentTypeHeader = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Team id
     * @param data An object of model property name/value pairs
     */
    teamPrototypePatchAttributes(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypePatchAttributes");
        }
        const baseUrl = `/Teams/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PATCH" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     * @param data
     */
    teamPrototypeUpdateByIdMembers(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamPrototypeUpdateByIdMembers");
        }
        // verify required parameter "fk" is set
        if (params["fk"] == null) {
            throw new Error("Missing required parameter fk when calling teamPrototypeUpdateByIdMembers");
        }
        const baseUrl = `/Teams/{id}/members/{fk}`
            .replace(`{${"id"}}`, `${params["id"]}`)
            .replace(`{${"fk"}}`, `${params["fk"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    teamReplaceByIdPostTeamsidReplace(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamReplaceByIdPostTeamsidReplace");
        }
        const baseUrl = `/Teams/{id}/replace`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    teamReplaceByIdPutTeamsid(params, options) {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling teamReplaceByIdPutTeamsid");
        }
        const baseUrl = `/Teams/{id}`
            .replace(`{${"id"}}`, `${params["id"]}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamReplaceOrCreatePostTeamsReplaceOrCreate(params, options) {
        const baseUrl = `/Teams/replaceOrCreate`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamReplaceOrCreatePutTeams(params, options) {
        const baseUrl = `/Teams`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions = assign({}, { method: "PUT" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    teamUpdateAll(params, options) {
        const baseUrl = `/Teams/update`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    teamUpsertWithWhere(params, options) {
        const baseUrl = `/Teams/upsertWithWhere`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "where": params["where"],
        });
        let fetchOptions = assign({}, { method: "POST" }, options);
        let contentTypeHeader = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};
/**
 * TeamApi - functional programming interface
 */
exports.TeamApiFp = {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    teamCount(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamCount(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    teamCreate(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    teamCreateChangeStreamGetTeamsChangeStream(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamCreateChangeStreamGetTeamsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    teamCreateChangeStreamPostTeamsChangeStream(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamCreateChangeStreamPostTeamsChangeStream(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    teamDeleteById(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamDeleteById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    teamExistsGetTeamsidExists(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamExistsGetTeamsidExists(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    teamExistsHeadTeamsid(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamExistsHeadTeamsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    teamFind(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamFind(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    teamFindById(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamFindById(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    teamFindOne(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamFindOne(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamPatchOrCreate(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamPatchOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Counts members of Team.
     * @param id Team id
     * @param where Criteria to match model instances
     */
    teamPrototypeCountMembers(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamPrototypeCountMembers(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Creates a new instance in members of this model.
     * @param id Team id
     * @param data
     */
    teamPrototypeCreateMembers(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamPrototypeCreateMembers(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Deletes all members of this model.
     * @param id Team id
     */
    teamPrototypeDeleteMembers(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamPrototypeDeleteMembers(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Delete a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     */
    teamPrototypeDestroyByIdMembers(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamPrototypeDestroyByIdMembers(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Find a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     */
    teamPrototypeFindByIdMembers(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamPrototypeFindByIdMembers(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Fetches belongsTo relation leader.
     * @param id Team id
     * @param refresh
     */
    teamPrototypeGetLeader(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamPrototypeGetLeader(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Queries members of Team.
     * @param id Team id
     * @param filter
     */
    teamPrototypeGetMembers(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamPrototypeGetMembers(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Team id
     * @param data An object of model property name/value pairs
     */
    teamPrototypePatchAttributes(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamPrototypePatchAttributes(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     * @param data
     */
    teamPrototypeUpdateByIdMembers(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamPrototypeUpdateByIdMembers(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    teamReplaceByIdPostTeamsidReplace(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamReplaceByIdPostTeamsidReplace(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    teamReplaceByIdPutTeamsid(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamReplaceByIdPutTeamsid(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamReplaceOrCreatePostTeamsReplaceOrCreate(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamReplaceOrCreatePostTeamsReplaceOrCreate(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamReplaceOrCreatePutTeams(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamReplaceOrCreatePutTeams(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    teamUpdateAll(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamUpdateAll(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    teamUpsertWithWhere(params, options) {
        const fetchArgs = exports.TeamApiFetchParamCreator.teamUpsertWithWhere(params, options);
        return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                }
                else {
                    throw response;
                }
            });
        };
    },
};
/**
 * TeamApi - object-oriented interface
 */
class TeamApi extends BaseAPI {
    /**
     *
     * @summary Count instances of the model matched by where from the data source.
     * @param where Criteria to match model instances
     */
    teamCount(params, options) {
        return exports.TeamApiFp.teamCount(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a new instance of the model and persist it into the data source.
     * @param data Model instance data
     */
    teamCreate(params, options) {
        return exports.TeamApiFp.teamCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    teamCreateChangeStreamGetTeamsChangeStream(params, options) {
        return exports.TeamApiFp.teamCreateChangeStreamGetTeamsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Create a change stream.
     * @param options
     */
    teamCreateChangeStreamPostTeamsChangeStream(params, options) {
        return exports.TeamApiFp.teamCreateChangeStreamPostTeamsChangeStream(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a model instance by {{id}} from the data source.
     * @param id Model id
     */
    teamDeleteById(params, options) {
        return exports.TeamApiFp.teamDeleteById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    teamExistsGetTeamsidExists(params, options) {
        return exports.TeamApiFp.teamExistsGetTeamsidExists(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Check whether a model instance exists in the data source.
     * @param id Model id
     */
    teamExistsHeadTeamsid(params, options) {
        return exports.TeamApiFp.teamExistsHeadTeamsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find all instances of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    teamFind(params, options) {
        return exports.TeamApiFp.teamFind(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a model instance by {{id}} from the data source.
     * @param id Model id
     * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
     */
    teamFindById(params, options) {
        return exports.TeamApiFp.teamFindById(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find first instance of the model matched by filter from the data source.
     * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
     */
    teamFindOne(params, options) {
        return exports.TeamApiFp.teamFindOne(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamPatchOrCreate(params, options) {
        return exports.TeamApiFp.teamPatchOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Counts members of Team.
     * @param id Team id
     * @param where Criteria to match model instances
     */
    teamPrototypeCountMembers(params, options) {
        return exports.TeamApiFp.teamPrototypeCountMembers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Creates a new instance in members of this model.
     * @param id Team id
     * @param data
     */
    teamPrototypeCreateMembers(params, options) {
        return exports.TeamApiFp.teamPrototypeCreateMembers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Deletes all members of this model.
     * @param id Team id
     */
    teamPrototypeDeleteMembers(params, options) {
        return exports.TeamApiFp.teamPrototypeDeleteMembers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Delete a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     */
    teamPrototypeDestroyByIdMembers(params, options) {
        return exports.TeamApiFp.teamPrototypeDestroyByIdMembers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Find a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     */
    teamPrototypeFindByIdMembers(params, options) {
        return exports.TeamApiFp.teamPrototypeFindByIdMembers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Fetches belongsTo relation leader.
     * @param id Team id
     * @param refresh
     */
    teamPrototypeGetLeader(params, options) {
        return exports.TeamApiFp.teamPrototypeGetLeader(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Queries members of Team.
     * @param id Team id
     * @param filter
     */
    teamPrototypeGetMembers(params, options) {
        return exports.TeamApiFp.teamPrototypeGetMembers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Patch attributes for a model instance and persist it into the data source.
     * @param id Team id
     * @param data An object of model property name/value pairs
     */
    teamPrototypePatchAttributes(params, options) {
        return exports.TeamApiFp.teamPrototypePatchAttributes(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update a related item by id for members.
     * @param id Team id
     * @param fk Foreign key for members
     * @param data
     */
    teamPrototypeUpdateByIdMembers(params, options) {
        return exports.TeamApiFp.teamPrototypeUpdateByIdMembers(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    teamReplaceByIdPostTeamsidReplace(params, options) {
        return exports.TeamApiFp.teamReplaceByIdPostTeamsidReplace(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace attributes for a model instance and persist it into the data source.
     * @param id Model id
     * @param data Model instance data
     */
    teamReplaceByIdPutTeamsid(params, options) {
        return exports.TeamApiFp.teamReplaceByIdPutTeamsid(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamReplaceOrCreatePostTeamsReplaceOrCreate(params, options) {
        return exports.TeamApiFp.teamReplaceOrCreatePostTeamsReplaceOrCreate(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Replace an existing model instance or insert a new one into the data source.
     * @param data Model instance data
     */
    teamReplaceOrCreatePutTeams(params, options) {
        return exports.TeamApiFp.teamReplaceOrCreatePutTeams(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update instances of the model matched by {{where}} from the data source.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    teamUpdateAll(params, options) {
        return exports.TeamApiFp.teamUpdateAll(params, options)(this.fetch, this.basePath);
    }
    /**
     *
     * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
     * @param where Criteria to match model instances
     * @param data An object of model property name/value pairs
     */
    teamUpsertWithWhere(params, options) {
        return exports.TeamApiFp.teamUpsertWithWhere(params, options)(this.fetch, this.basePath);
    }
}
exports.TeamApi = TeamApi;
;
/**
 * TeamApi - factory interface
 */
const TeamApiFactory = function (fetch, basePath) {
    return {
        /**
         *
         * @summary Count instances of the model matched by where from the data source.
         * @param where Criteria to match model instances
         */
        teamCount(params, options) {
            return exports.TeamApiFp.teamCount(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a new instance of the model and persist it into the data source.
         * @param data Model instance data
         */
        teamCreate(params, options) {
            return exports.TeamApiFp.teamCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        teamCreateChangeStreamGetTeamsChangeStream(params, options) {
            return exports.TeamApiFp.teamCreateChangeStreamGetTeamsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Create a change stream.
         * @param options
         */
        teamCreateChangeStreamPostTeamsChangeStream(params, options) {
            return exports.TeamApiFp.teamCreateChangeStreamPostTeamsChangeStream(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a model instance by {{id}} from the data source.
         * @param id Model id
         */
        teamDeleteById(params, options) {
            return exports.TeamApiFp.teamDeleteById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        teamExistsGetTeamsidExists(params, options) {
            return exports.TeamApiFp.teamExistsGetTeamsidExists(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Check whether a model instance exists in the data source.
         * @param id Model id
         */
        teamExistsHeadTeamsid(params, options) {
            return exports.TeamApiFp.teamExistsHeadTeamsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find all instances of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        teamFind(params, options) {
            return exports.TeamApiFp.teamFind(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a model instance by {{id}} from the data source.
         * @param id Model id
         * @param filter Filter defining fields and include - must be a JSON-encoded string ({\&quot;something\&quot;:\&quot;value\&quot;})
         */
        teamFindById(params, options) {
            return exports.TeamApiFp.teamFindById(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find first instance of the model matched by filter from the data source.
         * @param filter Filter defining fields, where, include, order, offset, and limit - must be a JSON-encoded string (&#x60;{\&quot;where\&quot;:{\&quot;something\&quot;:\&quot;value\&quot;}}&#x60;).  See https://loopback.io/doc/en/lb3/Querying-data.html#using-stringified-json-in-rest-queries for more details.
         */
        teamFindOne(params, options) {
            return exports.TeamApiFp.teamFindOne(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        teamPatchOrCreate(params, options) {
            return exports.TeamApiFp.teamPatchOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Counts members of Team.
         * @param id Team id
         * @param where Criteria to match model instances
         */
        teamPrototypeCountMembers(params, options) {
            return exports.TeamApiFp.teamPrototypeCountMembers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Creates a new instance in members of this model.
         * @param id Team id
         * @param data
         */
        teamPrototypeCreateMembers(params, options) {
            return exports.TeamApiFp.teamPrototypeCreateMembers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Deletes all members of this model.
         * @param id Team id
         */
        teamPrototypeDeleteMembers(params, options) {
            return exports.TeamApiFp.teamPrototypeDeleteMembers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Delete a related item by id for members.
         * @param id Team id
         * @param fk Foreign key for members
         */
        teamPrototypeDestroyByIdMembers(params, options) {
            return exports.TeamApiFp.teamPrototypeDestroyByIdMembers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Find a related item by id for members.
         * @param id Team id
         * @param fk Foreign key for members
         */
        teamPrototypeFindByIdMembers(params, options) {
            return exports.TeamApiFp.teamPrototypeFindByIdMembers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Fetches belongsTo relation leader.
         * @param id Team id
         * @param refresh
         */
        teamPrototypeGetLeader(params, options) {
            return exports.TeamApiFp.teamPrototypeGetLeader(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Queries members of Team.
         * @param id Team id
         * @param filter
         */
        teamPrototypeGetMembers(params, options) {
            return exports.TeamApiFp.teamPrototypeGetMembers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Patch attributes for a model instance and persist it into the data source.
         * @param id Team id
         * @param data An object of model property name/value pairs
         */
        teamPrototypePatchAttributes(params, options) {
            return exports.TeamApiFp.teamPrototypePatchAttributes(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update a related item by id for members.
         * @param id Team id
         * @param fk Foreign key for members
         * @param data
         */
        teamPrototypeUpdateByIdMembers(params, options) {
            return exports.TeamApiFp.teamPrototypeUpdateByIdMembers(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        teamReplaceByIdPostTeamsidReplace(params, options) {
            return exports.TeamApiFp.teamReplaceByIdPostTeamsidReplace(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace attributes for a model instance and persist it into the data source.
         * @param id Model id
         * @param data Model instance data
         */
        teamReplaceByIdPutTeamsid(params, options) {
            return exports.TeamApiFp.teamReplaceByIdPutTeamsid(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        teamReplaceOrCreatePostTeamsReplaceOrCreate(params, options) {
            return exports.TeamApiFp.teamReplaceOrCreatePostTeamsReplaceOrCreate(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Replace an existing model instance or insert a new one into the data source.
         * @param data Model instance data
         */
        teamReplaceOrCreatePutTeams(params, options) {
            return exports.TeamApiFp.teamReplaceOrCreatePutTeams(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update instances of the model matched by {{where}} from the data source.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        teamUpdateAll(params, options) {
            return exports.TeamApiFp.teamUpdateAll(params, options)(fetch, basePath);
        },
        /**
         *
         * @summary Update an existing model instance or insert a new one into the data source based on the where criteria.
         * @param where Criteria to match model instances
         * @param data An object of model property name/value pairs
         */
        teamUpsertWithWhere(params, options) {
            return exports.TeamApiFp.teamUpsertWithWhere(params, options)(fetch, basePath);
        },
    };
};
exports.TeamApiFactory = TeamApiFactory;
//# sourceMappingURL=api.js.map